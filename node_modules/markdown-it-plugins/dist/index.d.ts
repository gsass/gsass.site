import require$$8 from 'punycode';

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var utils$1 = {};

const Aacute = "Á";
const aacute = "á";
const Abreve = "Ă";
const abreve = "ă";
const ac = "∾";
const acd = "∿";
const acE = "∾̳";
const Acirc = "Â";
const acirc = "â";
const acute = "´";
const Acy = "А";
const acy = "а";
const AElig = "Æ";
const aelig = "æ";
const af = "⁡";
const Afr = "𝔄";
const afr = "𝔞";
const Agrave = "À";
const agrave = "à";
const alefsym = "ℵ";
const aleph = "ℵ";
const Alpha = "Α";
const alpha = "α";
const Amacr = "Ā";
const amacr = "ā";
const amalg = "⨿";
const amp = "&";
const AMP = "&";
const andand = "⩕";
const And = "⩓";
const and = "∧";
const andd = "⩜";
const andslope = "⩘";
const andv = "⩚";
const ang = "∠";
const ange = "⦤";
const angle = "∠";
const angmsdaa = "⦨";
const angmsdab = "⦩";
const angmsdac = "⦪";
const angmsdad = "⦫";
const angmsdae = "⦬";
const angmsdaf = "⦭";
const angmsdag = "⦮";
const angmsdah = "⦯";
const angmsd = "∡";
const angrt = "∟";
const angrtvb = "⊾";
const angrtvbd = "⦝";
const angsph = "∢";
const angst = "Å";
const angzarr = "⍼";
const Aogon = "Ą";
const aogon = "ą";
const Aopf = "𝔸";
const aopf = "𝕒";
const apacir = "⩯";
const ap = "≈";
const apE = "⩰";
const ape = "≊";
const apid = "≋";
const apos = "'";
const ApplyFunction = "⁡";
const approx = "≈";
const approxeq = "≊";
const Aring = "Å";
const aring = "å";
const Ascr = "𝒜";
const ascr = "𝒶";
const Assign = "≔";
const ast = "*";
const asymp = "≈";
const asympeq = "≍";
const Atilde = "Ã";
const atilde = "ã";
const Auml = "Ä";
const auml = "ä";
const awconint = "∳";
const awint = "⨑";
const backcong = "≌";
const backepsilon = "϶";
const backprime = "‵";
const backsim = "∽";
const backsimeq = "⋍";
const Backslash = "∖";
const Barv = "⫧";
const barvee = "⊽";
const barwed = "⌅";
const Barwed = "⌆";
const barwedge = "⌅";
const bbrk = "⎵";
const bbrktbrk = "⎶";
const bcong = "≌";
const Bcy = "Б";
const bcy = "б";
const bdquo = "„";
const becaus = "∵";
const because = "∵";
const Because = "∵";
const bemptyv = "⦰";
const bepsi = "϶";
const bernou = "ℬ";
const Bernoullis = "ℬ";
const Beta = "Β";
const beta = "β";
const beth = "ℶ";
const between = "≬";
const Bfr = "𝔅";
const bfr = "𝔟";
const bigcap = "⋂";
const bigcirc = "◯";
const bigcup = "⋃";
const bigodot = "⨀";
const bigoplus = "⨁";
const bigotimes = "⨂";
const bigsqcup = "⨆";
const bigstar = "★";
const bigtriangledown = "▽";
const bigtriangleup = "△";
const biguplus = "⨄";
const bigvee = "⋁";
const bigwedge = "⋀";
const bkarow = "⤍";
const blacklozenge = "⧫";
const blacksquare = "▪";
const blacktriangle = "▴";
const blacktriangledown = "▾";
const blacktriangleleft = "◂";
const blacktriangleright = "▸";
const blank = "␣";
const blk12 = "▒";
const blk14 = "░";
const blk34 = "▓";
const block$1 = "█";
const bne = "=⃥";
const bnequiv = "≡⃥";
const bNot = "⫭";
const bnot = "⌐";
const Bopf = "𝔹";
const bopf = "𝕓";
const bot = "⊥";
const bottom = "⊥";
const bowtie = "⋈";
const boxbox = "⧉";
const boxdl = "┐";
const boxdL = "╕";
const boxDl = "╖";
const boxDL = "╗";
const boxdr = "┌";
const boxdR = "╒";
const boxDr = "╓";
const boxDR = "╔";
const boxh = "─";
const boxH = "═";
const boxhd = "┬";
const boxHd = "╤";
const boxhD = "╥";
const boxHD = "╦";
const boxhu = "┴";
const boxHu = "╧";
const boxhU = "╨";
const boxHU = "╩";
const boxminus = "⊟";
const boxplus = "⊞";
const boxtimes = "⊠";
const boxul = "┘";
const boxuL = "╛";
const boxUl = "╜";
const boxUL = "╝";
const boxur = "└";
const boxuR = "╘";
const boxUr = "╙";
const boxUR = "╚";
const boxv = "│";
const boxV = "║";
const boxvh = "┼";
const boxvH = "╪";
const boxVh = "╫";
const boxVH = "╬";
const boxvl = "┤";
const boxvL = "╡";
const boxVl = "╢";
const boxVL = "╣";
const boxvr = "├";
const boxvR = "╞";
const boxVr = "╟";
const boxVR = "╠";
const bprime = "‵";
const breve = "˘";
const Breve = "˘";
const brvbar = "¦";
const bscr = "𝒷";
const Bscr = "ℬ";
const bsemi = "⁏";
const bsim = "∽";
const bsime = "⋍";
const bsolb = "⧅";
const bsol = "\\";
const bsolhsub = "⟈";
const bull = "•";
const bullet = "•";
const bump = "≎";
const bumpE = "⪮";
const bumpe = "≏";
const Bumpeq = "≎";
const bumpeq = "≏";
const Cacute = "Ć";
const cacute = "ć";
const capand = "⩄";
const capbrcup = "⩉";
const capcap = "⩋";
const cap = "∩";
const Cap = "⋒";
const capcup = "⩇";
const capdot = "⩀";
const CapitalDifferentialD = "ⅅ";
const caps = "∩︀";
const caret = "⁁";
const caron = "ˇ";
const Cayleys = "ℭ";
const ccaps = "⩍";
const Ccaron = "Č";
const ccaron = "č";
const Ccedil = "Ç";
const ccedil = "ç";
const Ccirc = "Ĉ";
const ccirc = "ĉ";
const Cconint = "∰";
const ccups = "⩌";
const ccupssm = "⩐";
const Cdot = "Ċ";
const cdot = "ċ";
const cedil = "¸";
const Cedilla = "¸";
const cemptyv = "⦲";
const cent = "¢";
const centerdot = "·";
const CenterDot = "·";
const cfr = "𝔠";
const Cfr = "ℭ";
const CHcy = "Ч";
const chcy = "ч";
const check = "✓";
const checkmark = "✓";
const Chi = "Χ";
const chi = "χ";
const circ = "ˆ";
const circeq = "≗";
const circlearrowleft = "↺";
const circlearrowright = "↻";
const circledast = "⊛";
const circledcirc = "⊚";
const circleddash = "⊝";
const CircleDot = "⊙";
const circledR = "®";
const circledS = "Ⓢ";
const CircleMinus = "⊖";
const CirclePlus = "⊕";
const CircleTimes = "⊗";
const cir = "○";
const cirE = "⧃";
const cire = "≗";
const cirfnint = "⨐";
const cirmid = "⫯";
const cirscir = "⧂";
const ClockwiseContourIntegral = "∲";
const CloseCurlyDoubleQuote = "”";
const CloseCurlyQuote = "’";
const clubs = "♣";
const clubsuit = "♣";
const colon = ":";
const Colon = "∷";
const Colone = "⩴";
const colone = "≔";
const coloneq = "≔";
const comma = ",";
const commat = "@";
const comp = "∁";
const compfn = "∘";
const complement = "∁";
const complexes = "ℂ";
const cong = "≅";
const congdot = "⩭";
const Congruent = "≡";
const conint = "∮";
const Conint = "∯";
const ContourIntegral = "∮";
const copf = "𝕔";
const Copf = "ℂ";
const coprod = "∐";
const Coproduct = "∐";
const copy = "©";
const COPY = "©";
const copysr = "℗";
const CounterClockwiseContourIntegral = "∳";
const crarr = "↵";
const cross = "✗";
const Cross = "⨯";
const Cscr = "𝒞";
const cscr = "𝒸";
const csub = "⫏";
const csube = "⫑";
const csup = "⫐";
const csupe = "⫒";
const ctdot = "⋯";
const cudarrl = "⤸";
const cudarrr = "⤵";
const cuepr = "⋞";
const cuesc = "⋟";
const cularr = "↶";
const cularrp = "⤽";
const cupbrcap = "⩈";
const cupcap = "⩆";
const CupCap = "≍";
const cup = "∪";
const Cup = "⋓";
const cupcup = "⩊";
const cupdot = "⊍";
const cupor = "⩅";
const cups = "∪︀";
const curarr = "↷";
const curarrm = "⤼";
const curlyeqprec = "⋞";
const curlyeqsucc = "⋟";
const curlyvee = "⋎";
const curlywedge = "⋏";
const curren = "¤";
const curvearrowleft = "↶";
const curvearrowright = "↷";
const cuvee = "⋎";
const cuwed = "⋏";
const cwconint = "∲";
const cwint = "∱";
const cylcty = "⌭";
const dagger = "†";
const Dagger = "‡";
const daleth = "ℸ";
const darr = "↓";
const Darr = "↡";
const dArr = "⇓";
const dash = "‐";
const Dashv = "⫤";
const dashv = "⊣";
const dbkarow = "⤏";
const dblac = "˝";
const Dcaron = "Ď";
const dcaron = "ď";
const Dcy = "Д";
const dcy = "д";
const ddagger = "‡";
const ddarr = "⇊";
const DD = "ⅅ";
const dd = "ⅆ";
const DDotrahd = "⤑";
const ddotseq = "⩷";
const deg = "°";
const Del = "∇";
const Delta = "Δ";
const delta = "δ";
const demptyv = "⦱";
const dfisht = "⥿";
const Dfr = "𝔇";
const dfr = "𝔡";
const dHar = "⥥";
const dharl = "⇃";
const dharr = "⇂";
const DiacriticalAcute = "´";
const DiacriticalDot = "˙";
const DiacriticalDoubleAcute = "˝";
const DiacriticalGrave = "`";
const DiacriticalTilde = "˜";
const diam = "⋄";
const diamond = "⋄";
const Diamond = "⋄";
const diamondsuit = "♦";
const diams = "♦";
const die = "¨";
const DifferentialD = "ⅆ";
const digamma = "ϝ";
const disin = "⋲";
const div = "÷";
const divide = "÷";
const divideontimes = "⋇";
const divonx = "⋇";
const DJcy = "Ђ";
const djcy = "ђ";
const dlcorn = "⌞";
const dlcrop = "⌍";
const dollar = "$";
const Dopf = "𝔻";
const dopf = "𝕕";
const Dot = "¨";
const dot = "˙";
const DotDot = "⃜";
const doteq = "≐";
const doteqdot = "≑";
const DotEqual = "≐";
const dotminus = "∸";
const dotplus = "∔";
const dotsquare = "⊡";
const doublebarwedge = "⌆";
const DoubleContourIntegral = "∯";
const DoubleDot = "¨";
const DoubleDownArrow = "⇓";
const DoubleLeftArrow = "⇐";
const DoubleLeftRightArrow = "⇔";
const DoubleLeftTee = "⫤";
const DoubleLongLeftArrow = "⟸";
const DoubleLongLeftRightArrow = "⟺";
const DoubleLongRightArrow = "⟹";
const DoubleRightArrow = "⇒";
const DoubleRightTee = "⊨";
const DoubleUpArrow = "⇑";
const DoubleUpDownArrow = "⇕";
const DoubleVerticalBar = "∥";
const DownArrowBar = "⤓";
const downarrow = "↓";
const DownArrow = "↓";
const Downarrow = "⇓";
const DownArrowUpArrow = "⇵";
const DownBreve = "̑";
const downdownarrows = "⇊";
const downharpoonleft = "⇃";
const downharpoonright = "⇂";
const DownLeftRightVector = "⥐";
const DownLeftTeeVector = "⥞";
const DownLeftVectorBar = "⥖";
const DownLeftVector = "↽";
const DownRightTeeVector = "⥟";
const DownRightVectorBar = "⥗";
const DownRightVector = "⇁";
const DownTeeArrow = "↧";
const DownTee = "⊤";
const drbkarow = "⤐";
const drcorn = "⌟";
const drcrop = "⌌";
const Dscr = "𝒟";
const dscr = "𝒹";
const DScy = "Ѕ";
const dscy = "ѕ";
const dsol = "⧶";
const Dstrok = "Đ";
const dstrok = "đ";
const dtdot = "⋱";
const dtri = "▿";
const dtrif = "▾";
const duarr = "⇵";
const duhar = "⥯";
const dwangle = "⦦";
const DZcy = "Џ";
const dzcy = "џ";
const dzigrarr = "⟿";
const Eacute = "É";
const eacute = "é";
const easter = "⩮";
const Ecaron = "Ě";
const ecaron = "ě";
const Ecirc = "Ê";
const ecirc = "ê";
const ecir = "≖";
const ecolon = "≕";
const Ecy = "Э";
const ecy = "э";
const eDDot = "⩷";
const Edot = "Ė";
const edot = "ė";
const eDot = "≑";
const ee = "ⅇ";
const efDot = "≒";
const Efr = "𝔈";
const efr = "𝔢";
const eg = "⪚";
const Egrave = "È";
const egrave = "è";
const egs = "⪖";
const egsdot = "⪘";
const el = "⪙";
const Element = "∈";
const elinters = "⏧";
const ell = "ℓ";
const els = "⪕";
const elsdot = "⪗";
const Emacr = "Ē";
const emacr = "ē";
const empty = "∅";
const emptyset = "∅";
const EmptySmallSquare = "◻";
const emptyv = "∅";
const EmptyVerySmallSquare = "▫";
const emsp13 = " ";
const emsp14 = " ";
const emsp = " ";
const ENG = "Ŋ";
const eng = "ŋ";
const ensp = " ";
const Eogon = "Ę";
const eogon = "ę";
const Eopf = "𝔼";
const eopf = "𝕖";
const epar = "⋕";
const eparsl = "⧣";
const eplus = "⩱";
const epsi = "ε";
const Epsilon = "Ε";
const epsilon = "ε";
const epsiv = "ϵ";
const eqcirc = "≖";
const eqcolon = "≕";
const eqsim = "≂";
const eqslantgtr = "⪖";
const eqslantless = "⪕";
const Equal = "⩵";
const equals = "=";
const EqualTilde = "≂";
const equest = "≟";
const Equilibrium = "⇌";
const equiv = "≡";
const equivDD = "⩸";
const eqvparsl = "⧥";
const erarr = "⥱";
const erDot = "≓";
const escr = "ℯ";
const Escr = "ℰ";
const esdot = "≐";
const Esim = "⩳";
const esim = "≂";
const Eta = "Η";
const eta = "η";
const ETH = "Ð";
const eth = "ð";
const Euml = "Ë";
const euml = "ë";
const euro = "€";
const excl = "!";
const exist = "∃";
const Exists = "∃";
const expectation = "ℰ";
const exponentiale = "ⅇ";
const ExponentialE = "ⅇ";
const fallingdotseq = "≒";
const Fcy = "Ф";
const fcy = "ф";
const female = "♀";
const ffilig = "ﬃ";
const fflig = "ﬀ";
const ffllig = "ﬄ";
const Ffr = "𝔉";
const ffr = "𝔣";
const filig = "ﬁ";
const FilledSmallSquare = "◼";
const FilledVerySmallSquare = "▪";
const fjlig = "fj";
const flat = "♭";
const fllig = "ﬂ";
const fltns = "▱";
const fnof = "ƒ";
const Fopf = "𝔽";
const fopf = "𝕗";
const forall = "∀";
const ForAll = "∀";
const fork = "⋔";
const forkv = "⫙";
const Fouriertrf = "ℱ";
const fpartint = "⨍";
const frac12 = "½";
const frac13 = "⅓";
const frac14 = "¼";
const frac15 = "⅕";
const frac16 = "⅙";
const frac18 = "⅛";
const frac23 = "⅔";
const frac25 = "⅖";
const frac34 = "¾";
const frac35 = "⅗";
const frac38 = "⅜";
const frac45 = "⅘";
const frac56 = "⅚";
const frac58 = "⅝";
const frac78 = "⅞";
const frasl = "⁄";
const frown = "⌢";
const fscr = "𝒻";
const Fscr = "ℱ";
const gacute = "ǵ";
const Gamma = "Γ";
const gamma = "γ";
const Gammad = "Ϝ";
const gammad = "ϝ";
const gap = "⪆";
const Gbreve = "Ğ";
const gbreve = "ğ";
const Gcedil = "Ģ";
const Gcirc = "Ĝ";
const gcirc = "ĝ";
const Gcy = "Г";
const gcy = "г";
const Gdot = "Ġ";
const gdot = "ġ";
const ge = "≥";
const gE = "≧";
const gEl = "⪌";
const gel = "⋛";
const geq = "≥";
const geqq = "≧";
const geqslant = "⩾";
const gescc = "⪩";
const ges = "⩾";
const gesdot = "⪀";
const gesdoto = "⪂";
const gesdotol = "⪄";
const gesl = "⋛︀";
const gesles = "⪔";
const Gfr = "𝔊";
const gfr = "𝔤";
const gg = "≫";
const Gg = "⋙";
const ggg = "⋙";
const gimel = "ℷ";
const GJcy = "Ѓ";
const gjcy = "ѓ";
const gla = "⪥";
const gl = "≷";
const glE = "⪒";
const glj = "⪤";
const gnap = "⪊";
const gnapprox = "⪊";
const gne = "⪈";
const gnE = "≩";
const gneq = "⪈";
const gneqq = "≩";
const gnsim = "⋧";
const Gopf = "𝔾";
const gopf = "𝕘";
const grave = "`";
const GreaterEqual = "≥";
const GreaterEqualLess = "⋛";
const GreaterFullEqual = "≧";
const GreaterGreater = "⪢";
const GreaterLess = "≷";
const GreaterSlantEqual = "⩾";
const GreaterTilde = "≳";
const Gscr = "𝒢";
const gscr = "ℊ";
const gsim = "≳";
const gsime = "⪎";
const gsiml = "⪐";
const gtcc = "⪧";
const gtcir = "⩺";
const gt = ">";
const GT = ">";
const Gt = "≫";
const gtdot = "⋗";
const gtlPar = "⦕";
const gtquest = "⩼";
const gtrapprox = "⪆";
const gtrarr = "⥸";
const gtrdot = "⋗";
const gtreqless = "⋛";
const gtreqqless = "⪌";
const gtrless = "≷";
const gtrsim = "≳";
const gvertneqq = "≩︀";
const gvnE = "≩︀";
const Hacek = "ˇ";
const hairsp = " ";
const half = "½";
const hamilt = "ℋ";
const HARDcy = "Ъ";
const hardcy = "ъ";
const harrcir = "⥈";
const harr = "↔";
const hArr = "⇔";
const harrw = "↭";
const Hat = "^";
const hbar = "ℏ";
const Hcirc = "Ĥ";
const hcirc = "ĥ";
const hearts = "♥";
const heartsuit = "♥";
const hellip = "…";
const hercon = "⊹";
const hfr = "𝔥";
const Hfr = "ℌ";
const HilbertSpace = "ℋ";
const hksearow = "⤥";
const hkswarow = "⤦";
const hoarr = "⇿";
const homtht = "∻";
const hookleftarrow = "↩";
const hookrightarrow = "↪";
const hopf = "𝕙";
const Hopf = "ℍ";
const horbar = "―";
const HorizontalLine = "─";
const hscr = "𝒽";
const Hscr = "ℋ";
const hslash = "ℏ";
const Hstrok = "Ħ";
const hstrok = "ħ";
const HumpDownHump = "≎";
const HumpEqual = "≏";
const hybull = "⁃";
const hyphen = "‐";
const Iacute = "Í";
const iacute = "í";
const ic = "⁣";
const Icirc = "Î";
const icirc = "î";
const Icy = "И";
const icy = "и";
const Idot = "İ";
const IEcy = "Е";
const iecy = "е";
const iexcl = "¡";
const iff = "⇔";
const ifr = "𝔦";
const Ifr = "ℑ";
const Igrave = "Ì";
const igrave = "ì";
const ii = "ⅈ";
const iiiint = "⨌";
const iiint = "∭";
const iinfin = "⧜";
const iiota = "℩";
const IJlig = "Ĳ";
const ijlig = "ĳ";
const Imacr = "Ī";
const imacr = "ī";
const image$1 = "ℑ";
const ImaginaryI = "ⅈ";
const imagline = "ℐ";
const imagpart = "ℑ";
const imath = "ı";
const Im = "ℑ";
const imof = "⊷";
const imped = "Ƶ";
const Implies = "⇒";
const incare = "℅";
const infin = "∞";
const infintie = "⧝";
const inodot = "ı";
const intcal = "⊺";
const int = "∫";
const Int = "∬";
const integers = "ℤ";
const Integral = "∫";
const intercal = "⊺";
const Intersection = "⋂";
const intlarhk = "⨗";
const intprod = "⨼";
const InvisibleComma = "⁣";
const InvisibleTimes = "⁢";
const IOcy = "Ё";
const iocy = "ё";
const Iogon = "Į";
const iogon = "į";
const Iopf = "𝕀";
const iopf = "𝕚";
const Iota = "Ι";
const iota = "ι";
const iprod = "⨼";
const iquest = "¿";
const iscr = "𝒾";
const Iscr = "ℐ";
const isin = "∈";
const isindot = "⋵";
const isinE = "⋹";
const isins = "⋴";
const isinsv = "⋳";
const isinv = "∈";
const it = "⁢";
const Itilde = "Ĩ";
const itilde = "ĩ";
const Iukcy = "І";
const iukcy = "і";
const Iuml = "Ï";
const iuml = "ï";
const Jcirc = "Ĵ";
const jcirc = "ĵ";
const Jcy = "Й";
const jcy = "й";
const Jfr = "𝔍";
const jfr = "𝔧";
const jmath = "ȷ";
const Jopf = "𝕁";
const jopf = "𝕛";
const Jscr = "𝒥";
const jscr = "𝒿";
const Jsercy = "Ј";
const jsercy = "ј";
const Jukcy = "Є";
const jukcy = "є";
const Kappa = "Κ";
const kappa = "κ";
const kappav = "ϰ";
const Kcedil = "Ķ";
const kcedil = "ķ";
const Kcy = "К";
const kcy = "к";
const Kfr = "𝔎";
const kfr = "𝔨";
const kgreen = "ĸ";
const KHcy = "Х";
const khcy = "х";
const KJcy = "Ќ";
const kjcy = "ќ";
const Kopf = "𝕂";
const kopf = "𝕜";
const Kscr = "𝒦";
const kscr = "𝓀";
const lAarr = "⇚";
const Lacute = "Ĺ";
const lacute = "ĺ";
const laemptyv = "⦴";
const lagran = "ℒ";
const Lambda = "Λ";
const lambda = "λ";
const lang = "⟨";
const Lang = "⟪";
const langd = "⦑";
const langle = "⟨";
const lap = "⪅";
const Laplacetrf = "ℒ";
const laquo = "«";
const larrb = "⇤";
const larrbfs = "⤟";
const larr = "←";
const Larr = "↞";
const lArr = "⇐";
const larrfs = "⤝";
const larrhk = "↩";
const larrlp = "↫";
const larrpl = "⤹";
const larrsim = "⥳";
const larrtl = "↢";
const latail = "⤙";
const lAtail = "⤛";
const lat = "⪫";
const late = "⪭";
const lates = "⪭︀";
const lbarr = "⤌";
const lBarr = "⤎";
const lbbrk = "❲";
const lbrace = "{";
const lbrack = "[";
const lbrke = "⦋";
const lbrksld = "⦏";
const lbrkslu = "⦍";
const Lcaron = "Ľ";
const lcaron = "ľ";
const Lcedil = "Ļ";
const lcedil = "ļ";
const lceil = "⌈";
const lcub = "{";
const Lcy = "Л";
const lcy = "л";
const ldca = "⤶";
const ldquo = "“";
const ldquor = "„";
const ldrdhar = "⥧";
const ldrushar = "⥋";
const ldsh = "↲";
const le = "≤";
const lE = "≦";
const LeftAngleBracket = "⟨";
const LeftArrowBar = "⇤";
const leftarrow = "←";
const LeftArrow = "←";
const Leftarrow = "⇐";
const LeftArrowRightArrow = "⇆";
const leftarrowtail = "↢";
const LeftCeiling = "⌈";
const LeftDoubleBracket = "⟦";
const LeftDownTeeVector = "⥡";
const LeftDownVectorBar = "⥙";
const LeftDownVector = "⇃";
const LeftFloor = "⌊";
const leftharpoondown = "↽";
const leftharpoonup = "↼";
const leftleftarrows = "⇇";
const leftrightarrow = "↔";
const LeftRightArrow = "↔";
const Leftrightarrow = "⇔";
const leftrightarrows = "⇆";
const leftrightharpoons = "⇋";
const leftrightsquigarrow = "↭";
const LeftRightVector = "⥎";
const LeftTeeArrow = "↤";
const LeftTee = "⊣";
const LeftTeeVector = "⥚";
const leftthreetimes = "⋋";
const LeftTriangleBar = "⧏";
const LeftTriangle = "⊲";
const LeftTriangleEqual = "⊴";
const LeftUpDownVector = "⥑";
const LeftUpTeeVector = "⥠";
const LeftUpVectorBar = "⥘";
const LeftUpVector = "↿";
const LeftVectorBar = "⥒";
const LeftVector = "↼";
const lEg = "⪋";
const leg = "⋚";
const leq = "≤";
const leqq = "≦";
const leqslant = "⩽";
const lescc = "⪨";
const les = "⩽";
const lesdot = "⩿";
const lesdoto = "⪁";
const lesdotor = "⪃";
const lesg = "⋚︀";
const lesges = "⪓";
const lessapprox = "⪅";
const lessdot = "⋖";
const lesseqgtr = "⋚";
const lesseqqgtr = "⪋";
const LessEqualGreater = "⋚";
const LessFullEqual = "≦";
const LessGreater = "≶";
const lessgtr = "≶";
const LessLess = "⪡";
const lesssim = "≲";
const LessSlantEqual = "⩽";
const LessTilde = "≲";
const lfisht = "⥼";
const lfloor = "⌊";
const Lfr = "𝔏";
const lfr = "𝔩";
const lg = "≶";
const lgE = "⪑";
const lHar = "⥢";
const lhard = "↽";
const lharu = "↼";
const lharul = "⥪";
const lhblk = "▄";
const LJcy = "Љ";
const ljcy = "љ";
const llarr = "⇇";
const ll = "≪";
const Ll = "⋘";
const llcorner = "⌞";
const Lleftarrow = "⇚";
const llhard = "⥫";
const lltri = "◺";
const Lmidot = "Ŀ";
const lmidot = "ŀ";
const lmoustache = "⎰";
const lmoust = "⎰";
const lnap = "⪉";
const lnapprox = "⪉";
const lne = "⪇";
const lnE = "≨";
const lneq = "⪇";
const lneqq = "≨";
const lnsim = "⋦";
const loang = "⟬";
const loarr = "⇽";
const lobrk = "⟦";
const longleftarrow = "⟵";
const LongLeftArrow = "⟵";
const Longleftarrow = "⟸";
const longleftrightarrow = "⟷";
const LongLeftRightArrow = "⟷";
const Longleftrightarrow = "⟺";
const longmapsto = "⟼";
const longrightarrow = "⟶";
const LongRightArrow = "⟶";
const Longrightarrow = "⟹";
const looparrowleft = "↫";
const looparrowright = "↬";
const lopar = "⦅";
const Lopf = "𝕃";
const lopf = "𝕝";
const loplus = "⨭";
const lotimes = "⨴";
const lowast = "∗";
const lowbar = "_";
const LowerLeftArrow = "↙";
const LowerRightArrow = "↘";
const loz = "◊";
const lozenge = "◊";
const lozf = "⧫";
const lpar = "(";
const lparlt = "⦓";
const lrarr = "⇆";
const lrcorner = "⌟";
const lrhar = "⇋";
const lrhard = "⥭";
const lrm = "‎";
const lrtri = "⊿";
const lsaquo = "‹";
const lscr = "𝓁";
const Lscr = "ℒ";
const lsh = "↰";
const Lsh = "↰";
const lsim = "≲";
const lsime = "⪍";
const lsimg = "⪏";
const lsqb = "[";
const lsquo = "‘";
const lsquor = "‚";
const Lstrok = "Ł";
const lstrok = "ł";
const ltcc = "⪦";
const ltcir = "⩹";
const lt = "<";
const LT = "<";
const Lt = "≪";
const ltdot = "⋖";
const lthree = "⋋";
const ltimes = "⋉";
const ltlarr = "⥶";
const ltquest = "⩻";
const ltri = "◃";
const ltrie = "⊴";
const ltrif = "◂";
const ltrPar = "⦖";
const lurdshar = "⥊";
const luruhar = "⥦";
const lvertneqq = "≨︀";
const lvnE = "≨︀";
const macr = "¯";
const male = "♂";
const malt = "✠";
const maltese = "✠";
const map = "↦";
const mapsto = "↦";
const mapstodown = "↧";
const mapstoleft = "↤";
const mapstoup = "↥";
const marker = "▮";
const mcomma = "⨩";
const Mcy = "М";
const mcy = "м";
const mdash = "—";
const mDDot = "∺";
const measuredangle = "∡";
const MediumSpace = " ";
const Mellintrf = "ℳ";
const Mfr = "𝔐";
const mfr = "𝔪";
const mho = "℧";
const micro = "µ";
const midast = "*";
const midcir = "⫰";
const mid = "∣";
const middot = "·";
const minusb = "⊟";
const minus = "−";
const minusd = "∸";
const minusdu = "⨪";
const MinusPlus = "∓";
const mlcp = "⫛";
const mldr = "…";
const mnplus = "∓";
const models = "⊧";
const Mopf = "𝕄";
const mopf = "𝕞";
const mp = "∓";
const mscr = "𝓂";
const Mscr = "ℳ";
const mstpos = "∾";
const Mu = "Μ";
const mu = "μ";
const multimap = "⊸";
const mumap = "⊸";
const nabla = "∇";
const Nacute = "Ń";
const nacute = "ń";
const nang = "∠⃒";
const nap = "≉";
const napE = "⩰̸";
const napid = "≋̸";
const napos = "ŉ";
const napprox = "≉";
const natural = "♮";
const naturals = "ℕ";
const natur = "♮";
const nbsp = " ";
const nbump = "≎̸";
const nbumpe = "≏̸";
const ncap = "⩃";
const Ncaron = "Ň";
const ncaron = "ň";
const Ncedil = "Ņ";
const ncedil = "ņ";
const ncong = "≇";
const ncongdot = "⩭̸";
const ncup = "⩂";
const Ncy = "Н";
const ncy = "н";
const ndash = "–";
const nearhk = "⤤";
const nearr = "↗";
const neArr = "⇗";
const nearrow = "↗";
const ne = "≠";
const nedot = "≐̸";
const NegativeMediumSpace = "​";
const NegativeThickSpace = "​";
const NegativeThinSpace = "​";
const NegativeVeryThinSpace = "​";
const nequiv = "≢";
const nesear = "⤨";
const nesim = "≂̸";
const NestedGreaterGreater = "≫";
const NestedLessLess = "≪";
const NewLine = "\n";
const nexist = "∄";
const nexists = "∄";
const Nfr = "𝔑";
const nfr = "𝔫";
const ngE = "≧̸";
const nge = "≱";
const ngeq = "≱";
const ngeqq = "≧̸";
const ngeqslant = "⩾̸";
const nges = "⩾̸";
const nGg = "⋙̸";
const ngsim = "≵";
const nGt = "≫⃒";
const ngt = "≯";
const ngtr = "≯";
const nGtv = "≫̸";
const nharr = "↮";
const nhArr = "⇎";
const nhpar = "⫲";
const ni = "∋";
const nis = "⋼";
const nisd = "⋺";
const niv = "∋";
const NJcy = "Њ";
const njcy = "њ";
const nlarr = "↚";
const nlArr = "⇍";
const nldr = "‥";
const nlE = "≦̸";
const nle = "≰";
const nleftarrow = "↚";
const nLeftarrow = "⇍";
const nleftrightarrow = "↮";
const nLeftrightarrow = "⇎";
const nleq = "≰";
const nleqq = "≦̸";
const nleqslant = "⩽̸";
const nles = "⩽̸";
const nless = "≮";
const nLl = "⋘̸";
const nlsim = "≴";
const nLt = "≪⃒";
const nlt = "≮";
const nltri = "⋪";
const nltrie = "⋬";
const nLtv = "≪̸";
const nmid = "∤";
const NoBreak = "⁠";
const NonBreakingSpace = " ";
const nopf = "𝕟";
const Nopf = "ℕ";
const Not = "⫬";
const not = "¬";
const NotCongruent = "≢";
const NotCupCap = "≭";
const NotDoubleVerticalBar = "∦";
const NotElement = "∉";
const NotEqual = "≠";
const NotEqualTilde = "≂̸";
const NotExists = "∄";
const NotGreater = "≯";
const NotGreaterEqual = "≱";
const NotGreaterFullEqual = "≧̸";
const NotGreaterGreater = "≫̸";
const NotGreaterLess = "≹";
const NotGreaterSlantEqual = "⩾̸";
const NotGreaterTilde = "≵";
const NotHumpDownHump = "≎̸";
const NotHumpEqual = "≏̸";
const notin = "∉";
const notindot = "⋵̸";
const notinE = "⋹̸";
const notinva = "∉";
const notinvb = "⋷";
const notinvc = "⋶";
const NotLeftTriangleBar = "⧏̸";
const NotLeftTriangle = "⋪";
const NotLeftTriangleEqual = "⋬";
const NotLess = "≮";
const NotLessEqual = "≰";
const NotLessGreater = "≸";
const NotLessLess = "≪̸";
const NotLessSlantEqual = "⩽̸";
const NotLessTilde = "≴";
const NotNestedGreaterGreater = "⪢̸";
const NotNestedLessLess = "⪡̸";
const notni = "∌";
const notniva = "∌";
const notnivb = "⋾";
const notnivc = "⋽";
const NotPrecedes = "⊀";
const NotPrecedesEqual = "⪯̸";
const NotPrecedesSlantEqual = "⋠";
const NotReverseElement = "∌";
const NotRightTriangleBar = "⧐̸";
const NotRightTriangle = "⋫";
const NotRightTriangleEqual = "⋭";
const NotSquareSubset = "⊏̸";
const NotSquareSubsetEqual = "⋢";
const NotSquareSuperset = "⊐̸";
const NotSquareSupersetEqual = "⋣";
const NotSubset = "⊂⃒";
const NotSubsetEqual = "⊈";
const NotSucceeds = "⊁";
const NotSucceedsEqual = "⪰̸";
const NotSucceedsSlantEqual = "⋡";
const NotSucceedsTilde = "≿̸";
const NotSuperset = "⊃⃒";
const NotSupersetEqual = "⊉";
const NotTilde = "≁";
const NotTildeEqual = "≄";
const NotTildeFullEqual = "≇";
const NotTildeTilde = "≉";
const NotVerticalBar = "∤";
const nparallel = "∦";
const npar = "∦";
const nparsl = "⫽⃥";
const npart = "∂̸";
const npolint = "⨔";
const npr = "⊀";
const nprcue = "⋠";
const nprec = "⊀";
const npreceq = "⪯̸";
const npre = "⪯̸";
const nrarrc = "⤳̸";
const nrarr = "↛";
const nrArr = "⇏";
const nrarrw = "↝̸";
const nrightarrow = "↛";
const nRightarrow = "⇏";
const nrtri = "⋫";
const nrtrie = "⋭";
const nsc = "⊁";
const nsccue = "⋡";
const nsce = "⪰̸";
const Nscr = "𝒩";
const nscr = "𝓃";
const nshortmid = "∤";
const nshortparallel = "∦";
const nsim = "≁";
const nsime = "≄";
const nsimeq = "≄";
const nsmid = "∤";
const nspar = "∦";
const nsqsube = "⋢";
const nsqsupe = "⋣";
const nsub = "⊄";
const nsubE = "⫅̸";
const nsube = "⊈";
const nsubset = "⊂⃒";
const nsubseteq = "⊈";
const nsubseteqq = "⫅̸";
const nsucc = "⊁";
const nsucceq = "⪰̸";
const nsup = "⊅";
const nsupE = "⫆̸";
const nsupe = "⊉";
const nsupset = "⊃⃒";
const nsupseteq = "⊉";
const nsupseteqq = "⫆̸";
const ntgl = "≹";
const Ntilde = "Ñ";
const ntilde = "ñ";
const ntlg = "≸";
const ntriangleleft = "⋪";
const ntrianglelefteq = "⋬";
const ntriangleright = "⋫";
const ntrianglerighteq = "⋭";
const Nu = "Ν";
const nu = "ν";
const num = "#";
const numero = "№";
const numsp = " ";
const nvap = "≍⃒";
const nvdash = "⊬";
const nvDash = "⊭";
const nVdash = "⊮";
const nVDash = "⊯";
const nvge = "≥⃒";
const nvgt = ">⃒";
const nvHarr = "⤄";
const nvinfin = "⧞";
const nvlArr = "⤂";
const nvle = "≤⃒";
const nvlt = "<⃒";
const nvltrie = "⊴⃒";
const nvrArr = "⤃";
const nvrtrie = "⊵⃒";
const nvsim = "∼⃒";
const nwarhk = "⤣";
const nwarr = "↖";
const nwArr = "⇖";
const nwarrow = "↖";
const nwnear = "⤧";
const Oacute = "Ó";
const oacute = "ó";
const oast = "⊛";
const Ocirc = "Ô";
const ocirc = "ô";
const ocir = "⊚";
const Ocy = "О";
const ocy = "о";
const odash = "⊝";
const Odblac = "Ő";
const odblac = "ő";
const odiv = "⨸";
const odot = "⊙";
const odsold = "⦼";
const OElig = "Œ";
const oelig = "œ";
const ofcir = "⦿";
const Ofr = "𝔒";
const ofr = "𝔬";
const ogon = "˛";
const Ograve = "Ò";
const ograve = "ò";
const ogt = "⧁";
const ohbar = "⦵";
const ohm = "Ω";
const oint = "∮";
const olarr = "↺";
const olcir = "⦾";
const olcross = "⦻";
const oline = "‾";
const olt = "⧀";
const Omacr = "Ō";
const omacr = "ō";
const Omega = "Ω";
const omega = "ω";
const Omicron = "Ο";
const omicron = "ο";
const omid = "⦶";
const ominus = "⊖";
const Oopf = "𝕆";
const oopf = "𝕠";
const opar = "⦷";
const OpenCurlyDoubleQuote = "“";
const OpenCurlyQuote = "‘";
const operp = "⦹";
const oplus = "⊕";
const orarr = "↻";
const Or = "⩔";
const or = "∨";
const ord = "⩝";
const order = "ℴ";
const orderof = "ℴ";
const ordf = "ª";
const ordm = "º";
const origof = "⊶";
const oror = "⩖";
const orslope = "⩗";
const orv = "⩛";
const oS = "Ⓢ";
const Oscr = "𝒪";
const oscr = "ℴ";
const Oslash = "Ø";
const oslash = "ø";
const osol = "⊘";
const Otilde = "Õ";
const otilde = "õ";
const otimesas = "⨶";
const Otimes = "⨷";
const otimes = "⊗";
const Ouml = "Ö";
const ouml = "ö";
const ovbar = "⌽";
const OverBar = "‾";
const OverBrace = "⏞";
const OverBracket = "⎴";
const OverParenthesis = "⏜";
const para = "¶";
const parallel = "∥";
const par = "∥";
const parsim = "⫳";
const parsl = "⫽";
const part = "∂";
const PartialD = "∂";
const Pcy = "П";
const pcy = "п";
const percnt = "%";
const period = ".";
const permil = "‰";
const perp = "⊥";
const pertenk = "‱";
const Pfr = "𝔓";
const pfr = "𝔭";
const Phi = "Φ";
const phi = "φ";
const phiv = "ϕ";
const phmmat = "ℳ";
const phone = "☎";
const Pi = "Π";
const pi = "π";
const pitchfork = "⋔";
const piv = "ϖ";
const planck = "ℏ";
const planckh = "ℎ";
const plankv = "ℏ";
const plusacir = "⨣";
const plusb = "⊞";
const pluscir = "⨢";
const plus = "+";
const plusdo = "∔";
const plusdu = "⨥";
const pluse = "⩲";
const PlusMinus = "±";
const plusmn = "±";
const plussim = "⨦";
const plustwo = "⨧";
const pm = "±";
const Poincareplane = "ℌ";
const pointint = "⨕";
const popf = "𝕡";
const Popf = "ℙ";
const pound = "£";
const prap = "⪷";
const Pr = "⪻";
const pr = "≺";
const prcue = "≼";
const precapprox = "⪷";
const prec = "≺";
const preccurlyeq = "≼";
const Precedes = "≺";
const PrecedesEqual = "⪯";
const PrecedesSlantEqual = "≼";
const PrecedesTilde = "≾";
const preceq = "⪯";
const precnapprox = "⪹";
const precneqq = "⪵";
const precnsim = "⋨";
const pre = "⪯";
const prE = "⪳";
const precsim = "≾";
const prime = "′";
const Prime = "″";
const primes = "ℙ";
const prnap = "⪹";
const prnE = "⪵";
const prnsim = "⋨";
const prod = "∏";
const Product = "∏";
const profalar = "⌮";
const profline = "⌒";
const profsurf = "⌓";
const prop = "∝";
const Proportional = "∝";
const Proportion = "∷";
const propto = "∝";
const prsim = "≾";
const prurel = "⊰";
const Pscr = "𝒫";
const pscr = "𝓅";
const Psi = "Ψ";
const psi = "ψ";
const puncsp = " ";
const Qfr = "𝔔";
const qfr = "𝔮";
const qint = "⨌";
const qopf = "𝕢";
const Qopf = "ℚ";
const qprime = "⁗";
const Qscr = "𝒬";
const qscr = "𝓆";
const quaternions = "ℍ";
const quatint = "⨖";
const quest = "?";
const questeq = "≟";
const quot = "\"";
const QUOT = "\"";
const rAarr = "⇛";
const race = "∽̱";
const Racute = "Ŕ";
const racute = "ŕ";
const radic = "√";
const raemptyv = "⦳";
const rang = "⟩";
const Rang = "⟫";
const rangd = "⦒";
const range = "⦥";
const rangle = "⟩";
const raquo = "»";
const rarrap = "⥵";
const rarrb = "⇥";
const rarrbfs = "⤠";
const rarrc = "⤳";
const rarr = "→";
const Rarr = "↠";
const rArr = "⇒";
const rarrfs = "⤞";
const rarrhk = "↪";
const rarrlp = "↬";
const rarrpl = "⥅";
const rarrsim = "⥴";
const Rarrtl = "⤖";
const rarrtl = "↣";
const rarrw = "↝";
const ratail = "⤚";
const rAtail = "⤜";
const ratio = "∶";
const rationals = "ℚ";
const rbarr = "⤍";
const rBarr = "⤏";
const RBarr = "⤐";
const rbbrk = "❳";
const rbrace = "}";
const rbrack = "]";
const rbrke = "⦌";
const rbrksld = "⦎";
const rbrkslu = "⦐";
const Rcaron = "Ř";
const rcaron = "ř";
const Rcedil = "Ŗ";
const rcedil = "ŗ";
const rceil = "⌉";
const rcub = "}";
const Rcy = "Р";
const rcy = "р";
const rdca = "⤷";
const rdldhar = "⥩";
const rdquo = "”";
const rdquor = "”";
const rdsh = "↳";
const real = "ℜ";
const realine = "ℛ";
const realpart = "ℜ";
const reals = "ℝ";
const Re = "ℜ";
const rect = "▭";
const reg = "®";
const REG = "®";
const ReverseElement = "∋";
const ReverseEquilibrium = "⇋";
const ReverseUpEquilibrium = "⥯";
const rfisht = "⥽";
const rfloor = "⌋";
const rfr = "𝔯";
const Rfr = "ℜ";
const rHar = "⥤";
const rhard = "⇁";
const rharu = "⇀";
const rharul = "⥬";
const Rho = "Ρ";
const rho = "ρ";
const rhov = "ϱ";
const RightAngleBracket = "⟩";
const RightArrowBar = "⇥";
const rightarrow = "→";
const RightArrow = "→";
const Rightarrow = "⇒";
const RightArrowLeftArrow = "⇄";
const rightarrowtail = "↣";
const RightCeiling = "⌉";
const RightDoubleBracket = "⟧";
const RightDownTeeVector = "⥝";
const RightDownVectorBar = "⥕";
const RightDownVector = "⇂";
const RightFloor = "⌋";
const rightharpoondown = "⇁";
const rightharpoonup = "⇀";
const rightleftarrows = "⇄";
const rightleftharpoons = "⇌";
const rightrightarrows = "⇉";
const rightsquigarrow = "↝";
const RightTeeArrow = "↦";
const RightTee = "⊢";
const RightTeeVector = "⥛";
const rightthreetimes = "⋌";
const RightTriangleBar = "⧐";
const RightTriangle = "⊳";
const RightTriangleEqual = "⊵";
const RightUpDownVector = "⥏";
const RightUpTeeVector = "⥜";
const RightUpVectorBar = "⥔";
const RightUpVector = "↾";
const RightVectorBar = "⥓";
const RightVector = "⇀";
const ring = "˚";
const risingdotseq = "≓";
const rlarr = "⇄";
const rlhar = "⇌";
const rlm = "‏";
const rmoustache = "⎱";
const rmoust = "⎱";
const rnmid = "⫮";
const roang = "⟭";
const roarr = "⇾";
const robrk = "⟧";
const ropar = "⦆";
const ropf = "𝕣";
const Ropf = "ℝ";
const roplus = "⨮";
const rotimes = "⨵";
const RoundImplies = "⥰";
const rpar = ")";
const rpargt = "⦔";
const rppolint = "⨒";
const rrarr = "⇉";
const Rrightarrow = "⇛";
const rsaquo = "›";
const rscr = "𝓇";
const Rscr = "ℛ";
const rsh = "↱";
const Rsh = "↱";
const rsqb = "]";
const rsquo = "’";
const rsquor = "’";
const rthree = "⋌";
const rtimes = "⋊";
const rtri = "▹";
const rtrie = "⊵";
const rtrif = "▸";
const rtriltri = "⧎";
const RuleDelayed = "⧴";
const ruluhar = "⥨";
const rx = "℞";
const Sacute = "Ś";
const sacute = "ś";
const sbquo = "‚";
const scap = "⪸";
const Scaron = "Š";
const scaron = "š";
const Sc = "⪼";
const sc = "≻";
const sccue = "≽";
const sce = "⪰";
const scE = "⪴";
const Scedil = "Ş";
const scedil = "ş";
const Scirc = "Ŝ";
const scirc = "ŝ";
const scnap = "⪺";
const scnE = "⪶";
const scnsim = "⋩";
const scpolint = "⨓";
const scsim = "≿";
const Scy = "С";
const scy = "с";
const sdotb = "⊡";
const sdot = "⋅";
const sdote = "⩦";
const searhk = "⤥";
const searr = "↘";
const seArr = "⇘";
const searrow = "↘";
const sect = "§";
const semi = ";";
const seswar = "⤩";
const setminus = "∖";
const setmn = "∖";
const sext = "✶";
const Sfr = "𝔖";
const sfr = "𝔰";
const sfrown = "⌢";
const sharp = "♯";
const SHCHcy = "Щ";
const shchcy = "щ";
const SHcy = "Ш";
const shcy = "ш";
const ShortDownArrow = "↓";
const ShortLeftArrow = "←";
const shortmid = "∣";
const shortparallel = "∥";
const ShortRightArrow = "→";
const ShortUpArrow = "↑";
const shy = "­";
const Sigma = "Σ";
const sigma = "σ";
const sigmaf = "ς";
const sigmav = "ς";
const sim = "∼";
const simdot = "⩪";
const sime = "≃";
const simeq = "≃";
const simg = "⪞";
const simgE = "⪠";
const siml = "⪝";
const simlE = "⪟";
const simne = "≆";
const simplus = "⨤";
const simrarr = "⥲";
const slarr = "←";
const SmallCircle = "∘";
const smallsetminus = "∖";
const smashp = "⨳";
const smeparsl = "⧤";
const smid = "∣";
const smile = "⌣";
const smt = "⪪";
const smte = "⪬";
const smtes = "⪬︀";
const SOFTcy = "Ь";
const softcy = "ь";
const solbar = "⌿";
const solb = "⧄";
const sol = "/";
const Sopf = "𝕊";
const sopf = "𝕤";
const spades = "♠";
const spadesuit = "♠";
const spar = "∥";
const sqcap = "⊓";
const sqcaps = "⊓︀";
const sqcup = "⊔";
const sqcups = "⊔︀";
const Sqrt = "√";
const sqsub = "⊏";
const sqsube = "⊑";
const sqsubset = "⊏";
const sqsubseteq = "⊑";
const sqsup = "⊐";
const sqsupe = "⊒";
const sqsupset = "⊐";
const sqsupseteq = "⊒";
const square = "□";
const Square = "□";
const SquareIntersection = "⊓";
const SquareSubset = "⊏";
const SquareSubsetEqual = "⊑";
const SquareSuperset = "⊐";
const SquareSupersetEqual = "⊒";
const SquareUnion = "⊔";
const squarf = "▪";
const squ = "□";
const squf = "▪";
const srarr = "→";
const Sscr = "𝒮";
const sscr = "𝓈";
const ssetmn = "∖";
const ssmile = "⌣";
const sstarf = "⋆";
const Star = "⋆";
const star = "☆";
const starf = "★";
const straightepsilon = "ϵ";
const straightphi = "ϕ";
const strns = "¯";
const sub = "⊂";
const Sub = "⋐";
const subdot = "⪽";
const subE = "⫅";
const sube = "⊆";
const subedot = "⫃";
const submult = "⫁";
const subnE = "⫋";
const subne = "⊊";
const subplus = "⪿";
const subrarr = "⥹";
const subset = "⊂";
const Subset = "⋐";
const subseteq = "⊆";
const subseteqq = "⫅";
const SubsetEqual = "⊆";
const subsetneq = "⊊";
const subsetneqq = "⫋";
const subsim = "⫇";
const subsub = "⫕";
const subsup = "⫓";
const succapprox = "⪸";
const succ = "≻";
const succcurlyeq = "≽";
const Succeeds = "≻";
const SucceedsEqual = "⪰";
const SucceedsSlantEqual = "≽";
const SucceedsTilde = "≿";
const succeq = "⪰";
const succnapprox = "⪺";
const succneqq = "⪶";
const succnsim = "⋩";
const succsim = "≿";
const SuchThat = "∋";
const sum = "∑";
const Sum = "∑";
const sung = "♪";
const sup1 = "¹";
const sup2 = "²";
const sup3 = "³";
const sup = "⊃";
const Sup = "⋑";
const supdot = "⪾";
const supdsub = "⫘";
const supE = "⫆";
const supe = "⊇";
const supedot = "⫄";
const Superset = "⊃";
const SupersetEqual = "⊇";
const suphsol = "⟉";
const suphsub = "⫗";
const suplarr = "⥻";
const supmult = "⫂";
const supnE = "⫌";
const supne = "⊋";
const supplus = "⫀";
const supset = "⊃";
const Supset = "⋑";
const supseteq = "⊇";
const supseteqq = "⫆";
const supsetneq = "⊋";
const supsetneqq = "⫌";
const supsim = "⫈";
const supsub = "⫔";
const supsup = "⫖";
const swarhk = "⤦";
const swarr = "↙";
const swArr = "⇙";
const swarrow = "↙";
const swnwar = "⤪";
const szlig = "ß";
const Tab = "\t";
const target = "⌖";
const Tau = "Τ";
const tau = "τ";
const tbrk = "⎴";
const Tcaron = "Ť";
const tcaron = "ť";
const Tcedil = "Ţ";
const tcedil = "ţ";
const Tcy = "Т";
const tcy = "т";
const tdot = "⃛";
const telrec = "⌕";
const Tfr = "𝔗";
const tfr = "𝔱";
const there4 = "∴";
const therefore = "∴";
const Therefore = "∴";
const Theta = "Θ";
const theta = "θ";
const thetasym = "ϑ";
const thetav = "ϑ";
const thickapprox = "≈";
const thicksim = "∼";
const ThickSpace = "  ";
const ThinSpace = " ";
const thinsp = " ";
const thkap = "≈";
const thksim = "∼";
const THORN = "Þ";
const thorn = "þ";
const tilde = "˜";
const Tilde = "∼";
const TildeEqual = "≃";
const TildeFullEqual = "≅";
const TildeTilde = "≈";
const timesbar = "⨱";
const timesb = "⊠";
const times = "×";
const timesd = "⨰";
const tint = "∭";
const toea = "⤨";
const topbot = "⌶";
const topcir = "⫱";
const top = "⊤";
const Topf = "𝕋";
const topf = "𝕥";
const topfork = "⫚";
const tosa = "⤩";
const tprime = "‴";
const trade = "™";
const TRADE = "™";
const triangle = "▵";
const triangledown = "▿";
const triangleleft = "◃";
const trianglelefteq = "⊴";
const triangleq = "≜";
const triangleright = "▹";
const trianglerighteq = "⊵";
const tridot = "◬";
const trie = "≜";
const triminus = "⨺";
const TripleDot = "⃛";
const triplus = "⨹";
const trisb = "⧍";
const tritime = "⨻";
const trpezium = "⏢";
const Tscr = "𝒯";
const tscr = "𝓉";
const TScy = "Ц";
const tscy = "ц";
const TSHcy = "Ћ";
const tshcy = "ћ";
const Tstrok = "Ŧ";
const tstrok = "ŧ";
const twixt = "≬";
const twoheadleftarrow = "↞";
const twoheadrightarrow = "↠";
const Uacute = "Ú";
const uacute = "ú";
const uarr = "↑";
const Uarr = "↟";
const uArr = "⇑";
const Uarrocir = "⥉";
const Ubrcy = "Ў";
const ubrcy = "ў";
const Ubreve = "Ŭ";
const ubreve = "ŭ";
const Ucirc = "Û";
const ucirc = "û";
const Ucy = "У";
const ucy = "у";
const udarr = "⇅";
const Udblac = "Ű";
const udblac = "ű";
const udhar = "⥮";
const ufisht = "⥾";
const Ufr = "𝔘";
const ufr = "𝔲";
const Ugrave = "Ù";
const ugrave = "ù";
const uHar = "⥣";
const uharl = "↿";
const uharr = "↾";
const uhblk = "▀";
const ulcorn = "⌜";
const ulcorner = "⌜";
const ulcrop = "⌏";
const ultri = "◸";
const Umacr = "Ū";
const umacr = "ū";
const uml = "¨";
const UnderBar = "_";
const UnderBrace = "⏟";
const UnderBracket = "⎵";
const UnderParenthesis = "⏝";
const Union = "⋃";
const UnionPlus = "⊎";
const Uogon = "Ų";
const uogon = "ų";
const Uopf = "𝕌";
const uopf = "𝕦";
const UpArrowBar = "⤒";
const uparrow = "↑";
const UpArrow = "↑";
const Uparrow = "⇑";
const UpArrowDownArrow = "⇅";
const updownarrow = "↕";
const UpDownArrow = "↕";
const Updownarrow = "⇕";
const UpEquilibrium = "⥮";
const upharpoonleft = "↿";
const upharpoonright = "↾";
const uplus = "⊎";
const UpperLeftArrow = "↖";
const UpperRightArrow = "↗";
const upsi = "υ";
const Upsi = "ϒ";
const upsih = "ϒ";
const Upsilon = "Υ";
const upsilon = "υ";
const UpTeeArrow = "↥";
const UpTee = "⊥";
const upuparrows = "⇈";
const urcorn = "⌝";
const urcorner = "⌝";
const urcrop = "⌎";
const Uring = "Ů";
const uring = "ů";
const urtri = "◹";
const Uscr = "𝒰";
const uscr = "𝓊";
const utdot = "⋰";
const Utilde = "Ũ";
const utilde = "ũ";
const utri = "▵";
const utrif = "▴";
const uuarr = "⇈";
const Uuml = "Ü";
const uuml = "ü";
const uwangle = "⦧";
const vangrt = "⦜";
const varepsilon = "ϵ";
const varkappa = "ϰ";
const varnothing = "∅";
const varphi = "ϕ";
const varpi = "ϖ";
const varpropto = "∝";
const varr = "↕";
const vArr = "⇕";
const varrho = "ϱ";
const varsigma = "ς";
const varsubsetneq = "⊊︀";
const varsubsetneqq = "⫋︀";
const varsupsetneq = "⊋︀";
const varsupsetneqq = "⫌︀";
const vartheta = "ϑ";
const vartriangleleft = "⊲";
const vartriangleright = "⊳";
const vBar = "⫨";
const Vbar = "⫫";
const vBarv = "⫩";
const Vcy = "В";
const vcy = "в";
const vdash = "⊢";
const vDash = "⊨";
const Vdash = "⊩";
const VDash = "⊫";
const Vdashl = "⫦";
const veebar = "⊻";
const vee = "∨";
const Vee = "⋁";
const veeeq = "≚";
const vellip = "⋮";
const verbar = "|";
const Verbar = "‖";
const vert = "|";
const Vert = "‖";
const VerticalBar = "∣";
const VerticalLine = "|";
const VerticalSeparator = "❘";
const VerticalTilde = "≀";
const VeryThinSpace = " ";
const Vfr = "𝔙";
const vfr = "𝔳";
const vltri = "⊲";
const vnsub = "⊂⃒";
const vnsup = "⊃⃒";
const Vopf = "𝕍";
const vopf = "𝕧";
const vprop = "∝";
const vrtri = "⊳";
const Vscr = "𝒱";
const vscr = "𝓋";
const vsubnE = "⫋︀";
const vsubne = "⊊︀";
const vsupnE = "⫌︀";
const vsupne = "⊋︀";
const Vvdash = "⊪";
const vzigzag = "⦚";
const Wcirc = "Ŵ";
const wcirc = "ŵ";
const wedbar = "⩟";
const wedge = "∧";
const Wedge = "⋀";
const wedgeq = "≙";
const weierp = "℘";
const Wfr = "𝔚";
const wfr = "𝔴";
const Wopf = "𝕎";
const wopf = "𝕨";
const wp = "℘";
const wr = "≀";
const wreath = "≀";
const Wscr = "𝒲";
const wscr = "𝓌";
const xcap = "⋂";
const xcirc = "◯";
const xcup = "⋃";
const xdtri = "▽";
const Xfr = "𝔛";
const xfr = "𝔵";
const xharr = "⟷";
const xhArr = "⟺";
const Xi = "Ξ";
const xi = "ξ";
const xlarr = "⟵";
const xlArr = "⟸";
const xmap = "⟼";
const xnis = "⋻";
const xodot = "⨀";
const Xopf = "𝕏";
const xopf = "𝕩";
const xoplus = "⨁";
const xotime = "⨂";
const xrarr = "⟶";
const xrArr = "⟹";
const Xscr = "𝒳";
const xscr = "𝓍";
const xsqcup = "⨆";
const xuplus = "⨄";
const xutri = "△";
const xvee = "⋁";
const xwedge = "⋀";
const Yacute = "Ý";
const yacute = "ý";
const YAcy = "Я";
const yacy = "я";
const Ycirc = "Ŷ";
const ycirc = "ŷ";
const Ycy = "Ы";
const ycy = "ы";
const yen = "¥";
const Yfr = "𝔜";
const yfr = "𝔶";
const YIcy = "Ї";
const yicy = "ї";
const Yopf = "𝕐";
const yopf = "𝕪";
const Yscr = "𝒴";
const yscr = "𝓎";
const YUcy = "Ю";
const yucy = "ю";
const yuml = "ÿ";
const Yuml = "Ÿ";
const Zacute = "Ź";
const zacute = "ź";
const Zcaron = "Ž";
const zcaron = "ž";
const Zcy = "З";
const zcy = "з";
const Zdot = "Ż";
const zdot = "ż";
const zeetrf = "ℨ";
const ZeroWidthSpace = "​";
const Zeta = "Ζ";
const zeta = "ζ";
const zfr = "𝔷";
const Zfr = "ℨ";
const ZHcy = "Ж";
const zhcy = "ж";
const zigrarr = "⇝";
const zopf = "𝕫";
const Zopf = "ℤ";
const Zscr = "𝒵";
const zscr = "𝓏";
const zwj = "‍";
const zwnj = "‌";
var entities$2 = {
	Aacute: Aacute,
	aacute: aacute,
	Abreve: Abreve,
	abreve: abreve,
	ac: ac,
	acd: acd,
	acE: acE,
	Acirc: Acirc,
	acirc: acirc,
	acute: acute,
	Acy: Acy,
	acy: acy,
	AElig: AElig,
	aelig: aelig,
	af: af,
	Afr: Afr,
	afr: afr,
	Agrave: Agrave,
	agrave: agrave,
	alefsym: alefsym,
	aleph: aleph,
	Alpha: Alpha,
	alpha: alpha,
	Amacr: Amacr,
	amacr: amacr,
	amalg: amalg,
	amp: amp,
	AMP: AMP,
	andand: andand,
	And: And,
	and: and,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angmsd: angmsd,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	Aogon: Aogon,
	aogon: aogon,
	Aopf: Aopf,
	aopf: aopf,
	apacir: apacir,
	ap: ap,
	apE: apE,
	ape: ape,
	apid: apid,
	apos: apos,
	ApplyFunction: ApplyFunction,
	approx: approx,
	approxeq: approxeq,
	Aring: Aring,
	aring: aring,
	Ascr: Ascr,
	ascr: ascr,
	Assign: Assign,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	Atilde: Atilde,
	atilde: atilde,
	Auml: Auml,
	auml: auml,
	awconint: awconint,
	awint: awint,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	Backslash: Backslash,
	Barv: Barv,
	barvee: barvee,
	barwed: barwed,
	Barwed: Barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	Bcy: Bcy,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	Because: Because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	Bernoullis: Bernoullis,
	Beta: Beta,
	beta: beta,
	beth: beth,
	between: between,
	Bfr: Bfr,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block$1,
	bne: bne,
	bnequiv: bnequiv,
	bNot: bNot,
	bnot: bnot,
	Bopf: Bopf,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxbox: boxbox,
	boxdl: boxdl,
	boxdL: boxdL,
	boxDl: boxDl,
	boxDL: boxDL,
	boxdr: boxdr,
	boxdR: boxdR,
	boxDr: boxDr,
	boxDR: boxDR,
	boxh: boxh,
	boxH: boxH,
	boxhd: boxhd,
	boxHd: boxHd,
	boxhD: boxhD,
	boxHD: boxHD,
	boxhu: boxhu,
	boxHu: boxHu,
	boxhU: boxhU,
	boxHU: boxHU,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxul: boxul,
	boxuL: boxuL,
	boxUl: boxUl,
	boxUL: boxUL,
	boxur: boxur,
	boxuR: boxuR,
	boxUr: boxUr,
	boxUR: boxUR,
	boxv: boxv,
	boxV: boxV,
	boxvh: boxvh,
	boxvH: boxvH,
	boxVh: boxVh,
	boxVH: boxVH,
	boxvl: boxvl,
	boxvL: boxvL,
	boxVl: boxVl,
	boxVL: boxVL,
	boxvr: boxvr,
	boxvR: boxvR,
	boxVr: boxVr,
	boxVR: boxVR,
	bprime: bprime,
	breve: breve,
	Breve: Breve,
	brvbar: brvbar,
	bscr: bscr,
	Bscr: Bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsolb: bsolb,
	bsol: bsol,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	Bumpeq: Bumpeq,
	bumpeq: bumpeq,
	Cacute: Cacute,
	cacute: cacute,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	cap: cap,
	Cap: Cap,
	capcup: capcup,
	capdot: capdot,
	CapitalDifferentialD: CapitalDifferentialD,
	caps: caps,
	caret: caret,
	caron: caron,
	Cayleys: Cayleys,
	ccaps: ccaps,
	Ccaron: Ccaron,
	ccaron: ccaron,
	Ccedil: Ccedil,
	ccedil: ccedil,
	Ccirc: Ccirc,
	ccirc: ccirc,
	Cconint: Cconint,
	ccups: ccups,
	ccupssm: ccupssm,
	Cdot: Cdot,
	cdot: cdot,
	cedil: cedil,
	Cedilla: Cedilla,
	cemptyv: cemptyv,
	cent: cent,
	centerdot: centerdot,
	CenterDot: CenterDot,
	cfr: cfr,
	Cfr: Cfr,
	CHcy: CHcy,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	Chi: Chi,
	chi: chi,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	CircleDot: CircleDot,
	circledR: circledR,
	circledS: circledS,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	cir: cir,
	cirE: cirE,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	Colon: Colon,
	Colone: Colone,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	Congruent: Congruent,
	conint: conint,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	copf: copf,
	Copf: Copf,
	coprod: coprod,
	Coproduct: Coproduct,
	copy: copy,
	COPY: COPY,
	copysr: copysr,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	crarr: crarr,
	cross: cross,
	Cross: Cross,
	Cscr: Cscr,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	CupCap: CupCap,
	cup: cup,
	Cup: Cup,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curren: curren,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dagger: dagger,
	Dagger: Dagger,
	daleth: daleth,
	darr: darr,
	Darr: Darr,
	dArr: dArr,
	dash: dash,
	Dashv: Dashv,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	Dcaron: Dcaron,
	dcaron: dcaron,
	Dcy: Dcy,
	dcy: dcy,
	ddagger: ddagger,
	ddarr: ddarr,
	DD: DD,
	dd: dd,
	DDotrahd: DDotrahd,
	ddotseq: ddotseq,
	deg: deg,
	Del: Del,
	Delta: Delta,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	Dfr: Dfr,
	dfr: dfr,
	dHar: dHar,
	dharl: dharl,
	dharr: dharr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	diam: diam,
	diamond: diamond,
	Diamond: Diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	DifferentialD: DifferentialD,
	digamma: digamma,
	disin: disin,
	div: div,
	divide: divide,
	divideontimes: divideontimes,
	divonx: divonx,
	DJcy: DJcy,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	Dopf: Dopf,
	dopf: dopf,
	Dot: Dot,
	dot: dot,
	DotDot: DotDot,
	doteq: doteq,
	doteqdot: doteqdot,
	DotEqual: DotEqual,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrowBar: DownArrowBar,
	downarrow: downarrow,
	DownArrow: DownArrow,
	Downarrow: Downarrow,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownLeftVector: DownLeftVector,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVectorBar: DownRightVectorBar,
	DownRightVector: DownRightVector,
	DownTeeArrow: DownTeeArrow,
	DownTee: DownTee,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	Dscr: Dscr,
	dscr: dscr,
	DScy: DScy,
	dscy: dscy,
	dsol: dsol,
	Dstrok: Dstrok,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	DZcy: DZcy,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	Eacute: Eacute,
	eacute: eacute,
	easter: easter,
	Ecaron: Ecaron,
	ecaron: ecaron,
	Ecirc: Ecirc,
	ecirc: ecirc,
	ecir: ecir,
	ecolon: ecolon,
	Ecy: Ecy,
	ecy: ecy,
	eDDot: eDDot,
	Edot: Edot,
	edot: edot,
	eDot: eDot,
	ee: ee,
	efDot: efDot,
	Efr: Efr,
	efr: efr,
	eg: eg,
	Egrave: Egrave,
	egrave: egrave,
	egs: egs,
	egsdot: egsdot,
	el: el,
	Element: Element,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	Emacr: Emacr,
	emacr: emacr,
	empty: empty,
	emptyset: emptyset,
	EmptySmallSquare: EmptySmallSquare,
	emptyv: emptyv,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	ENG: ENG,
	eng: eng,
	ensp: ensp,
	Eogon: Eogon,
	eogon: eogon,
	Eopf: Eopf,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	Epsilon: Epsilon,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	Equal: Equal,
	equals: equals,
	EqualTilde: EqualTilde,
	equest: equest,
	Equilibrium: Equilibrium,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erarr: erarr,
	erDot: erDot,
	escr: escr,
	Escr: Escr,
	esdot: esdot,
	Esim: Esim,
	esim: esim,
	Eta: Eta,
	eta: eta,
	ETH: ETH,
	eth: eth,
	Euml: Euml,
	euml: euml,
	euro: euro,
	excl: excl,
	exist: exist,
	Exists: Exists,
	expectation: expectation,
	exponentiale: exponentiale,
	ExponentialE: ExponentialE,
	fallingdotseq: fallingdotseq,
	Fcy: Fcy,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	Ffr: Ffr,
	ffr: ffr,
	filig: filig,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	Fopf: Fopf,
	fopf: fopf,
	forall: forall,
	ForAll: ForAll,
	fork: fork,
	forkv: forkv,
	Fouriertrf: Fouriertrf,
	fpartint: fpartint,
	frac12: frac12,
	frac13: frac13,
	frac14: frac14,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac34: frac34,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	Fscr: Fscr,
	gacute: gacute,
	Gamma: Gamma,
	gamma: gamma,
	Gammad: Gammad,
	gammad: gammad,
	gap: gap,
	Gbreve: Gbreve,
	gbreve: gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	gcirc: gcirc,
	Gcy: Gcy,
	gcy: gcy,
	Gdot: Gdot,
	gdot: gdot,
	ge: ge,
	gE: gE,
	gEl: gEl,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	gescc: gescc,
	ges: ges,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	Gfr: Gfr,
	gfr: gfr,
	gg: gg,
	Gg: Gg,
	ggg: ggg,
	gimel: gimel,
	GJcy: GJcy,
	gjcy: gjcy,
	gla: gla,
	gl: gl,
	glE: glE,
	glj: glj,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gnE: gnE,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	Gopf: Gopf,
	gopf: gopf,
	grave: grave,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	gtcc: gtcc,
	gtcir: gtcir,
	gt: gt,
	GT: GT,
	Gt: Gt,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	Hacek: Hacek,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	HARDcy: HARDcy,
	hardcy: hardcy,
	harrcir: harrcir,
	harr: harr,
	hArr: hArr,
	harrw: harrw,
	Hat: Hat,
	hbar: hbar,
	Hcirc: Hcirc,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	Hopf: Hopf,
	horbar: horbar,
	HorizontalLine: HorizontalLine,
	hscr: hscr,
	Hscr: Hscr,
	hslash: hslash,
	Hstrok: Hstrok,
	hstrok: hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	hybull: hybull,
	hyphen: hyphen,
	Iacute: Iacute,
	iacute: iacute,
	ic: ic,
	Icirc: Icirc,
	icirc: icirc,
	Icy: Icy,
	icy: icy,
	Idot: Idot,
	IEcy: IEcy,
	iecy: iecy,
	iexcl: iexcl,
	iff: iff,
	ifr: ifr,
	Ifr: Ifr,
	Igrave: Igrave,
	igrave: igrave,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	IJlig: IJlig,
	ijlig: ijlig,
	Imacr: Imacr,
	imacr: imacr,
	image: image$1,
	ImaginaryI: ImaginaryI,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	Im: Im,
	imof: imof,
	imped: imped,
	Implies: Implies,
	incare: incare,
	"in": "∈",
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	intcal: intcal,
	int: int,
	Int: Int,
	integers: integers,
	Integral: Integral,
	intercal: intercal,
	Intersection: Intersection,
	intlarhk: intlarhk,
	intprod: intprod,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	IOcy: IOcy,
	iocy: iocy,
	Iogon: Iogon,
	iogon: iogon,
	Iopf: Iopf,
	iopf: iopf,
	Iota: Iota,
	iota: iota,
	iprod: iprod,
	iquest: iquest,
	iscr: iscr,
	Iscr: Iscr,
	isin: isin,
	isindot: isindot,
	isinE: isinE,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	Itilde: Itilde,
	itilde: itilde,
	Iukcy: Iukcy,
	iukcy: iukcy,
	Iuml: Iuml,
	iuml: iuml,
	Jcirc: Jcirc,
	jcirc: jcirc,
	Jcy: Jcy,
	jcy: jcy,
	Jfr: Jfr,
	jfr: jfr,
	jmath: jmath,
	Jopf: Jopf,
	jopf: jopf,
	Jscr: Jscr,
	jscr: jscr,
	Jsercy: Jsercy,
	jsercy: jsercy,
	Jukcy: Jukcy,
	jukcy: jukcy,
	Kappa: Kappa,
	kappa: kappa,
	kappav: kappav,
	Kcedil: Kcedil,
	kcedil: kcedil,
	Kcy: Kcy,
	kcy: kcy,
	Kfr: Kfr,
	kfr: kfr,
	kgreen: kgreen,
	KHcy: KHcy,
	khcy: khcy,
	KJcy: KJcy,
	kjcy: kjcy,
	Kopf: Kopf,
	kopf: kopf,
	Kscr: Kscr,
	kscr: kscr,
	lAarr: lAarr,
	Lacute: Lacute,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	Lambda: Lambda,
	lambda: lambda,
	lang: lang,
	Lang: Lang,
	langd: langd,
	langle: langle,
	lap: lap,
	Laplacetrf: Laplacetrf,
	laquo: laquo,
	larrb: larrb,
	larrbfs: larrbfs,
	larr: larr,
	Larr: Larr,
	lArr: lArr,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	latail: latail,
	lAtail: lAtail,
	lat: lat,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lBarr: lBarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	Lcaron: Lcaron,
	lcaron: lcaron,
	Lcedil: Lcedil,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	Lcy: Lcy,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	lE: lE,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrowBar: LeftArrowBar,
	leftarrow: leftarrow,
	LeftArrow: LeftArrow,
	Leftarrow: Leftarrow,
	LeftArrowRightArrow: LeftArrowRightArrow,
	leftarrowtail: leftarrowtail,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftDownVector: LeftDownVector,
	LeftFloor: LeftFloor,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	LeftRightArrow: LeftRightArrow,
	Leftrightarrow: Leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	LeftRightVector: LeftRightVector,
	LeftTeeArrow: LeftTeeArrow,
	LeftTee: LeftTee,
	LeftTeeVector: LeftTeeVector,
	leftthreetimes: leftthreetimes,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangle: LeftTriangle,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftUpVector: LeftUpVector,
	LeftVectorBar: LeftVectorBar,
	LeftVector: LeftVector,
	lEg: lEg,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	lescc: lescc,
	les: les,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	lessgtr: lessgtr,
	LessLess: LessLess,
	lesssim: lesssim,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	lfisht: lfisht,
	lfloor: lfloor,
	Lfr: Lfr,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lHar: lHar,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	LJcy: LJcy,
	ljcy: ljcy,
	llarr: llarr,
	ll: ll,
	Ll: Ll,
	llcorner: llcorner,
	Lleftarrow: Lleftarrow,
	llhard: llhard,
	lltri: lltri,
	Lmidot: Lmidot,
	lmidot: lmidot,
	lmoustache: lmoustache,
	lmoust: lmoust,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lnE: lnE,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	LongLeftArrow: LongLeftArrow,
	Longleftarrow: Longleftarrow,
	longleftrightarrow: longleftrightarrow,
	LongLeftRightArrow: LongLeftRightArrow,
	Longleftrightarrow: Longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	LongRightArrow: LongRightArrow,
	Longrightarrow: Longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	Lopf: Lopf,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	Lscr: Lscr,
	lsh: lsh,
	Lsh: Lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	Lstrok: Lstrok,
	lstrok: lstrok,
	ltcc: ltcc,
	ltcir: ltcir,
	lt: lt,
	LT: LT,
	Lt: Lt,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	ltrPar: ltrPar,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	macr: macr,
	male: male,
	malt: malt,
	maltese: maltese,
	"Map": "⤅",
	map: map,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	Mcy: Mcy,
	mcy: mcy,
	mdash: mdash,
	mDDot: mDDot,
	measuredangle: measuredangle,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	mfr: mfr,
	mho: mho,
	micro: micro,
	midast: midast,
	midcir: midcir,
	mid: mid,
	middot: middot,
	minusb: minusb,
	minus: minus,
	minusd: minusd,
	minusdu: minusdu,
	MinusPlus: MinusPlus,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	Mopf: Mopf,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	Mscr: Mscr,
	mstpos: mstpos,
	Mu: Mu,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nabla: nabla,
	Nacute: Nacute,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natural: natural,
	naturals: naturals,
	natur: natur,
	nbsp: nbsp,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	Ncaron: Ncaron,
	ncaron: ncaron,
	Ncedil: Ncedil,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	Ncy: Ncy,
	ncy: ncy,
	ndash: ndash,
	nearhk: nearhk,
	nearr: nearr,
	neArr: neArr,
	nearrow: nearrow,
	ne: ne,
	nedot: nedot,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	nexist: nexist,
	nexists: nexists,
	Nfr: Nfr,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	nGg: nGg,
	ngsim: ngsim,
	nGt: nGt,
	ngt: ngt,
	ngtr: ngtr,
	nGtv: nGtv,
	nharr: nharr,
	nhArr: nhArr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	NJcy: NJcy,
	njcy: njcy,
	nlarr: nlarr,
	nlArr: nlArr,
	nldr: nldr,
	nlE: nlE,
	nle: nle,
	nleftarrow: nleftarrow,
	nLeftarrow: nLeftarrow,
	nleftrightarrow: nleftrightarrow,
	nLeftrightarrow: nLeftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nLl: nLl,
	nlsim: nlsim,
	nLt: nLt,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nLtv: nLtv,
	nmid: nmid,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	nopf: nopf,
	Nopf: Nopf,
	Not: Not,
	not: not,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	notin: notin,
	notindot: notindot,
	notinE: notinE,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	nparallel: nparallel,
	npar: npar,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	nprec: nprec,
	npreceq: npreceq,
	npre: npre,
	nrarrc: nrarrc,
	nrarr: nrarr,
	nrArr: nrArr,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nRightarrow: nRightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	Nscr: Nscr,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	Ntilde: Ntilde,
	ntilde: ntilde,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	Nu: Nu,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvap: nvap,
	nvdash: nvdash,
	nvDash: nvDash,
	nVdash: nVdash,
	nVDash: nVDash,
	nvge: nvge,
	nvgt: nvgt,
	nvHarr: nvHarr,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwArr: nwArr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	Oacute: Oacute,
	oacute: oacute,
	oast: oast,
	Ocirc: Ocirc,
	ocirc: ocirc,
	ocir: ocir,
	Ocy: Ocy,
	ocy: ocy,
	odash: odash,
	Odblac: Odblac,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	OElig: OElig,
	oelig: oelig,
	ofcir: ofcir,
	Ofr: Ofr,
	ofr: ofr,
	ogon: ogon,
	Ograve: Ograve,
	ograve: ograve,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	Omacr: Omacr,
	omacr: omacr,
	Omega: Omega,
	omega: omega,
	Omicron: Omicron,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	Oopf: Oopf,
	oopf: oopf,
	opar: opar,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	operp: operp,
	oplus: oplus,
	orarr: orarr,
	Or: Or,
	or: or,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf,
	ordm: ordm,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oS: oS,
	Oscr: Oscr,
	oscr: oscr,
	Oslash: Oslash,
	oslash: oslash,
	osol: osol,
	Otilde: Otilde,
	otilde: otilde,
	otimesas: otimesas,
	Otimes: Otimes,
	otimes: otimes,
	Ouml: Ouml,
	ouml: ouml,
	ovbar: ovbar,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	para: para,
	parallel: parallel,
	par: par,
	parsim: parsim,
	parsl: parsl,
	part: part,
	PartialD: PartialD,
	Pcy: Pcy,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	Pfr: Pfr,
	pfr: pfr,
	Phi: Phi,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	Pi: Pi,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plus: plus,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	PlusMinus: PlusMinus,
	plusmn: plusmn,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	Poincareplane: Poincareplane,
	pointint: pointint,
	popf: popf,
	Popf: Popf,
	pound: pound,
	prap: prap,
	Pr: Pr,
	pr: pr,
	prcue: prcue,
	precapprox: precapprox,
	prec: prec,
	preccurlyeq: preccurlyeq,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	pre: pre,
	prE: prE,
	precsim: precsim,
	prime: prime,
	Prime: Prime,
	primes: primes,
	prnap: prnap,
	prnE: prnE,
	prnsim: prnsim,
	prod: prod,
	Product: Product,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	Proportional: Proportional,
	Proportion: Proportion,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	Pscr: Pscr,
	pscr: pscr,
	Psi: Psi,
	psi: psi,
	puncsp: puncsp,
	Qfr: Qfr,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	Qopf: Qopf,
	qprime: qprime,
	Qscr: Qscr,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quot: quot,
	QUOT: QUOT,
	rAarr: rAarr,
	race: race,
	Racute: Racute,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	Rang: Rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raquo: raquo,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarr: rarr,
	Rarr: Rarr,
	rArr: rArr,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	Rarrtl: Rarrtl,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	rAtail: rAtail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rBarr: rBarr,
	RBarr: RBarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	Rcaron: Rcaron,
	rcaron: rcaron,
	Rcedil: Rcedil,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	Rcy: Rcy,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	Re: Re,
	rect: rect,
	reg: reg,
	REG: REG,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	Rfr: Rfr,
	rHar: rHar,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	Rho: Rho,
	rho: rho,
	rhov: rhov,
	RightAngleBracket: RightAngleBracket,
	RightArrowBar: RightArrowBar,
	rightarrow: rightarrow,
	RightArrow: RightArrow,
	Rightarrow: Rightarrow,
	RightArrowLeftArrow: RightArrowLeftArrow,
	rightarrowtail: rightarrowtail,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVectorBar: RightDownVectorBar,
	RightDownVector: RightDownVector,
	RightFloor: RightFloor,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	RightTeeArrow: RightTeeArrow,
	RightTee: RightTee,
	RightTeeVector: RightTeeVector,
	rightthreetimes: rightthreetimes,
	RightTriangleBar: RightTriangleBar,
	RightTriangle: RightTriangle,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVectorBar: RightUpVectorBar,
	RightUpVector: RightUpVector,
	RightVectorBar: RightVectorBar,
	RightVector: RightVector,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoustache: rmoustache,
	rmoust: rmoust,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	Ropf: Ropf,
	roplus: roplus,
	rotimes: rotimes,
	RoundImplies: RoundImplies,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	Rrightarrow: Rrightarrow,
	rsaquo: rsaquo,
	rscr: rscr,
	Rscr: Rscr,
	rsh: rsh,
	Rsh: Rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	RuleDelayed: RuleDelayed,
	ruluhar: ruluhar,
	rx: rx,
	Sacute: Sacute,
	sacute: sacute,
	sbquo: sbquo,
	scap: scap,
	Scaron: Scaron,
	scaron: scaron,
	Sc: Sc,
	sc: sc,
	sccue: sccue,
	sce: sce,
	scE: scE,
	Scedil: Scedil,
	scedil: scedil,
	Scirc: Scirc,
	scirc: scirc,
	scnap: scnap,
	scnE: scnE,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	Scy: Scy,
	scy: scy,
	sdotb: sdotb,
	sdot: sdot,
	sdote: sdote,
	searhk: searhk,
	searr: searr,
	seArr: seArr,
	searrow: searrow,
	sect: sect,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	Sfr: Sfr,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	SHCHcy: SHCHcy,
	shchcy: shchcy,
	SHcy: SHcy,
	shcy: shcy,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	shortmid: shortmid,
	shortparallel: shortparallel,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	shy: shy,
	Sigma: Sigma,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	SmallCircle: SmallCircle,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	SOFTcy: SOFTcy,
	softcy: softcy,
	solbar: solbar,
	solb: solb,
	sol: sol,
	Sopf: Sopf,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	Sqrt: Sqrt,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	square: square,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	squarf: squarf,
	squ: squ,
	squf: squf,
	srarr: srarr,
	Sscr: Sscr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	Star: Star,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub,
	Sub: Sub,
	subdot: subdot,
	subE: subE,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	Subset: Subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	SubsetEqual: SubsetEqual,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succapprox: succapprox,
	succ: succ,
	succcurlyeq: succcurlyeq,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	SuchThat: SuchThat,
	sum: sum,
	Sum: Sum,
	sung: sung,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	sup: sup,
	Sup: Sup,
	supdot: supdot,
	supdsub: supdsub,
	supE: supE,
	supe: supe,
	supedot: supedot,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	Supset: Supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swarhk: swarhk,
	swarr: swarr,
	swArr: swArr,
	swarrow: swarrow,
	swnwar: swnwar,
	szlig: szlig,
	Tab: Tab,
	target: target,
	Tau: Tau,
	tau: tau,
	tbrk: tbrk,
	Tcaron: Tcaron,
	tcaron: tcaron,
	Tcedil: Tcedil,
	tcedil: tcedil,
	Tcy: Tcy,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	Tfr: Tfr,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	Therefore: Therefore,
	Theta: Theta,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	THORN: THORN,
	thorn: thorn,
	tilde: tilde,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	timesbar: timesbar,
	timesb: timesb,
	times: times,
	timesd: timesd,
	tint: tint,
	toea: toea,
	topbot: topbot,
	topcir: topcir,
	top: top,
	Topf: Topf,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	TRADE: TRADE,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	TripleDot: TripleDot,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	Tscr: Tscr,
	tscr: tscr,
	TScy: TScy,
	tscy: tscy,
	TSHcy: TSHcy,
	tshcy: tshcy,
	Tstrok: Tstrok,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	Uacute: Uacute,
	uacute: uacute,
	uarr: uarr,
	Uarr: Uarr,
	uArr: uArr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	ubrcy: ubrcy,
	Ubreve: Ubreve,
	ubreve: ubreve,
	Ucirc: Ucirc,
	ucirc: ucirc,
	Ucy: Ucy,
	ucy: ucy,
	udarr: udarr,
	Udblac: Udblac,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	Ufr: Ufr,
	ufr: ufr,
	Ugrave: Ugrave,
	ugrave: ugrave,
	uHar: uHar,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	Umacr: Umacr,
	umacr: umacr,
	uml: uml,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	uogon: uogon,
	Uopf: Uopf,
	uopf: uopf,
	UpArrowBar: UpArrowBar,
	uparrow: uparrow,
	UpArrow: UpArrow,
	Uparrow: Uparrow,
	UpArrowDownArrow: UpArrowDownArrow,
	updownarrow: updownarrow,
	UpDownArrow: UpDownArrow,
	Updownarrow: Updownarrow,
	UpEquilibrium: UpEquilibrium,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	upsi: upsi,
	Upsi: Upsi,
	upsih: upsih,
	Upsilon: Upsilon,
	upsilon: upsilon,
	UpTeeArrow: UpTeeArrow,
	UpTee: UpTee,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	Uring: Uring,
	uring: uring,
	urtri: urtri,
	Uscr: Uscr,
	uscr: uscr,
	utdot: utdot,
	Utilde: Utilde,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	Uuml: Uuml,
	uuml: uuml,
	uwangle: uwangle,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	vArr: vArr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vBar: vBar,
	Vbar: Vbar,
	vBarv: vBarv,
	Vcy: Vcy,
	vcy: vcy,
	vdash: vdash,
	vDash: vDash,
	Vdash: Vdash,
	VDash: VDash,
	Vdashl: Vdashl,
	veebar: veebar,
	vee: vee,
	Vee: Vee,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	Verbar: Verbar,
	vert: vert,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	Vopf: Vopf,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	Vscr: Vscr,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	Vvdash: Vvdash,
	vzigzag: vzigzag,
	Wcirc: Wcirc,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	Wedge: Wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	Wfr: Wfr,
	wfr: wfr,
	Wopf: Wopf,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	Wscr: Wscr,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	Xfr: Xfr,
	xfr: xfr,
	xharr: xharr,
	xhArr: xhArr,
	Xi: Xi,
	xi: xi,
	xlarr: xlarr,
	xlArr: xlArr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	Xopf: Xopf,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrarr: xrarr,
	xrArr: xrArr,
	Xscr: Xscr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	Yacute: Yacute,
	yacute: yacute,
	YAcy: YAcy,
	yacy: yacy,
	Ycirc: Ycirc,
	ycirc: ycirc,
	Ycy: Ycy,
	ycy: ycy,
	yen: yen,
	Yfr: Yfr,
	yfr: yfr,
	YIcy: YIcy,
	yicy: yicy,
	Yopf: Yopf,
	yopf: yopf,
	Yscr: Yscr,
	yscr: yscr,
	YUcy: YUcy,
	yucy: yucy,
	yuml: yuml,
	Yuml: Yuml,
	Zacute: Zacute,
	zacute: zacute,
	Zcaron: Zcaron,
	zcaron: zcaron,
	Zcy: Zcy,
	zcy: zcy,
	Zdot: Zdot,
	zdot: zdot,
	zeetrf: zeetrf,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	zeta: zeta,
	zfr: zfr,
	Zfr: Zfr,
	ZHcy: ZHcy,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	Zopf: Zopf,
	Zscr: Zscr,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj
};

declare const entities$3_Aacute: typeof Aacute;
declare const entities$3_aacute: typeof aacute;
declare const entities$3_Abreve: typeof Abreve;
declare const entities$3_abreve: typeof abreve;
declare const entities$3_ac: typeof ac;
declare const entities$3_acd: typeof acd;
declare const entities$3_acE: typeof acE;
declare const entities$3_Acirc: typeof Acirc;
declare const entities$3_acirc: typeof acirc;
declare const entities$3_acute: typeof acute;
declare const entities$3_Acy: typeof Acy;
declare const entities$3_acy: typeof acy;
declare const entities$3_AElig: typeof AElig;
declare const entities$3_aelig: typeof aelig;
declare const entities$3_af: typeof af;
declare const entities$3_Afr: typeof Afr;
declare const entities$3_afr: typeof afr;
declare const entities$3_Agrave: typeof Agrave;
declare const entities$3_agrave: typeof agrave;
declare const entities$3_alefsym: typeof alefsym;
declare const entities$3_aleph: typeof aleph;
declare const entities$3_Alpha: typeof Alpha;
declare const entities$3_alpha: typeof alpha;
declare const entities$3_Amacr: typeof Amacr;
declare const entities$3_amacr: typeof amacr;
declare const entities$3_amalg: typeof amalg;
declare const entities$3_amp: typeof amp;
declare const entities$3_AMP: typeof AMP;
declare const entities$3_andand: typeof andand;
declare const entities$3_And: typeof And;
declare const entities$3_and: typeof and;
declare const entities$3_andd: typeof andd;
declare const entities$3_andslope: typeof andslope;
declare const entities$3_andv: typeof andv;
declare const entities$3_ang: typeof ang;
declare const entities$3_ange: typeof ange;
declare const entities$3_angle: typeof angle;
declare const entities$3_angmsdaa: typeof angmsdaa;
declare const entities$3_angmsdab: typeof angmsdab;
declare const entities$3_angmsdac: typeof angmsdac;
declare const entities$3_angmsdad: typeof angmsdad;
declare const entities$3_angmsdae: typeof angmsdae;
declare const entities$3_angmsdaf: typeof angmsdaf;
declare const entities$3_angmsdag: typeof angmsdag;
declare const entities$3_angmsdah: typeof angmsdah;
declare const entities$3_angmsd: typeof angmsd;
declare const entities$3_angrt: typeof angrt;
declare const entities$3_angrtvb: typeof angrtvb;
declare const entities$3_angrtvbd: typeof angrtvbd;
declare const entities$3_angsph: typeof angsph;
declare const entities$3_angst: typeof angst;
declare const entities$3_angzarr: typeof angzarr;
declare const entities$3_Aogon: typeof Aogon;
declare const entities$3_aogon: typeof aogon;
declare const entities$3_Aopf: typeof Aopf;
declare const entities$3_aopf: typeof aopf;
declare const entities$3_apacir: typeof apacir;
declare const entities$3_ap: typeof ap;
declare const entities$3_apE: typeof apE;
declare const entities$3_ape: typeof ape;
declare const entities$3_apid: typeof apid;
declare const entities$3_apos: typeof apos;
declare const entities$3_ApplyFunction: typeof ApplyFunction;
declare const entities$3_approx: typeof approx;
declare const entities$3_approxeq: typeof approxeq;
declare const entities$3_Aring: typeof Aring;
declare const entities$3_aring: typeof aring;
declare const entities$3_Ascr: typeof Ascr;
declare const entities$3_ascr: typeof ascr;
declare const entities$3_Assign: typeof Assign;
declare const entities$3_ast: typeof ast;
declare const entities$3_asymp: typeof asymp;
declare const entities$3_asympeq: typeof asympeq;
declare const entities$3_Atilde: typeof Atilde;
declare const entities$3_atilde: typeof atilde;
declare const entities$3_Auml: typeof Auml;
declare const entities$3_auml: typeof auml;
declare const entities$3_awconint: typeof awconint;
declare const entities$3_awint: typeof awint;
declare const entities$3_backcong: typeof backcong;
declare const entities$3_backepsilon: typeof backepsilon;
declare const entities$3_backprime: typeof backprime;
declare const entities$3_backsim: typeof backsim;
declare const entities$3_backsimeq: typeof backsimeq;
declare const entities$3_Backslash: typeof Backslash;
declare const entities$3_Barv: typeof Barv;
declare const entities$3_barvee: typeof barvee;
declare const entities$3_barwed: typeof barwed;
declare const entities$3_Barwed: typeof Barwed;
declare const entities$3_barwedge: typeof barwedge;
declare const entities$3_bbrk: typeof bbrk;
declare const entities$3_bbrktbrk: typeof bbrktbrk;
declare const entities$3_bcong: typeof bcong;
declare const entities$3_Bcy: typeof Bcy;
declare const entities$3_bcy: typeof bcy;
declare const entities$3_bdquo: typeof bdquo;
declare const entities$3_becaus: typeof becaus;
declare const entities$3_because: typeof because;
declare const entities$3_Because: typeof Because;
declare const entities$3_bemptyv: typeof bemptyv;
declare const entities$3_bepsi: typeof bepsi;
declare const entities$3_bernou: typeof bernou;
declare const entities$3_Bernoullis: typeof Bernoullis;
declare const entities$3_Beta: typeof Beta;
declare const entities$3_beta: typeof beta;
declare const entities$3_beth: typeof beth;
declare const entities$3_between: typeof between;
declare const entities$3_Bfr: typeof Bfr;
declare const entities$3_bfr: typeof bfr;
declare const entities$3_bigcap: typeof bigcap;
declare const entities$3_bigcirc: typeof bigcirc;
declare const entities$3_bigcup: typeof bigcup;
declare const entities$3_bigodot: typeof bigodot;
declare const entities$3_bigoplus: typeof bigoplus;
declare const entities$3_bigotimes: typeof bigotimes;
declare const entities$3_bigsqcup: typeof bigsqcup;
declare const entities$3_bigstar: typeof bigstar;
declare const entities$3_bigtriangledown: typeof bigtriangledown;
declare const entities$3_bigtriangleup: typeof bigtriangleup;
declare const entities$3_biguplus: typeof biguplus;
declare const entities$3_bigvee: typeof bigvee;
declare const entities$3_bigwedge: typeof bigwedge;
declare const entities$3_bkarow: typeof bkarow;
declare const entities$3_blacklozenge: typeof blacklozenge;
declare const entities$3_blacksquare: typeof blacksquare;
declare const entities$3_blacktriangle: typeof blacktriangle;
declare const entities$3_blacktriangledown: typeof blacktriangledown;
declare const entities$3_blacktriangleleft: typeof blacktriangleleft;
declare const entities$3_blacktriangleright: typeof blacktriangleright;
declare const entities$3_blank: typeof blank;
declare const entities$3_blk12: typeof blk12;
declare const entities$3_blk14: typeof blk14;
declare const entities$3_blk34: typeof blk34;
declare const entities$3_bne: typeof bne;
declare const entities$3_bnequiv: typeof bnequiv;
declare const entities$3_bNot: typeof bNot;
declare const entities$3_bnot: typeof bnot;
declare const entities$3_Bopf: typeof Bopf;
declare const entities$3_bopf: typeof bopf;
declare const entities$3_bot: typeof bot;
declare const entities$3_bottom: typeof bottom;
declare const entities$3_bowtie: typeof bowtie;
declare const entities$3_boxbox: typeof boxbox;
declare const entities$3_boxdl: typeof boxdl;
declare const entities$3_boxdL: typeof boxdL;
declare const entities$3_boxDl: typeof boxDl;
declare const entities$3_boxDL: typeof boxDL;
declare const entities$3_boxdr: typeof boxdr;
declare const entities$3_boxdR: typeof boxdR;
declare const entities$3_boxDr: typeof boxDr;
declare const entities$3_boxDR: typeof boxDR;
declare const entities$3_boxh: typeof boxh;
declare const entities$3_boxH: typeof boxH;
declare const entities$3_boxhd: typeof boxhd;
declare const entities$3_boxHd: typeof boxHd;
declare const entities$3_boxhD: typeof boxhD;
declare const entities$3_boxHD: typeof boxHD;
declare const entities$3_boxhu: typeof boxhu;
declare const entities$3_boxHu: typeof boxHu;
declare const entities$3_boxhU: typeof boxhU;
declare const entities$3_boxHU: typeof boxHU;
declare const entities$3_boxminus: typeof boxminus;
declare const entities$3_boxplus: typeof boxplus;
declare const entities$3_boxtimes: typeof boxtimes;
declare const entities$3_boxul: typeof boxul;
declare const entities$3_boxuL: typeof boxuL;
declare const entities$3_boxUl: typeof boxUl;
declare const entities$3_boxUL: typeof boxUL;
declare const entities$3_boxur: typeof boxur;
declare const entities$3_boxuR: typeof boxuR;
declare const entities$3_boxUr: typeof boxUr;
declare const entities$3_boxUR: typeof boxUR;
declare const entities$3_boxv: typeof boxv;
declare const entities$3_boxV: typeof boxV;
declare const entities$3_boxvh: typeof boxvh;
declare const entities$3_boxvH: typeof boxvH;
declare const entities$3_boxVh: typeof boxVh;
declare const entities$3_boxVH: typeof boxVH;
declare const entities$3_boxvl: typeof boxvl;
declare const entities$3_boxvL: typeof boxvL;
declare const entities$3_boxVl: typeof boxVl;
declare const entities$3_boxVL: typeof boxVL;
declare const entities$3_boxvr: typeof boxvr;
declare const entities$3_boxvR: typeof boxvR;
declare const entities$3_boxVr: typeof boxVr;
declare const entities$3_boxVR: typeof boxVR;
declare const entities$3_bprime: typeof bprime;
declare const entities$3_breve: typeof breve;
declare const entities$3_Breve: typeof Breve;
declare const entities$3_brvbar: typeof brvbar;
declare const entities$3_bscr: typeof bscr;
declare const entities$3_Bscr: typeof Bscr;
declare const entities$3_bsemi: typeof bsemi;
declare const entities$3_bsim: typeof bsim;
declare const entities$3_bsime: typeof bsime;
declare const entities$3_bsolb: typeof bsolb;
declare const entities$3_bsol: typeof bsol;
declare const entities$3_bsolhsub: typeof bsolhsub;
declare const entities$3_bull: typeof bull;
declare const entities$3_bullet: typeof bullet;
declare const entities$3_bump: typeof bump;
declare const entities$3_bumpE: typeof bumpE;
declare const entities$3_bumpe: typeof bumpe;
declare const entities$3_Bumpeq: typeof Bumpeq;
declare const entities$3_bumpeq: typeof bumpeq;
declare const entities$3_Cacute: typeof Cacute;
declare const entities$3_cacute: typeof cacute;
declare const entities$3_capand: typeof capand;
declare const entities$3_capbrcup: typeof capbrcup;
declare const entities$3_capcap: typeof capcap;
declare const entities$3_cap: typeof cap;
declare const entities$3_Cap: typeof Cap;
declare const entities$3_capcup: typeof capcup;
declare const entities$3_capdot: typeof capdot;
declare const entities$3_CapitalDifferentialD: typeof CapitalDifferentialD;
declare const entities$3_caps: typeof caps;
declare const entities$3_caret: typeof caret;
declare const entities$3_caron: typeof caron;
declare const entities$3_Cayleys: typeof Cayleys;
declare const entities$3_ccaps: typeof ccaps;
declare const entities$3_Ccaron: typeof Ccaron;
declare const entities$3_ccaron: typeof ccaron;
declare const entities$3_Ccedil: typeof Ccedil;
declare const entities$3_ccedil: typeof ccedil;
declare const entities$3_Ccirc: typeof Ccirc;
declare const entities$3_ccirc: typeof ccirc;
declare const entities$3_Cconint: typeof Cconint;
declare const entities$3_ccups: typeof ccups;
declare const entities$3_ccupssm: typeof ccupssm;
declare const entities$3_Cdot: typeof Cdot;
declare const entities$3_cdot: typeof cdot;
declare const entities$3_cedil: typeof cedil;
declare const entities$3_Cedilla: typeof Cedilla;
declare const entities$3_cemptyv: typeof cemptyv;
declare const entities$3_cent: typeof cent;
declare const entities$3_centerdot: typeof centerdot;
declare const entities$3_CenterDot: typeof CenterDot;
declare const entities$3_cfr: typeof cfr;
declare const entities$3_Cfr: typeof Cfr;
declare const entities$3_CHcy: typeof CHcy;
declare const entities$3_chcy: typeof chcy;
declare const entities$3_check: typeof check;
declare const entities$3_checkmark: typeof checkmark;
declare const entities$3_Chi: typeof Chi;
declare const entities$3_chi: typeof chi;
declare const entities$3_circ: typeof circ;
declare const entities$3_circeq: typeof circeq;
declare const entities$3_circlearrowleft: typeof circlearrowleft;
declare const entities$3_circlearrowright: typeof circlearrowright;
declare const entities$3_circledast: typeof circledast;
declare const entities$3_circledcirc: typeof circledcirc;
declare const entities$3_circleddash: typeof circleddash;
declare const entities$3_CircleDot: typeof CircleDot;
declare const entities$3_circledR: typeof circledR;
declare const entities$3_circledS: typeof circledS;
declare const entities$3_CircleMinus: typeof CircleMinus;
declare const entities$3_CirclePlus: typeof CirclePlus;
declare const entities$3_CircleTimes: typeof CircleTimes;
declare const entities$3_cir: typeof cir;
declare const entities$3_cirE: typeof cirE;
declare const entities$3_cire: typeof cire;
declare const entities$3_cirfnint: typeof cirfnint;
declare const entities$3_cirmid: typeof cirmid;
declare const entities$3_cirscir: typeof cirscir;
declare const entities$3_ClockwiseContourIntegral: typeof ClockwiseContourIntegral;
declare const entities$3_CloseCurlyDoubleQuote: typeof CloseCurlyDoubleQuote;
declare const entities$3_CloseCurlyQuote: typeof CloseCurlyQuote;
declare const entities$3_clubs: typeof clubs;
declare const entities$3_clubsuit: typeof clubsuit;
declare const entities$3_colon: typeof colon;
declare const entities$3_Colon: typeof Colon;
declare const entities$3_Colone: typeof Colone;
declare const entities$3_colone: typeof colone;
declare const entities$3_coloneq: typeof coloneq;
declare const entities$3_comma: typeof comma;
declare const entities$3_commat: typeof commat;
declare const entities$3_comp: typeof comp;
declare const entities$3_compfn: typeof compfn;
declare const entities$3_complement: typeof complement;
declare const entities$3_complexes: typeof complexes;
declare const entities$3_cong: typeof cong;
declare const entities$3_congdot: typeof congdot;
declare const entities$3_Congruent: typeof Congruent;
declare const entities$3_conint: typeof conint;
declare const entities$3_Conint: typeof Conint;
declare const entities$3_ContourIntegral: typeof ContourIntegral;
declare const entities$3_copf: typeof copf;
declare const entities$3_Copf: typeof Copf;
declare const entities$3_coprod: typeof coprod;
declare const entities$3_Coproduct: typeof Coproduct;
declare const entities$3_copy: typeof copy;
declare const entities$3_COPY: typeof COPY;
declare const entities$3_copysr: typeof copysr;
declare const entities$3_CounterClockwiseContourIntegral: typeof CounterClockwiseContourIntegral;
declare const entities$3_crarr: typeof crarr;
declare const entities$3_cross: typeof cross;
declare const entities$3_Cross: typeof Cross;
declare const entities$3_Cscr: typeof Cscr;
declare const entities$3_cscr: typeof cscr;
declare const entities$3_csub: typeof csub;
declare const entities$3_csube: typeof csube;
declare const entities$3_csup: typeof csup;
declare const entities$3_csupe: typeof csupe;
declare const entities$3_ctdot: typeof ctdot;
declare const entities$3_cudarrl: typeof cudarrl;
declare const entities$3_cudarrr: typeof cudarrr;
declare const entities$3_cuepr: typeof cuepr;
declare const entities$3_cuesc: typeof cuesc;
declare const entities$3_cularr: typeof cularr;
declare const entities$3_cularrp: typeof cularrp;
declare const entities$3_cupbrcap: typeof cupbrcap;
declare const entities$3_cupcap: typeof cupcap;
declare const entities$3_CupCap: typeof CupCap;
declare const entities$3_cup: typeof cup;
declare const entities$3_Cup: typeof Cup;
declare const entities$3_cupcup: typeof cupcup;
declare const entities$3_cupdot: typeof cupdot;
declare const entities$3_cupor: typeof cupor;
declare const entities$3_cups: typeof cups;
declare const entities$3_curarr: typeof curarr;
declare const entities$3_curarrm: typeof curarrm;
declare const entities$3_curlyeqprec: typeof curlyeqprec;
declare const entities$3_curlyeqsucc: typeof curlyeqsucc;
declare const entities$3_curlyvee: typeof curlyvee;
declare const entities$3_curlywedge: typeof curlywedge;
declare const entities$3_curren: typeof curren;
declare const entities$3_curvearrowleft: typeof curvearrowleft;
declare const entities$3_curvearrowright: typeof curvearrowright;
declare const entities$3_cuvee: typeof cuvee;
declare const entities$3_cuwed: typeof cuwed;
declare const entities$3_cwconint: typeof cwconint;
declare const entities$3_cwint: typeof cwint;
declare const entities$3_cylcty: typeof cylcty;
declare const entities$3_dagger: typeof dagger;
declare const entities$3_Dagger: typeof Dagger;
declare const entities$3_daleth: typeof daleth;
declare const entities$3_darr: typeof darr;
declare const entities$3_Darr: typeof Darr;
declare const entities$3_dArr: typeof dArr;
declare const entities$3_dash: typeof dash;
declare const entities$3_Dashv: typeof Dashv;
declare const entities$3_dashv: typeof dashv;
declare const entities$3_dbkarow: typeof dbkarow;
declare const entities$3_dblac: typeof dblac;
declare const entities$3_Dcaron: typeof Dcaron;
declare const entities$3_dcaron: typeof dcaron;
declare const entities$3_Dcy: typeof Dcy;
declare const entities$3_dcy: typeof dcy;
declare const entities$3_ddagger: typeof ddagger;
declare const entities$3_ddarr: typeof ddarr;
declare const entities$3_DD: typeof DD;
declare const entities$3_dd: typeof dd;
declare const entities$3_DDotrahd: typeof DDotrahd;
declare const entities$3_ddotseq: typeof ddotseq;
declare const entities$3_deg: typeof deg;
declare const entities$3_Del: typeof Del;
declare const entities$3_Delta: typeof Delta;
declare const entities$3_delta: typeof delta;
declare const entities$3_demptyv: typeof demptyv;
declare const entities$3_dfisht: typeof dfisht;
declare const entities$3_Dfr: typeof Dfr;
declare const entities$3_dfr: typeof dfr;
declare const entities$3_dHar: typeof dHar;
declare const entities$3_dharl: typeof dharl;
declare const entities$3_dharr: typeof dharr;
declare const entities$3_DiacriticalAcute: typeof DiacriticalAcute;
declare const entities$3_DiacriticalDot: typeof DiacriticalDot;
declare const entities$3_DiacriticalDoubleAcute: typeof DiacriticalDoubleAcute;
declare const entities$3_DiacriticalGrave: typeof DiacriticalGrave;
declare const entities$3_DiacriticalTilde: typeof DiacriticalTilde;
declare const entities$3_diam: typeof diam;
declare const entities$3_diamond: typeof diamond;
declare const entities$3_Diamond: typeof Diamond;
declare const entities$3_diamondsuit: typeof diamondsuit;
declare const entities$3_diams: typeof diams;
declare const entities$3_die: typeof die;
declare const entities$3_DifferentialD: typeof DifferentialD;
declare const entities$3_digamma: typeof digamma;
declare const entities$3_disin: typeof disin;
declare const entities$3_div: typeof div;
declare const entities$3_divide: typeof divide;
declare const entities$3_divideontimes: typeof divideontimes;
declare const entities$3_divonx: typeof divonx;
declare const entities$3_DJcy: typeof DJcy;
declare const entities$3_djcy: typeof djcy;
declare const entities$3_dlcorn: typeof dlcorn;
declare const entities$3_dlcrop: typeof dlcrop;
declare const entities$3_dollar: typeof dollar;
declare const entities$3_Dopf: typeof Dopf;
declare const entities$3_dopf: typeof dopf;
declare const entities$3_Dot: typeof Dot;
declare const entities$3_dot: typeof dot;
declare const entities$3_DotDot: typeof DotDot;
declare const entities$3_doteq: typeof doteq;
declare const entities$3_doteqdot: typeof doteqdot;
declare const entities$3_DotEqual: typeof DotEqual;
declare const entities$3_dotminus: typeof dotminus;
declare const entities$3_dotplus: typeof dotplus;
declare const entities$3_dotsquare: typeof dotsquare;
declare const entities$3_doublebarwedge: typeof doublebarwedge;
declare const entities$3_DoubleContourIntegral: typeof DoubleContourIntegral;
declare const entities$3_DoubleDot: typeof DoubleDot;
declare const entities$3_DoubleDownArrow: typeof DoubleDownArrow;
declare const entities$3_DoubleLeftArrow: typeof DoubleLeftArrow;
declare const entities$3_DoubleLeftRightArrow: typeof DoubleLeftRightArrow;
declare const entities$3_DoubleLeftTee: typeof DoubleLeftTee;
declare const entities$3_DoubleLongLeftArrow: typeof DoubleLongLeftArrow;
declare const entities$3_DoubleLongLeftRightArrow: typeof DoubleLongLeftRightArrow;
declare const entities$3_DoubleLongRightArrow: typeof DoubleLongRightArrow;
declare const entities$3_DoubleRightArrow: typeof DoubleRightArrow;
declare const entities$3_DoubleRightTee: typeof DoubleRightTee;
declare const entities$3_DoubleUpArrow: typeof DoubleUpArrow;
declare const entities$3_DoubleUpDownArrow: typeof DoubleUpDownArrow;
declare const entities$3_DoubleVerticalBar: typeof DoubleVerticalBar;
declare const entities$3_DownArrowBar: typeof DownArrowBar;
declare const entities$3_downarrow: typeof downarrow;
declare const entities$3_DownArrow: typeof DownArrow;
declare const entities$3_Downarrow: typeof Downarrow;
declare const entities$3_DownArrowUpArrow: typeof DownArrowUpArrow;
declare const entities$3_DownBreve: typeof DownBreve;
declare const entities$3_downdownarrows: typeof downdownarrows;
declare const entities$3_downharpoonleft: typeof downharpoonleft;
declare const entities$3_downharpoonright: typeof downharpoonright;
declare const entities$3_DownLeftRightVector: typeof DownLeftRightVector;
declare const entities$3_DownLeftTeeVector: typeof DownLeftTeeVector;
declare const entities$3_DownLeftVectorBar: typeof DownLeftVectorBar;
declare const entities$3_DownLeftVector: typeof DownLeftVector;
declare const entities$3_DownRightTeeVector: typeof DownRightTeeVector;
declare const entities$3_DownRightVectorBar: typeof DownRightVectorBar;
declare const entities$3_DownRightVector: typeof DownRightVector;
declare const entities$3_DownTeeArrow: typeof DownTeeArrow;
declare const entities$3_DownTee: typeof DownTee;
declare const entities$3_drbkarow: typeof drbkarow;
declare const entities$3_drcorn: typeof drcorn;
declare const entities$3_drcrop: typeof drcrop;
declare const entities$3_Dscr: typeof Dscr;
declare const entities$3_dscr: typeof dscr;
declare const entities$3_DScy: typeof DScy;
declare const entities$3_dscy: typeof dscy;
declare const entities$3_dsol: typeof dsol;
declare const entities$3_Dstrok: typeof Dstrok;
declare const entities$3_dstrok: typeof dstrok;
declare const entities$3_dtdot: typeof dtdot;
declare const entities$3_dtri: typeof dtri;
declare const entities$3_dtrif: typeof dtrif;
declare const entities$3_duarr: typeof duarr;
declare const entities$3_duhar: typeof duhar;
declare const entities$3_dwangle: typeof dwangle;
declare const entities$3_DZcy: typeof DZcy;
declare const entities$3_dzcy: typeof dzcy;
declare const entities$3_dzigrarr: typeof dzigrarr;
declare const entities$3_Eacute: typeof Eacute;
declare const entities$3_eacute: typeof eacute;
declare const entities$3_easter: typeof easter;
declare const entities$3_Ecaron: typeof Ecaron;
declare const entities$3_ecaron: typeof ecaron;
declare const entities$3_Ecirc: typeof Ecirc;
declare const entities$3_ecirc: typeof ecirc;
declare const entities$3_ecir: typeof ecir;
declare const entities$3_ecolon: typeof ecolon;
declare const entities$3_Ecy: typeof Ecy;
declare const entities$3_ecy: typeof ecy;
declare const entities$3_eDDot: typeof eDDot;
declare const entities$3_Edot: typeof Edot;
declare const entities$3_edot: typeof edot;
declare const entities$3_eDot: typeof eDot;
declare const entities$3_ee: typeof ee;
declare const entities$3_efDot: typeof efDot;
declare const entities$3_Efr: typeof Efr;
declare const entities$3_efr: typeof efr;
declare const entities$3_eg: typeof eg;
declare const entities$3_Egrave: typeof Egrave;
declare const entities$3_egrave: typeof egrave;
declare const entities$3_egs: typeof egs;
declare const entities$3_egsdot: typeof egsdot;
declare const entities$3_el: typeof el;
declare const entities$3_Element: typeof Element;
declare const entities$3_elinters: typeof elinters;
declare const entities$3_ell: typeof ell;
declare const entities$3_els: typeof els;
declare const entities$3_elsdot: typeof elsdot;
declare const entities$3_Emacr: typeof Emacr;
declare const entities$3_emacr: typeof emacr;
declare const entities$3_empty: typeof empty;
declare const entities$3_emptyset: typeof emptyset;
declare const entities$3_EmptySmallSquare: typeof EmptySmallSquare;
declare const entities$3_emptyv: typeof emptyv;
declare const entities$3_EmptyVerySmallSquare: typeof EmptyVerySmallSquare;
declare const entities$3_emsp13: typeof emsp13;
declare const entities$3_emsp14: typeof emsp14;
declare const entities$3_emsp: typeof emsp;
declare const entities$3_ENG: typeof ENG;
declare const entities$3_eng: typeof eng;
declare const entities$3_ensp: typeof ensp;
declare const entities$3_Eogon: typeof Eogon;
declare const entities$3_eogon: typeof eogon;
declare const entities$3_Eopf: typeof Eopf;
declare const entities$3_eopf: typeof eopf;
declare const entities$3_epar: typeof epar;
declare const entities$3_eparsl: typeof eparsl;
declare const entities$3_eplus: typeof eplus;
declare const entities$3_epsi: typeof epsi;
declare const entities$3_Epsilon: typeof Epsilon;
declare const entities$3_epsilon: typeof epsilon;
declare const entities$3_epsiv: typeof epsiv;
declare const entities$3_eqcirc: typeof eqcirc;
declare const entities$3_eqcolon: typeof eqcolon;
declare const entities$3_eqsim: typeof eqsim;
declare const entities$3_eqslantgtr: typeof eqslantgtr;
declare const entities$3_eqslantless: typeof eqslantless;
declare const entities$3_Equal: typeof Equal;
declare const entities$3_equals: typeof equals;
declare const entities$3_EqualTilde: typeof EqualTilde;
declare const entities$3_equest: typeof equest;
declare const entities$3_Equilibrium: typeof Equilibrium;
declare const entities$3_equiv: typeof equiv;
declare const entities$3_equivDD: typeof equivDD;
declare const entities$3_eqvparsl: typeof eqvparsl;
declare const entities$3_erarr: typeof erarr;
declare const entities$3_erDot: typeof erDot;
declare const entities$3_escr: typeof escr;
declare const entities$3_Escr: typeof Escr;
declare const entities$3_esdot: typeof esdot;
declare const entities$3_Esim: typeof Esim;
declare const entities$3_esim: typeof esim;
declare const entities$3_Eta: typeof Eta;
declare const entities$3_eta: typeof eta;
declare const entities$3_ETH: typeof ETH;
declare const entities$3_eth: typeof eth;
declare const entities$3_Euml: typeof Euml;
declare const entities$3_euml: typeof euml;
declare const entities$3_euro: typeof euro;
declare const entities$3_excl: typeof excl;
declare const entities$3_exist: typeof exist;
declare const entities$3_Exists: typeof Exists;
declare const entities$3_expectation: typeof expectation;
declare const entities$3_exponentiale: typeof exponentiale;
declare const entities$3_ExponentialE: typeof ExponentialE;
declare const entities$3_fallingdotseq: typeof fallingdotseq;
declare const entities$3_Fcy: typeof Fcy;
declare const entities$3_fcy: typeof fcy;
declare const entities$3_female: typeof female;
declare const entities$3_ffilig: typeof ffilig;
declare const entities$3_fflig: typeof fflig;
declare const entities$3_ffllig: typeof ffllig;
declare const entities$3_Ffr: typeof Ffr;
declare const entities$3_ffr: typeof ffr;
declare const entities$3_filig: typeof filig;
declare const entities$3_FilledSmallSquare: typeof FilledSmallSquare;
declare const entities$3_FilledVerySmallSquare: typeof FilledVerySmallSquare;
declare const entities$3_fjlig: typeof fjlig;
declare const entities$3_flat: typeof flat;
declare const entities$3_fllig: typeof fllig;
declare const entities$3_fltns: typeof fltns;
declare const entities$3_fnof: typeof fnof;
declare const entities$3_Fopf: typeof Fopf;
declare const entities$3_fopf: typeof fopf;
declare const entities$3_forall: typeof forall;
declare const entities$3_ForAll: typeof ForAll;
declare const entities$3_fork: typeof fork;
declare const entities$3_forkv: typeof forkv;
declare const entities$3_Fouriertrf: typeof Fouriertrf;
declare const entities$3_fpartint: typeof fpartint;
declare const entities$3_frac12: typeof frac12;
declare const entities$3_frac13: typeof frac13;
declare const entities$3_frac14: typeof frac14;
declare const entities$3_frac15: typeof frac15;
declare const entities$3_frac16: typeof frac16;
declare const entities$3_frac18: typeof frac18;
declare const entities$3_frac23: typeof frac23;
declare const entities$3_frac25: typeof frac25;
declare const entities$3_frac34: typeof frac34;
declare const entities$3_frac35: typeof frac35;
declare const entities$3_frac38: typeof frac38;
declare const entities$3_frac45: typeof frac45;
declare const entities$3_frac56: typeof frac56;
declare const entities$3_frac58: typeof frac58;
declare const entities$3_frac78: typeof frac78;
declare const entities$3_frasl: typeof frasl;
declare const entities$3_frown: typeof frown;
declare const entities$3_fscr: typeof fscr;
declare const entities$3_Fscr: typeof Fscr;
declare const entities$3_gacute: typeof gacute;
declare const entities$3_Gamma: typeof Gamma;
declare const entities$3_gamma: typeof gamma;
declare const entities$3_Gammad: typeof Gammad;
declare const entities$3_gammad: typeof gammad;
declare const entities$3_gap: typeof gap;
declare const entities$3_Gbreve: typeof Gbreve;
declare const entities$3_gbreve: typeof gbreve;
declare const entities$3_Gcedil: typeof Gcedil;
declare const entities$3_Gcirc: typeof Gcirc;
declare const entities$3_gcirc: typeof gcirc;
declare const entities$3_Gcy: typeof Gcy;
declare const entities$3_gcy: typeof gcy;
declare const entities$3_Gdot: typeof Gdot;
declare const entities$3_gdot: typeof gdot;
declare const entities$3_ge: typeof ge;
declare const entities$3_gE: typeof gE;
declare const entities$3_gEl: typeof gEl;
declare const entities$3_gel: typeof gel;
declare const entities$3_geq: typeof geq;
declare const entities$3_geqq: typeof geqq;
declare const entities$3_geqslant: typeof geqslant;
declare const entities$3_gescc: typeof gescc;
declare const entities$3_ges: typeof ges;
declare const entities$3_gesdot: typeof gesdot;
declare const entities$3_gesdoto: typeof gesdoto;
declare const entities$3_gesdotol: typeof gesdotol;
declare const entities$3_gesl: typeof gesl;
declare const entities$3_gesles: typeof gesles;
declare const entities$3_Gfr: typeof Gfr;
declare const entities$3_gfr: typeof gfr;
declare const entities$3_gg: typeof gg;
declare const entities$3_Gg: typeof Gg;
declare const entities$3_ggg: typeof ggg;
declare const entities$3_gimel: typeof gimel;
declare const entities$3_GJcy: typeof GJcy;
declare const entities$3_gjcy: typeof gjcy;
declare const entities$3_gla: typeof gla;
declare const entities$3_gl: typeof gl;
declare const entities$3_glE: typeof glE;
declare const entities$3_glj: typeof glj;
declare const entities$3_gnap: typeof gnap;
declare const entities$3_gnapprox: typeof gnapprox;
declare const entities$3_gne: typeof gne;
declare const entities$3_gnE: typeof gnE;
declare const entities$3_gneq: typeof gneq;
declare const entities$3_gneqq: typeof gneqq;
declare const entities$3_gnsim: typeof gnsim;
declare const entities$3_Gopf: typeof Gopf;
declare const entities$3_gopf: typeof gopf;
declare const entities$3_grave: typeof grave;
declare const entities$3_GreaterEqual: typeof GreaterEqual;
declare const entities$3_GreaterEqualLess: typeof GreaterEqualLess;
declare const entities$3_GreaterFullEqual: typeof GreaterFullEqual;
declare const entities$3_GreaterGreater: typeof GreaterGreater;
declare const entities$3_GreaterLess: typeof GreaterLess;
declare const entities$3_GreaterSlantEqual: typeof GreaterSlantEqual;
declare const entities$3_GreaterTilde: typeof GreaterTilde;
declare const entities$3_Gscr: typeof Gscr;
declare const entities$3_gscr: typeof gscr;
declare const entities$3_gsim: typeof gsim;
declare const entities$3_gsime: typeof gsime;
declare const entities$3_gsiml: typeof gsiml;
declare const entities$3_gtcc: typeof gtcc;
declare const entities$3_gtcir: typeof gtcir;
declare const entities$3_gt: typeof gt;
declare const entities$3_GT: typeof GT;
declare const entities$3_Gt: typeof Gt;
declare const entities$3_gtdot: typeof gtdot;
declare const entities$3_gtlPar: typeof gtlPar;
declare const entities$3_gtquest: typeof gtquest;
declare const entities$3_gtrapprox: typeof gtrapprox;
declare const entities$3_gtrarr: typeof gtrarr;
declare const entities$3_gtrdot: typeof gtrdot;
declare const entities$3_gtreqless: typeof gtreqless;
declare const entities$3_gtreqqless: typeof gtreqqless;
declare const entities$3_gtrless: typeof gtrless;
declare const entities$3_gtrsim: typeof gtrsim;
declare const entities$3_gvertneqq: typeof gvertneqq;
declare const entities$3_gvnE: typeof gvnE;
declare const entities$3_Hacek: typeof Hacek;
declare const entities$3_hairsp: typeof hairsp;
declare const entities$3_half: typeof half;
declare const entities$3_hamilt: typeof hamilt;
declare const entities$3_HARDcy: typeof HARDcy;
declare const entities$3_hardcy: typeof hardcy;
declare const entities$3_harrcir: typeof harrcir;
declare const entities$3_harr: typeof harr;
declare const entities$3_hArr: typeof hArr;
declare const entities$3_harrw: typeof harrw;
declare const entities$3_Hat: typeof Hat;
declare const entities$3_hbar: typeof hbar;
declare const entities$3_Hcirc: typeof Hcirc;
declare const entities$3_hcirc: typeof hcirc;
declare const entities$3_hearts: typeof hearts;
declare const entities$3_heartsuit: typeof heartsuit;
declare const entities$3_hellip: typeof hellip;
declare const entities$3_hercon: typeof hercon;
declare const entities$3_hfr: typeof hfr;
declare const entities$3_Hfr: typeof Hfr;
declare const entities$3_HilbertSpace: typeof HilbertSpace;
declare const entities$3_hksearow: typeof hksearow;
declare const entities$3_hkswarow: typeof hkswarow;
declare const entities$3_hoarr: typeof hoarr;
declare const entities$3_homtht: typeof homtht;
declare const entities$3_hookleftarrow: typeof hookleftarrow;
declare const entities$3_hookrightarrow: typeof hookrightarrow;
declare const entities$3_hopf: typeof hopf;
declare const entities$3_Hopf: typeof Hopf;
declare const entities$3_horbar: typeof horbar;
declare const entities$3_HorizontalLine: typeof HorizontalLine;
declare const entities$3_hscr: typeof hscr;
declare const entities$3_Hscr: typeof Hscr;
declare const entities$3_hslash: typeof hslash;
declare const entities$3_Hstrok: typeof Hstrok;
declare const entities$3_hstrok: typeof hstrok;
declare const entities$3_HumpDownHump: typeof HumpDownHump;
declare const entities$3_HumpEqual: typeof HumpEqual;
declare const entities$3_hybull: typeof hybull;
declare const entities$3_hyphen: typeof hyphen;
declare const entities$3_Iacute: typeof Iacute;
declare const entities$3_iacute: typeof iacute;
declare const entities$3_ic: typeof ic;
declare const entities$3_Icirc: typeof Icirc;
declare const entities$3_icirc: typeof icirc;
declare const entities$3_Icy: typeof Icy;
declare const entities$3_icy: typeof icy;
declare const entities$3_Idot: typeof Idot;
declare const entities$3_IEcy: typeof IEcy;
declare const entities$3_iecy: typeof iecy;
declare const entities$3_iexcl: typeof iexcl;
declare const entities$3_iff: typeof iff;
declare const entities$3_ifr: typeof ifr;
declare const entities$3_Ifr: typeof Ifr;
declare const entities$3_Igrave: typeof Igrave;
declare const entities$3_igrave: typeof igrave;
declare const entities$3_ii: typeof ii;
declare const entities$3_iiiint: typeof iiiint;
declare const entities$3_iiint: typeof iiint;
declare const entities$3_iinfin: typeof iinfin;
declare const entities$3_iiota: typeof iiota;
declare const entities$3_IJlig: typeof IJlig;
declare const entities$3_ijlig: typeof ijlig;
declare const entities$3_Imacr: typeof Imacr;
declare const entities$3_imacr: typeof imacr;
declare const entities$3_ImaginaryI: typeof ImaginaryI;
declare const entities$3_imagline: typeof imagline;
declare const entities$3_imagpart: typeof imagpart;
declare const entities$3_imath: typeof imath;
declare const entities$3_Im: typeof Im;
declare const entities$3_imof: typeof imof;
declare const entities$3_imped: typeof imped;
declare const entities$3_Implies: typeof Implies;
declare const entities$3_incare: typeof incare;
declare const entities$3_infin: typeof infin;
declare const entities$3_infintie: typeof infintie;
declare const entities$3_inodot: typeof inodot;
declare const entities$3_intcal: typeof intcal;
declare const entities$3_int: typeof int;
declare const entities$3_Int: typeof Int;
declare const entities$3_integers: typeof integers;
declare const entities$3_Integral: typeof Integral;
declare const entities$3_intercal: typeof intercal;
declare const entities$3_Intersection: typeof Intersection;
declare const entities$3_intlarhk: typeof intlarhk;
declare const entities$3_intprod: typeof intprod;
declare const entities$3_InvisibleComma: typeof InvisibleComma;
declare const entities$3_InvisibleTimes: typeof InvisibleTimes;
declare const entities$3_IOcy: typeof IOcy;
declare const entities$3_iocy: typeof iocy;
declare const entities$3_Iogon: typeof Iogon;
declare const entities$3_iogon: typeof iogon;
declare const entities$3_Iopf: typeof Iopf;
declare const entities$3_iopf: typeof iopf;
declare const entities$3_Iota: typeof Iota;
declare const entities$3_iota: typeof iota;
declare const entities$3_iprod: typeof iprod;
declare const entities$3_iquest: typeof iquest;
declare const entities$3_iscr: typeof iscr;
declare const entities$3_Iscr: typeof Iscr;
declare const entities$3_isin: typeof isin;
declare const entities$3_isindot: typeof isindot;
declare const entities$3_isinE: typeof isinE;
declare const entities$3_isins: typeof isins;
declare const entities$3_isinsv: typeof isinsv;
declare const entities$3_isinv: typeof isinv;
declare const entities$3_it: typeof it;
declare const entities$3_Itilde: typeof Itilde;
declare const entities$3_itilde: typeof itilde;
declare const entities$3_Iukcy: typeof Iukcy;
declare const entities$3_iukcy: typeof iukcy;
declare const entities$3_Iuml: typeof Iuml;
declare const entities$3_iuml: typeof iuml;
declare const entities$3_Jcirc: typeof Jcirc;
declare const entities$3_jcirc: typeof jcirc;
declare const entities$3_Jcy: typeof Jcy;
declare const entities$3_jcy: typeof jcy;
declare const entities$3_Jfr: typeof Jfr;
declare const entities$3_jfr: typeof jfr;
declare const entities$3_jmath: typeof jmath;
declare const entities$3_Jopf: typeof Jopf;
declare const entities$3_jopf: typeof jopf;
declare const entities$3_Jscr: typeof Jscr;
declare const entities$3_jscr: typeof jscr;
declare const entities$3_Jsercy: typeof Jsercy;
declare const entities$3_jsercy: typeof jsercy;
declare const entities$3_Jukcy: typeof Jukcy;
declare const entities$3_jukcy: typeof jukcy;
declare const entities$3_Kappa: typeof Kappa;
declare const entities$3_kappa: typeof kappa;
declare const entities$3_kappav: typeof kappav;
declare const entities$3_Kcedil: typeof Kcedil;
declare const entities$3_kcedil: typeof kcedil;
declare const entities$3_Kcy: typeof Kcy;
declare const entities$3_kcy: typeof kcy;
declare const entities$3_Kfr: typeof Kfr;
declare const entities$3_kfr: typeof kfr;
declare const entities$3_kgreen: typeof kgreen;
declare const entities$3_KHcy: typeof KHcy;
declare const entities$3_khcy: typeof khcy;
declare const entities$3_KJcy: typeof KJcy;
declare const entities$3_kjcy: typeof kjcy;
declare const entities$3_Kopf: typeof Kopf;
declare const entities$3_kopf: typeof kopf;
declare const entities$3_Kscr: typeof Kscr;
declare const entities$3_kscr: typeof kscr;
declare const entities$3_lAarr: typeof lAarr;
declare const entities$3_Lacute: typeof Lacute;
declare const entities$3_lacute: typeof lacute;
declare const entities$3_laemptyv: typeof laemptyv;
declare const entities$3_lagran: typeof lagran;
declare const entities$3_Lambda: typeof Lambda;
declare const entities$3_lambda: typeof lambda;
declare const entities$3_lang: typeof lang;
declare const entities$3_Lang: typeof Lang;
declare const entities$3_langd: typeof langd;
declare const entities$3_langle: typeof langle;
declare const entities$3_lap: typeof lap;
declare const entities$3_Laplacetrf: typeof Laplacetrf;
declare const entities$3_laquo: typeof laquo;
declare const entities$3_larrb: typeof larrb;
declare const entities$3_larrbfs: typeof larrbfs;
declare const entities$3_larr: typeof larr;
declare const entities$3_Larr: typeof Larr;
declare const entities$3_lArr: typeof lArr;
declare const entities$3_larrfs: typeof larrfs;
declare const entities$3_larrhk: typeof larrhk;
declare const entities$3_larrlp: typeof larrlp;
declare const entities$3_larrpl: typeof larrpl;
declare const entities$3_larrsim: typeof larrsim;
declare const entities$3_larrtl: typeof larrtl;
declare const entities$3_latail: typeof latail;
declare const entities$3_lAtail: typeof lAtail;
declare const entities$3_lat: typeof lat;
declare const entities$3_late: typeof late;
declare const entities$3_lates: typeof lates;
declare const entities$3_lbarr: typeof lbarr;
declare const entities$3_lBarr: typeof lBarr;
declare const entities$3_lbbrk: typeof lbbrk;
declare const entities$3_lbrace: typeof lbrace;
declare const entities$3_lbrack: typeof lbrack;
declare const entities$3_lbrke: typeof lbrke;
declare const entities$3_lbrksld: typeof lbrksld;
declare const entities$3_lbrkslu: typeof lbrkslu;
declare const entities$3_Lcaron: typeof Lcaron;
declare const entities$3_lcaron: typeof lcaron;
declare const entities$3_Lcedil: typeof Lcedil;
declare const entities$3_lcedil: typeof lcedil;
declare const entities$3_lceil: typeof lceil;
declare const entities$3_lcub: typeof lcub;
declare const entities$3_Lcy: typeof Lcy;
declare const entities$3_lcy: typeof lcy;
declare const entities$3_ldca: typeof ldca;
declare const entities$3_ldquo: typeof ldquo;
declare const entities$3_ldquor: typeof ldquor;
declare const entities$3_ldrdhar: typeof ldrdhar;
declare const entities$3_ldrushar: typeof ldrushar;
declare const entities$3_ldsh: typeof ldsh;
declare const entities$3_le: typeof le;
declare const entities$3_lE: typeof lE;
declare const entities$3_LeftAngleBracket: typeof LeftAngleBracket;
declare const entities$3_LeftArrowBar: typeof LeftArrowBar;
declare const entities$3_leftarrow: typeof leftarrow;
declare const entities$3_LeftArrow: typeof LeftArrow;
declare const entities$3_Leftarrow: typeof Leftarrow;
declare const entities$3_LeftArrowRightArrow: typeof LeftArrowRightArrow;
declare const entities$3_leftarrowtail: typeof leftarrowtail;
declare const entities$3_LeftCeiling: typeof LeftCeiling;
declare const entities$3_LeftDoubleBracket: typeof LeftDoubleBracket;
declare const entities$3_LeftDownTeeVector: typeof LeftDownTeeVector;
declare const entities$3_LeftDownVectorBar: typeof LeftDownVectorBar;
declare const entities$3_LeftDownVector: typeof LeftDownVector;
declare const entities$3_LeftFloor: typeof LeftFloor;
declare const entities$3_leftharpoondown: typeof leftharpoondown;
declare const entities$3_leftharpoonup: typeof leftharpoonup;
declare const entities$3_leftleftarrows: typeof leftleftarrows;
declare const entities$3_leftrightarrow: typeof leftrightarrow;
declare const entities$3_LeftRightArrow: typeof LeftRightArrow;
declare const entities$3_Leftrightarrow: typeof Leftrightarrow;
declare const entities$3_leftrightarrows: typeof leftrightarrows;
declare const entities$3_leftrightharpoons: typeof leftrightharpoons;
declare const entities$3_leftrightsquigarrow: typeof leftrightsquigarrow;
declare const entities$3_LeftRightVector: typeof LeftRightVector;
declare const entities$3_LeftTeeArrow: typeof LeftTeeArrow;
declare const entities$3_LeftTee: typeof LeftTee;
declare const entities$3_LeftTeeVector: typeof LeftTeeVector;
declare const entities$3_leftthreetimes: typeof leftthreetimes;
declare const entities$3_LeftTriangleBar: typeof LeftTriangleBar;
declare const entities$3_LeftTriangle: typeof LeftTriangle;
declare const entities$3_LeftTriangleEqual: typeof LeftTriangleEqual;
declare const entities$3_LeftUpDownVector: typeof LeftUpDownVector;
declare const entities$3_LeftUpTeeVector: typeof LeftUpTeeVector;
declare const entities$3_LeftUpVectorBar: typeof LeftUpVectorBar;
declare const entities$3_LeftUpVector: typeof LeftUpVector;
declare const entities$3_LeftVectorBar: typeof LeftVectorBar;
declare const entities$3_LeftVector: typeof LeftVector;
declare const entities$3_lEg: typeof lEg;
declare const entities$3_leg: typeof leg;
declare const entities$3_leq: typeof leq;
declare const entities$3_leqq: typeof leqq;
declare const entities$3_leqslant: typeof leqslant;
declare const entities$3_lescc: typeof lescc;
declare const entities$3_les: typeof les;
declare const entities$3_lesdot: typeof lesdot;
declare const entities$3_lesdoto: typeof lesdoto;
declare const entities$3_lesdotor: typeof lesdotor;
declare const entities$3_lesg: typeof lesg;
declare const entities$3_lesges: typeof lesges;
declare const entities$3_lessapprox: typeof lessapprox;
declare const entities$3_lessdot: typeof lessdot;
declare const entities$3_lesseqgtr: typeof lesseqgtr;
declare const entities$3_lesseqqgtr: typeof lesseqqgtr;
declare const entities$3_LessEqualGreater: typeof LessEqualGreater;
declare const entities$3_LessFullEqual: typeof LessFullEqual;
declare const entities$3_LessGreater: typeof LessGreater;
declare const entities$3_lessgtr: typeof lessgtr;
declare const entities$3_LessLess: typeof LessLess;
declare const entities$3_lesssim: typeof lesssim;
declare const entities$3_LessSlantEqual: typeof LessSlantEqual;
declare const entities$3_LessTilde: typeof LessTilde;
declare const entities$3_lfisht: typeof lfisht;
declare const entities$3_lfloor: typeof lfloor;
declare const entities$3_Lfr: typeof Lfr;
declare const entities$3_lfr: typeof lfr;
declare const entities$3_lg: typeof lg;
declare const entities$3_lgE: typeof lgE;
declare const entities$3_lHar: typeof lHar;
declare const entities$3_lhard: typeof lhard;
declare const entities$3_lharu: typeof lharu;
declare const entities$3_lharul: typeof lharul;
declare const entities$3_lhblk: typeof lhblk;
declare const entities$3_LJcy: typeof LJcy;
declare const entities$3_ljcy: typeof ljcy;
declare const entities$3_llarr: typeof llarr;
declare const entities$3_ll: typeof ll;
declare const entities$3_Ll: typeof Ll;
declare const entities$3_llcorner: typeof llcorner;
declare const entities$3_Lleftarrow: typeof Lleftarrow;
declare const entities$3_llhard: typeof llhard;
declare const entities$3_lltri: typeof lltri;
declare const entities$3_Lmidot: typeof Lmidot;
declare const entities$3_lmidot: typeof lmidot;
declare const entities$3_lmoustache: typeof lmoustache;
declare const entities$3_lmoust: typeof lmoust;
declare const entities$3_lnap: typeof lnap;
declare const entities$3_lnapprox: typeof lnapprox;
declare const entities$3_lne: typeof lne;
declare const entities$3_lnE: typeof lnE;
declare const entities$3_lneq: typeof lneq;
declare const entities$3_lneqq: typeof lneqq;
declare const entities$3_lnsim: typeof lnsim;
declare const entities$3_loang: typeof loang;
declare const entities$3_loarr: typeof loarr;
declare const entities$3_lobrk: typeof lobrk;
declare const entities$3_longleftarrow: typeof longleftarrow;
declare const entities$3_LongLeftArrow: typeof LongLeftArrow;
declare const entities$3_Longleftarrow: typeof Longleftarrow;
declare const entities$3_longleftrightarrow: typeof longleftrightarrow;
declare const entities$3_LongLeftRightArrow: typeof LongLeftRightArrow;
declare const entities$3_Longleftrightarrow: typeof Longleftrightarrow;
declare const entities$3_longmapsto: typeof longmapsto;
declare const entities$3_longrightarrow: typeof longrightarrow;
declare const entities$3_LongRightArrow: typeof LongRightArrow;
declare const entities$3_Longrightarrow: typeof Longrightarrow;
declare const entities$3_looparrowleft: typeof looparrowleft;
declare const entities$3_looparrowright: typeof looparrowright;
declare const entities$3_lopar: typeof lopar;
declare const entities$3_Lopf: typeof Lopf;
declare const entities$3_lopf: typeof lopf;
declare const entities$3_loplus: typeof loplus;
declare const entities$3_lotimes: typeof lotimes;
declare const entities$3_lowast: typeof lowast;
declare const entities$3_lowbar: typeof lowbar;
declare const entities$3_LowerLeftArrow: typeof LowerLeftArrow;
declare const entities$3_LowerRightArrow: typeof LowerRightArrow;
declare const entities$3_loz: typeof loz;
declare const entities$3_lozenge: typeof lozenge;
declare const entities$3_lozf: typeof lozf;
declare const entities$3_lpar: typeof lpar;
declare const entities$3_lparlt: typeof lparlt;
declare const entities$3_lrarr: typeof lrarr;
declare const entities$3_lrcorner: typeof lrcorner;
declare const entities$3_lrhar: typeof lrhar;
declare const entities$3_lrhard: typeof lrhard;
declare const entities$3_lrm: typeof lrm;
declare const entities$3_lrtri: typeof lrtri;
declare const entities$3_lsaquo: typeof lsaquo;
declare const entities$3_lscr: typeof lscr;
declare const entities$3_Lscr: typeof Lscr;
declare const entities$3_lsh: typeof lsh;
declare const entities$3_Lsh: typeof Lsh;
declare const entities$3_lsim: typeof lsim;
declare const entities$3_lsime: typeof lsime;
declare const entities$3_lsimg: typeof lsimg;
declare const entities$3_lsqb: typeof lsqb;
declare const entities$3_lsquo: typeof lsquo;
declare const entities$3_lsquor: typeof lsquor;
declare const entities$3_Lstrok: typeof Lstrok;
declare const entities$3_lstrok: typeof lstrok;
declare const entities$3_ltcc: typeof ltcc;
declare const entities$3_ltcir: typeof ltcir;
declare const entities$3_lt: typeof lt;
declare const entities$3_LT: typeof LT;
declare const entities$3_Lt: typeof Lt;
declare const entities$3_ltdot: typeof ltdot;
declare const entities$3_lthree: typeof lthree;
declare const entities$3_ltimes: typeof ltimes;
declare const entities$3_ltlarr: typeof ltlarr;
declare const entities$3_ltquest: typeof ltquest;
declare const entities$3_ltri: typeof ltri;
declare const entities$3_ltrie: typeof ltrie;
declare const entities$3_ltrif: typeof ltrif;
declare const entities$3_ltrPar: typeof ltrPar;
declare const entities$3_lurdshar: typeof lurdshar;
declare const entities$3_luruhar: typeof luruhar;
declare const entities$3_lvertneqq: typeof lvertneqq;
declare const entities$3_lvnE: typeof lvnE;
declare const entities$3_macr: typeof macr;
declare const entities$3_male: typeof male;
declare const entities$3_malt: typeof malt;
declare const entities$3_maltese: typeof maltese;
declare const entities$3_map: typeof map;
declare const entities$3_mapsto: typeof mapsto;
declare const entities$3_mapstodown: typeof mapstodown;
declare const entities$3_mapstoleft: typeof mapstoleft;
declare const entities$3_mapstoup: typeof mapstoup;
declare const entities$3_marker: typeof marker;
declare const entities$3_mcomma: typeof mcomma;
declare const entities$3_Mcy: typeof Mcy;
declare const entities$3_mcy: typeof mcy;
declare const entities$3_mdash: typeof mdash;
declare const entities$3_mDDot: typeof mDDot;
declare const entities$3_measuredangle: typeof measuredangle;
declare const entities$3_MediumSpace: typeof MediumSpace;
declare const entities$3_Mellintrf: typeof Mellintrf;
declare const entities$3_Mfr: typeof Mfr;
declare const entities$3_mfr: typeof mfr;
declare const entities$3_mho: typeof mho;
declare const entities$3_micro: typeof micro;
declare const entities$3_midast: typeof midast;
declare const entities$3_midcir: typeof midcir;
declare const entities$3_mid: typeof mid;
declare const entities$3_middot: typeof middot;
declare const entities$3_minusb: typeof minusb;
declare const entities$3_minus: typeof minus;
declare const entities$3_minusd: typeof minusd;
declare const entities$3_minusdu: typeof minusdu;
declare const entities$3_MinusPlus: typeof MinusPlus;
declare const entities$3_mlcp: typeof mlcp;
declare const entities$3_mldr: typeof mldr;
declare const entities$3_mnplus: typeof mnplus;
declare const entities$3_models: typeof models;
declare const entities$3_Mopf: typeof Mopf;
declare const entities$3_mopf: typeof mopf;
declare const entities$3_mp: typeof mp;
declare const entities$3_mscr: typeof mscr;
declare const entities$3_Mscr: typeof Mscr;
declare const entities$3_mstpos: typeof mstpos;
declare const entities$3_Mu: typeof Mu;
declare const entities$3_mu: typeof mu;
declare const entities$3_multimap: typeof multimap;
declare const entities$3_mumap: typeof mumap;
declare const entities$3_nabla: typeof nabla;
declare const entities$3_Nacute: typeof Nacute;
declare const entities$3_nacute: typeof nacute;
declare const entities$3_nang: typeof nang;
declare const entities$3_nap: typeof nap;
declare const entities$3_napE: typeof napE;
declare const entities$3_napid: typeof napid;
declare const entities$3_napos: typeof napos;
declare const entities$3_napprox: typeof napprox;
declare const entities$3_natural: typeof natural;
declare const entities$3_naturals: typeof naturals;
declare const entities$3_natur: typeof natur;
declare const entities$3_nbsp: typeof nbsp;
declare const entities$3_nbump: typeof nbump;
declare const entities$3_nbumpe: typeof nbumpe;
declare const entities$3_ncap: typeof ncap;
declare const entities$3_Ncaron: typeof Ncaron;
declare const entities$3_ncaron: typeof ncaron;
declare const entities$3_Ncedil: typeof Ncedil;
declare const entities$3_ncedil: typeof ncedil;
declare const entities$3_ncong: typeof ncong;
declare const entities$3_ncongdot: typeof ncongdot;
declare const entities$3_ncup: typeof ncup;
declare const entities$3_Ncy: typeof Ncy;
declare const entities$3_ncy: typeof ncy;
declare const entities$3_ndash: typeof ndash;
declare const entities$3_nearhk: typeof nearhk;
declare const entities$3_nearr: typeof nearr;
declare const entities$3_neArr: typeof neArr;
declare const entities$3_nearrow: typeof nearrow;
declare const entities$3_ne: typeof ne;
declare const entities$3_nedot: typeof nedot;
declare const entities$3_NegativeMediumSpace: typeof NegativeMediumSpace;
declare const entities$3_NegativeThickSpace: typeof NegativeThickSpace;
declare const entities$3_NegativeThinSpace: typeof NegativeThinSpace;
declare const entities$3_NegativeVeryThinSpace: typeof NegativeVeryThinSpace;
declare const entities$3_nequiv: typeof nequiv;
declare const entities$3_nesear: typeof nesear;
declare const entities$3_nesim: typeof nesim;
declare const entities$3_NestedGreaterGreater: typeof NestedGreaterGreater;
declare const entities$3_NestedLessLess: typeof NestedLessLess;
declare const entities$3_NewLine: typeof NewLine;
declare const entities$3_nexist: typeof nexist;
declare const entities$3_nexists: typeof nexists;
declare const entities$3_Nfr: typeof Nfr;
declare const entities$3_nfr: typeof nfr;
declare const entities$3_ngE: typeof ngE;
declare const entities$3_nge: typeof nge;
declare const entities$3_ngeq: typeof ngeq;
declare const entities$3_ngeqq: typeof ngeqq;
declare const entities$3_ngeqslant: typeof ngeqslant;
declare const entities$3_nges: typeof nges;
declare const entities$3_nGg: typeof nGg;
declare const entities$3_ngsim: typeof ngsim;
declare const entities$3_nGt: typeof nGt;
declare const entities$3_ngt: typeof ngt;
declare const entities$3_ngtr: typeof ngtr;
declare const entities$3_nGtv: typeof nGtv;
declare const entities$3_nharr: typeof nharr;
declare const entities$3_nhArr: typeof nhArr;
declare const entities$3_nhpar: typeof nhpar;
declare const entities$3_ni: typeof ni;
declare const entities$3_nis: typeof nis;
declare const entities$3_nisd: typeof nisd;
declare const entities$3_niv: typeof niv;
declare const entities$3_NJcy: typeof NJcy;
declare const entities$3_njcy: typeof njcy;
declare const entities$3_nlarr: typeof nlarr;
declare const entities$3_nlArr: typeof nlArr;
declare const entities$3_nldr: typeof nldr;
declare const entities$3_nlE: typeof nlE;
declare const entities$3_nle: typeof nle;
declare const entities$3_nleftarrow: typeof nleftarrow;
declare const entities$3_nLeftarrow: typeof nLeftarrow;
declare const entities$3_nleftrightarrow: typeof nleftrightarrow;
declare const entities$3_nLeftrightarrow: typeof nLeftrightarrow;
declare const entities$3_nleq: typeof nleq;
declare const entities$3_nleqq: typeof nleqq;
declare const entities$3_nleqslant: typeof nleqslant;
declare const entities$3_nles: typeof nles;
declare const entities$3_nless: typeof nless;
declare const entities$3_nLl: typeof nLl;
declare const entities$3_nlsim: typeof nlsim;
declare const entities$3_nLt: typeof nLt;
declare const entities$3_nlt: typeof nlt;
declare const entities$3_nltri: typeof nltri;
declare const entities$3_nltrie: typeof nltrie;
declare const entities$3_nLtv: typeof nLtv;
declare const entities$3_nmid: typeof nmid;
declare const entities$3_NoBreak: typeof NoBreak;
declare const entities$3_NonBreakingSpace: typeof NonBreakingSpace;
declare const entities$3_nopf: typeof nopf;
declare const entities$3_Nopf: typeof Nopf;
declare const entities$3_Not: typeof Not;
declare const entities$3_not: typeof not;
declare const entities$3_NotCongruent: typeof NotCongruent;
declare const entities$3_NotCupCap: typeof NotCupCap;
declare const entities$3_NotDoubleVerticalBar: typeof NotDoubleVerticalBar;
declare const entities$3_NotElement: typeof NotElement;
declare const entities$3_NotEqual: typeof NotEqual;
declare const entities$3_NotEqualTilde: typeof NotEqualTilde;
declare const entities$3_NotExists: typeof NotExists;
declare const entities$3_NotGreater: typeof NotGreater;
declare const entities$3_NotGreaterEqual: typeof NotGreaterEqual;
declare const entities$3_NotGreaterFullEqual: typeof NotGreaterFullEqual;
declare const entities$3_NotGreaterGreater: typeof NotGreaterGreater;
declare const entities$3_NotGreaterLess: typeof NotGreaterLess;
declare const entities$3_NotGreaterSlantEqual: typeof NotGreaterSlantEqual;
declare const entities$3_NotGreaterTilde: typeof NotGreaterTilde;
declare const entities$3_NotHumpDownHump: typeof NotHumpDownHump;
declare const entities$3_NotHumpEqual: typeof NotHumpEqual;
declare const entities$3_notin: typeof notin;
declare const entities$3_notindot: typeof notindot;
declare const entities$3_notinE: typeof notinE;
declare const entities$3_notinva: typeof notinva;
declare const entities$3_notinvb: typeof notinvb;
declare const entities$3_notinvc: typeof notinvc;
declare const entities$3_NotLeftTriangleBar: typeof NotLeftTriangleBar;
declare const entities$3_NotLeftTriangle: typeof NotLeftTriangle;
declare const entities$3_NotLeftTriangleEqual: typeof NotLeftTriangleEqual;
declare const entities$3_NotLess: typeof NotLess;
declare const entities$3_NotLessEqual: typeof NotLessEqual;
declare const entities$3_NotLessGreater: typeof NotLessGreater;
declare const entities$3_NotLessLess: typeof NotLessLess;
declare const entities$3_NotLessSlantEqual: typeof NotLessSlantEqual;
declare const entities$3_NotLessTilde: typeof NotLessTilde;
declare const entities$3_NotNestedGreaterGreater: typeof NotNestedGreaterGreater;
declare const entities$3_NotNestedLessLess: typeof NotNestedLessLess;
declare const entities$3_notni: typeof notni;
declare const entities$3_notniva: typeof notniva;
declare const entities$3_notnivb: typeof notnivb;
declare const entities$3_notnivc: typeof notnivc;
declare const entities$3_NotPrecedes: typeof NotPrecedes;
declare const entities$3_NotPrecedesEqual: typeof NotPrecedesEqual;
declare const entities$3_NotPrecedesSlantEqual: typeof NotPrecedesSlantEqual;
declare const entities$3_NotReverseElement: typeof NotReverseElement;
declare const entities$3_NotRightTriangleBar: typeof NotRightTriangleBar;
declare const entities$3_NotRightTriangle: typeof NotRightTriangle;
declare const entities$3_NotRightTriangleEqual: typeof NotRightTriangleEqual;
declare const entities$3_NotSquareSubset: typeof NotSquareSubset;
declare const entities$3_NotSquareSubsetEqual: typeof NotSquareSubsetEqual;
declare const entities$3_NotSquareSuperset: typeof NotSquareSuperset;
declare const entities$3_NotSquareSupersetEqual: typeof NotSquareSupersetEqual;
declare const entities$3_NotSubset: typeof NotSubset;
declare const entities$3_NotSubsetEqual: typeof NotSubsetEqual;
declare const entities$3_NotSucceeds: typeof NotSucceeds;
declare const entities$3_NotSucceedsEqual: typeof NotSucceedsEqual;
declare const entities$3_NotSucceedsSlantEqual: typeof NotSucceedsSlantEqual;
declare const entities$3_NotSucceedsTilde: typeof NotSucceedsTilde;
declare const entities$3_NotSuperset: typeof NotSuperset;
declare const entities$3_NotSupersetEqual: typeof NotSupersetEqual;
declare const entities$3_NotTilde: typeof NotTilde;
declare const entities$3_NotTildeEqual: typeof NotTildeEqual;
declare const entities$3_NotTildeFullEqual: typeof NotTildeFullEqual;
declare const entities$3_NotTildeTilde: typeof NotTildeTilde;
declare const entities$3_NotVerticalBar: typeof NotVerticalBar;
declare const entities$3_nparallel: typeof nparallel;
declare const entities$3_npar: typeof npar;
declare const entities$3_nparsl: typeof nparsl;
declare const entities$3_npart: typeof npart;
declare const entities$3_npolint: typeof npolint;
declare const entities$3_npr: typeof npr;
declare const entities$3_nprcue: typeof nprcue;
declare const entities$3_nprec: typeof nprec;
declare const entities$3_npreceq: typeof npreceq;
declare const entities$3_npre: typeof npre;
declare const entities$3_nrarrc: typeof nrarrc;
declare const entities$3_nrarr: typeof nrarr;
declare const entities$3_nrArr: typeof nrArr;
declare const entities$3_nrarrw: typeof nrarrw;
declare const entities$3_nrightarrow: typeof nrightarrow;
declare const entities$3_nRightarrow: typeof nRightarrow;
declare const entities$3_nrtri: typeof nrtri;
declare const entities$3_nrtrie: typeof nrtrie;
declare const entities$3_nsc: typeof nsc;
declare const entities$3_nsccue: typeof nsccue;
declare const entities$3_nsce: typeof nsce;
declare const entities$3_Nscr: typeof Nscr;
declare const entities$3_nscr: typeof nscr;
declare const entities$3_nshortmid: typeof nshortmid;
declare const entities$3_nshortparallel: typeof nshortparallel;
declare const entities$3_nsim: typeof nsim;
declare const entities$3_nsime: typeof nsime;
declare const entities$3_nsimeq: typeof nsimeq;
declare const entities$3_nsmid: typeof nsmid;
declare const entities$3_nspar: typeof nspar;
declare const entities$3_nsqsube: typeof nsqsube;
declare const entities$3_nsqsupe: typeof nsqsupe;
declare const entities$3_nsub: typeof nsub;
declare const entities$3_nsubE: typeof nsubE;
declare const entities$3_nsube: typeof nsube;
declare const entities$3_nsubset: typeof nsubset;
declare const entities$3_nsubseteq: typeof nsubseteq;
declare const entities$3_nsubseteqq: typeof nsubseteqq;
declare const entities$3_nsucc: typeof nsucc;
declare const entities$3_nsucceq: typeof nsucceq;
declare const entities$3_nsup: typeof nsup;
declare const entities$3_nsupE: typeof nsupE;
declare const entities$3_nsupe: typeof nsupe;
declare const entities$3_nsupset: typeof nsupset;
declare const entities$3_nsupseteq: typeof nsupseteq;
declare const entities$3_nsupseteqq: typeof nsupseteqq;
declare const entities$3_ntgl: typeof ntgl;
declare const entities$3_Ntilde: typeof Ntilde;
declare const entities$3_ntilde: typeof ntilde;
declare const entities$3_ntlg: typeof ntlg;
declare const entities$3_ntriangleleft: typeof ntriangleleft;
declare const entities$3_ntrianglelefteq: typeof ntrianglelefteq;
declare const entities$3_ntriangleright: typeof ntriangleright;
declare const entities$3_ntrianglerighteq: typeof ntrianglerighteq;
declare const entities$3_Nu: typeof Nu;
declare const entities$3_nu: typeof nu;
declare const entities$3_num: typeof num;
declare const entities$3_numero: typeof numero;
declare const entities$3_numsp: typeof numsp;
declare const entities$3_nvap: typeof nvap;
declare const entities$3_nvdash: typeof nvdash;
declare const entities$3_nvDash: typeof nvDash;
declare const entities$3_nVdash: typeof nVdash;
declare const entities$3_nVDash: typeof nVDash;
declare const entities$3_nvge: typeof nvge;
declare const entities$3_nvgt: typeof nvgt;
declare const entities$3_nvHarr: typeof nvHarr;
declare const entities$3_nvinfin: typeof nvinfin;
declare const entities$3_nvlArr: typeof nvlArr;
declare const entities$3_nvle: typeof nvle;
declare const entities$3_nvlt: typeof nvlt;
declare const entities$3_nvltrie: typeof nvltrie;
declare const entities$3_nvrArr: typeof nvrArr;
declare const entities$3_nvrtrie: typeof nvrtrie;
declare const entities$3_nvsim: typeof nvsim;
declare const entities$3_nwarhk: typeof nwarhk;
declare const entities$3_nwarr: typeof nwarr;
declare const entities$3_nwArr: typeof nwArr;
declare const entities$3_nwarrow: typeof nwarrow;
declare const entities$3_nwnear: typeof nwnear;
declare const entities$3_Oacute: typeof Oacute;
declare const entities$3_oacute: typeof oacute;
declare const entities$3_oast: typeof oast;
declare const entities$3_Ocirc: typeof Ocirc;
declare const entities$3_ocirc: typeof ocirc;
declare const entities$3_ocir: typeof ocir;
declare const entities$3_Ocy: typeof Ocy;
declare const entities$3_ocy: typeof ocy;
declare const entities$3_odash: typeof odash;
declare const entities$3_Odblac: typeof Odblac;
declare const entities$3_odblac: typeof odblac;
declare const entities$3_odiv: typeof odiv;
declare const entities$3_odot: typeof odot;
declare const entities$3_odsold: typeof odsold;
declare const entities$3_OElig: typeof OElig;
declare const entities$3_oelig: typeof oelig;
declare const entities$3_ofcir: typeof ofcir;
declare const entities$3_Ofr: typeof Ofr;
declare const entities$3_ofr: typeof ofr;
declare const entities$3_ogon: typeof ogon;
declare const entities$3_Ograve: typeof Ograve;
declare const entities$3_ograve: typeof ograve;
declare const entities$3_ogt: typeof ogt;
declare const entities$3_ohbar: typeof ohbar;
declare const entities$3_ohm: typeof ohm;
declare const entities$3_oint: typeof oint;
declare const entities$3_olarr: typeof olarr;
declare const entities$3_olcir: typeof olcir;
declare const entities$3_olcross: typeof olcross;
declare const entities$3_oline: typeof oline;
declare const entities$3_olt: typeof olt;
declare const entities$3_Omacr: typeof Omacr;
declare const entities$3_omacr: typeof omacr;
declare const entities$3_Omega: typeof Omega;
declare const entities$3_omega: typeof omega;
declare const entities$3_Omicron: typeof Omicron;
declare const entities$3_omicron: typeof omicron;
declare const entities$3_omid: typeof omid;
declare const entities$3_ominus: typeof ominus;
declare const entities$3_Oopf: typeof Oopf;
declare const entities$3_oopf: typeof oopf;
declare const entities$3_opar: typeof opar;
declare const entities$3_OpenCurlyDoubleQuote: typeof OpenCurlyDoubleQuote;
declare const entities$3_OpenCurlyQuote: typeof OpenCurlyQuote;
declare const entities$3_operp: typeof operp;
declare const entities$3_oplus: typeof oplus;
declare const entities$3_orarr: typeof orarr;
declare const entities$3_Or: typeof Or;
declare const entities$3_or: typeof or;
declare const entities$3_ord: typeof ord;
declare const entities$3_order: typeof order;
declare const entities$3_orderof: typeof orderof;
declare const entities$3_ordf: typeof ordf;
declare const entities$3_ordm: typeof ordm;
declare const entities$3_origof: typeof origof;
declare const entities$3_oror: typeof oror;
declare const entities$3_orslope: typeof orslope;
declare const entities$3_orv: typeof orv;
declare const entities$3_oS: typeof oS;
declare const entities$3_Oscr: typeof Oscr;
declare const entities$3_oscr: typeof oscr;
declare const entities$3_Oslash: typeof Oslash;
declare const entities$3_oslash: typeof oslash;
declare const entities$3_osol: typeof osol;
declare const entities$3_Otilde: typeof Otilde;
declare const entities$3_otilde: typeof otilde;
declare const entities$3_otimesas: typeof otimesas;
declare const entities$3_Otimes: typeof Otimes;
declare const entities$3_otimes: typeof otimes;
declare const entities$3_Ouml: typeof Ouml;
declare const entities$3_ouml: typeof ouml;
declare const entities$3_ovbar: typeof ovbar;
declare const entities$3_OverBar: typeof OverBar;
declare const entities$3_OverBrace: typeof OverBrace;
declare const entities$3_OverBracket: typeof OverBracket;
declare const entities$3_OverParenthesis: typeof OverParenthesis;
declare const entities$3_para: typeof para;
declare const entities$3_parallel: typeof parallel;
declare const entities$3_par: typeof par;
declare const entities$3_parsim: typeof parsim;
declare const entities$3_parsl: typeof parsl;
declare const entities$3_part: typeof part;
declare const entities$3_PartialD: typeof PartialD;
declare const entities$3_Pcy: typeof Pcy;
declare const entities$3_pcy: typeof pcy;
declare const entities$3_percnt: typeof percnt;
declare const entities$3_period: typeof period;
declare const entities$3_permil: typeof permil;
declare const entities$3_perp: typeof perp;
declare const entities$3_pertenk: typeof pertenk;
declare const entities$3_Pfr: typeof Pfr;
declare const entities$3_pfr: typeof pfr;
declare const entities$3_Phi: typeof Phi;
declare const entities$3_phi: typeof phi;
declare const entities$3_phiv: typeof phiv;
declare const entities$3_phmmat: typeof phmmat;
declare const entities$3_phone: typeof phone;
declare const entities$3_Pi: typeof Pi;
declare const entities$3_pi: typeof pi;
declare const entities$3_pitchfork: typeof pitchfork;
declare const entities$3_piv: typeof piv;
declare const entities$3_planck: typeof planck;
declare const entities$3_planckh: typeof planckh;
declare const entities$3_plankv: typeof plankv;
declare const entities$3_plusacir: typeof plusacir;
declare const entities$3_plusb: typeof plusb;
declare const entities$3_pluscir: typeof pluscir;
declare const entities$3_plus: typeof plus;
declare const entities$3_plusdo: typeof plusdo;
declare const entities$3_plusdu: typeof plusdu;
declare const entities$3_pluse: typeof pluse;
declare const entities$3_PlusMinus: typeof PlusMinus;
declare const entities$3_plusmn: typeof plusmn;
declare const entities$3_plussim: typeof plussim;
declare const entities$3_plustwo: typeof plustwo;
declare const entities$3_pm: typeof pm;
declare const entities$3_Poincareplane: typeof Poincareplane;
declare const entities$3_pointint: typeof pointint;
declare const entities$3_popf: typeof popf;
declare const entities$3_Popf: typeof Popf;
declare const entities$3_pound: typeof pound;
declare const entities$3_prap: typeof prap;
declare const entities$3_Pr: typeof Pr;
declare const entities$3_pr: typeof pr;
declare const entities$3_prcue: typeof prcue;
declare const entities$3_precapprox: typeof precapprox;
declare const entities$3_prec: typeof prec;
declare const entities$3_preccurlyeq: typeof preccurlyeq;
declare const entities$3_Precedes: typeof Precedes;
declare const entities$3_PrecedesEqual: typeof PrecedesEqual;
declare const entities$3_PrecedesSlantEqual: typeof PrecedesSlantEqual;
declare const entities$3_PrecedesTilde: typeof PrecedesTilde;
declare const entities$3_preceq: typeof preceq;
declare const entities$3_precnapprox: typeof precnapprox;
declare const entities$3_precneqq: typeof precneqq;
declare const entities$3_precnsim: typeof precnsim;
declare const entities$3_pre: typeof pre;
declare const entities$3_prE: typeof prE;
declare const entities$3_precsim: typeof precsim;
declare const entities$3_prime: typeof prime;
declare const entities$3_Prime: typeof Prime;
declare const entities$3_primes: typeof primes;
declare const entities$3_prnap: typeof prnap;
declare const entities$3_prnE: typeof prnE;
declare const entities$3_prnsim: typeof prnsim;
declare const entities$3_prod: typeof prod;
declare const entities$3_Product: typeof Product;
declare const entities$3_profalar: typeof profalar;
declare const entities$3_profline: typeof profline;
declare const entities$3_profsurf: typeof profsurf;
declare const entities$3_prop: typeof prop;
declare const entities$3_Proportional: typeof Proportional;
declare const entities$3_Proportion: typeof Proportion;
declare const entities$3_propto: typeof propto;
declare const entities$3_prsim: typeof prsim;
declare const entities$3_prurel: typeof prurel;
declare const entities$3_Pscr: typeof Pscr;
declare const entities$3_pscr: typeof pscr;
declare const entities$3_Psi: typeof Psi;
declare const entities$3_psi: typeof psi;
declare const entities$3_puncsp: typeof puncsp;
declare const entities$3_Qfr: typeof Qfr;
declare const entities$3_qfr: typeof qfr;
declare const entities$3_qint: typeof qint;
declare const entities$3_qopf: typeof qopf;
declare const entities$3_Qopf: typeof Qopf;
declare const entities$3_qprime: typeof qprime;
declare const entities$3_Qscr: typeof Qscr;
declare const entities$3_qscr: typeof qscr;
declare const entities$3_quaternions: typeof quaternions;
declare const entities$3_quatint: typeof quatint;
declare const entities$3_quest: typeof quest;
declare const entities$3_questeq: typeof questeq;
declare const entities$3_quot: typeof quot;
declare const entities$3_QUOT: typeof QUOT;
declare const entities$3_rAarr: typeof rAarr;
declare const entities$3_race: typeof race;
declare const entities$3_Racute: typeof Racute;
declare const entities$3_racute: typeof racute;
declare const entities$3_radic: typeof radic;
declare const entities$3_raemptyv: typeof raemptyv;
declare const entities$3_rang: typeof rang;
declare const entities$3_Rang: typeof Rang;
declare const entities$3_rangd: typeof rangd;
declare const entities$3_range: typeof range;
declare const entities$3_rangle: typeof rangle;
declare const entities$3_raquo: typeof raquo;
declare const entities$3_rarrap: typeof rarrap;
declare const entities$3_rarrb: typeof rarrb;
declare const entities$3_rarrbfs: typeof rarrbfs;
declare const entities$3_rarrc: typeof rarrc;
declare const entities$3_rarr: typeof rarr;
declare const entities$3_Rarr: typeof Rarr;
declare const entities$3_rArr: typeof rArr;
declare const entities$3_rarrfs: typeof rarrfs;
declare const entities$3_rarrhk: typeof rarrhk;
declare const entities$3_rarrlp: typeof rarrlp;
declare const entities$3_rarrpl: typeof rarrpl;
declare const entities$3_rarrsim: typeof rarrsim;
declare const entities$3_Rarrtl: typeof Rarrtl;
declare const entities$3_rarrtl: typeof rarrtl;
declare const entities$3_rarrw: typeof rarrw;
declare const entities$3_ratail: typeof ratail;
declare const entities$3_rAtail: typeof rAtail;
declare const entities$3_ratio: typeof ratio;
declare const entities$3_rationals: typeof rationals;
declare const entities$3_rbarr: typeof rbarr;
declare const entities$3_rBarr: typeof rBarr;
declare const entities$3_RBarr: typeof RBarr;
declare const entities$3_rbbrk: typeof rbbrk;
declare const entities$3_rbrace: typeof rbrace;
declare const entities$3_rbrack: typeof rbrack;
declare const entities$3_rbrke: typeof rbrke;
declare const entities$3_rbrksld: typeof rbrksld;
declare const entities$3_rbrkslu: typeof rbrkslu;
declare const entities$3_Rcaron: typeof Rcaron;
declare const entities$3_rcaron: typeof rcaron;
declare const entities$3_Rcedil: typeof Rcedil;
declare const entities$3_rcedil: typeof rcedil;
declare const entities$3_rceil: typeof rceil;
declare const entities$3_rcub: typeof rcub;
declare const entities$3_Rcy: typeof Rcy;
declare const entities$3_rcy: typeof rcy;
declare const entities$3_rdca: typeof rdca;
declare const entities$3_rdldhar: typeof rdldhar;
declare const entities$3_rdquo: typeof rdquo;
declare const entities$3_rdquor: typeof rdquor;
declare const entities$3_rdsh: typeof rdsh;
declare const entities$3_real: typeof real;
declare const entities$3_realine: typeof realine;
declare const entities$3_realpart: typeof realpart;
declare const entities$3_reals: typeof reals;
declare const entities$3_Re: typeof Re;
declare const entities$3_rect: typeof rect;
declare const entities$3_reg: typeof reg;
declare const entities$3_REG: typeof REG;
declare const entities$3_ReverseElement: typeof ReverseElement;
declare const entities$3_ReverseEquilibrium: typeof ReverseEquilibrium;
declare const entities$3_ReverseUpEquilibrium: typeof ReverseUpEquilibrium;
declare const entities$3_rfisht: typeof rfisht;
declare const entities$3_rfloor: typeof rfloor;
declare const entities$3_rfr: typeof rfr;
declare const entities$3_Rfr: typeof Rfr;
declare const entities$3_rHar: typeof rHar;
declare const entities$3_rhard: typeof rhard;
declare const entities$3_rharu: typeof rharu;
declare const entities$3_rharul: typeof rharul;
declare const entities$3_Rho: typeof Rho;
declare const entities$3_rho: typeof rho;
declare const entities$3_rhov: typeof rhov;
declare const entities$3_RightAngleBracket: typeof RightAngleBracket;
declare const entities$3_RightArrowBar: typeof RightArrowBar;
declare const entities$3_rightarrow: typeof rightarrow;
declare const entities$3_RightArrow: typeof RightArrow;
declare const entities$3_Rightarrow: typeof Rightarrow;
declare const entities$3_RightArrowLeftArrow: typeof RightArrowLeftArrow;
declare const entities$3_rightarrowtail: typeof rightarrowtail;
declare const entities$3_RightCeiling: typeof RightCeiling;
declare const entities$3_RightDoubleBracket: typeof RightDoubleBracket;
declare const entities$3_RightDownTeeVector: typeof RightDownTeeVector;
declare const entities$3_RightDownVectorBar: typeof RightDownVectorBar;
declare const entities$3_RightDownVector: typeof RightDownVector;
declare const entities$3_RightFloor: typeof RightFloor;
declare const entities$3_rightharpoondown: typeof rightharpoondown;
declare const entities$3_rightharpoonup: typeof rightharpoonup;
declare const entities$3_rightleftarrows: typeof rightleftarrows;
declare const entities$3_rightleftharpoons: typeof rightleftharpoons;
declare const entities$3_rightrightarrows: typeof rightrightarrows;
declare const entities$3_rightsquigarrow: typeof rightsquigarrow;
declare const entities$3_RightTeeArrow: typeof RightTeeArrow;
declare const entities$3_RightTee: typeof RightTee;
declare const entities$3_RightTeeVector: typeof RightTeeVector;
declare const entities$3_rightthreetimes: typeof rightthreetimes;
declare const entities$3_RightTriangleBar: typeof RightTriangleBar;
declare const entities$3_RightTriangle: typeof RightTriangle;
declare const entities$3_RightTriangleEqual: typeof RightTriangleEqual;
declare const entities$3_RightUpDownVector: typeof RightUpDownVector;
declare const entities$3_RightUpTeeVector: typeof RightUpTeeVector;
declare const entities$3_RightUpVectorBar: typeof RightUpVectorBar;
declare const entities$3_RightUpVector: typeof RightUpVector;
declare const entities$3_RightVectorBar: typeof RightVectorBar;
declare const entities$3_RightVector: typeof RightVector;
declare const entities$3_ring: typeof ring;
declare const entities$3_risingdotseq: typeof risingdotseq;
declare const entities$3_rlarr: typeof rlarr;
declare const entities$3_rlhar: typeof rlhar;
declare const entities$3_rlm: typeof rlm;
declare const entities$3_rmoustache: typeof rmoustache;
declare const entities$3_rmoust: typeof rmoust;
declare const entities$3_rnmid: typeof rnmid;
declare const entities$3_roang: typeof roang;
declare const entities$3_roarr: typeof roarr;
declare const entities$3_robrk: typeof robrk;
declare const entities$3_ropar: typeof ropar;
declare const entities$3_ropf: typeof ropf;
declare const entities$3_Ropf: typeof Ropf;
declare const entities$3_roplus: typeof roplus;
declare const entities$3_rotimes: typeof rotimes;
declare const entities$3_RoundImplies: typeof RoundImplies;
declare const entities$3_rpar: typeof rpar;
declare const entities$3_rpargt: typeof rpargt;
declare const entities$3_rppolint: typeof rppolint;
declare const entities$3_rrarr: typeof rrarr;
declare const entities$3_Rrightarrow: typeof Rrightarrow;
declare const entities$3_rsaquo: typeof rsaquo;
declare const entities$3_rscr: typeof rscr;
declare const entities$3_Rscr: typeof Rscr;
declare const entities$3_rsh: typeof rsh;
declare const entities$3_Rsh: typeof Rsh;
declare const entities$3_rsqb: typeof rsqb;
declare const entities$3_rsquo: typeof rsquo;
declare const entities$3_rsquor: typeof rsquor;
declare const entities$3_rthree: typeof rthree;
declare const entities$3_rtimes: typeof rtimes;
declare const entities$3_rtri: typeof rtri;
declare const entities$3_rtrie: typeof rtrie;
declare const entities$3_rtrif: typeof rtrif;
declare const entities$3_rtriltri: typeof rtriltri;
declare const entities$3_RuleDelayed: typeof RuleDelayed;
declare const entities$3_ruluhar: typeof ruluhar;
declare const entities$3_rx: typeof rx;
declare const entities$3_Sacute: typeof Sacute;
declare const entities$3_sacute: typeof sacute;
declare const entities$3_sbquo: typeof sbquo;
declare const entities$3_scap: typeof scap;
declare const entities$3_Scaron: typeof Scaron;
declare const entities$3_scaron: typeof scaron;
declare const entities$3_Sc: typeof Sc;
declare const entities$3_sc: typeof sc;
declare const entities$3_sccue: typeof sccue;
declare const entities$3_sce: typeof sce;
declare const entities$3_scE: typeof scE;
declare const entities$3_Scedil: typeof Scedil;
declare const entities$3_scedil: typeof scedil;
declare const entities$3_Scirc: typeof Scirc;
declare const entities$3_scirc: typeof scirc;
declare const entities$3_scnap: typeof scnap;
declare const entities$3_scnE: typeof scnE;
declare const entities$3_scnsim: typeof scnsim;
declare const entities$3_scpolint: typeof scpolint;
declare const entities$3_scsim: typeof scsim;
declare const entities$3_Scy: typeof Scy;
declare const entities$3_scy: typeof scy;
declare const entities$3_sdotb: typeof sdotb;
declare const entities$3_sdot: typeof sdot;
declare const entities$3_sdote: typeof sdote;
declare const entities$3_searhk: typeof searhk;
declare const entities$3_searr: typeof searr;
declare const entities$3_seArr: typeof seArr;
declare const entities$3_searrow: typeof searrow;
declare const entities$3_sect: typeof sect;
declare const entities$3_semi: typeof semi;
declare const entities$3_seswar: typeof seswar;
declare const entities$3_setminus: typeof setminus;
declare const entities$3_setmn: typeof setmn;
declare const entities$3_sext: typeof sext;
declare const entities$3_Sfr: typeof Sfr;
declare const entities$3_sfr: typeof sfr;
declare const entities$3_sfrown: typeof sfrown;
declare const entities$3_sharp: typeof sharp;
declare const entities$3_SHCHcy: typeof SHCHcy;
declare const entities$3_shchcy: typeof shchcy;
declare const entities$3_SHcy: typeof SHcy;
declare const entities$3_shcy: typeof shcy;
declare const entities$3_ShortDownArrow: typeof ShortDownArrow;
declare const entities$3_ShortLeftArrow: typeof ShortLeftArrow;
declare const entities$3_shortmid: typeof shortmid;
declare const entities$3_shortparallel: typeof shortparallel;
declare const entities$3_ShortRightArrow: typeof ShortRightArrow;
declare const entities$3_ShortUpArrow: typeof ShortUpArrow;
declare const entities$3_shy: typeof shy;
declare const entities$3_Sigma: typeof Sigma;
declare const entities$3_sigma: typeof sigma;
declare const entities$3_sigmaf: typeof sigmaf;
declare const entities$3_sigmav: typeof sigmav;
declare const entities$3_sim: typeof sim;
declare const entities$3_simdot: typeof simdot;
declare const entities$3_sime: typeof sime;
declare const entities$3_simeq: typeof simeq;
declare const entities$3_simg: typeof simg;
declare const entities$3_simgE: typeof simgE;
declare const entities$3_siml: typeof siml;
declare const entities$3_simlE: typeof simlE;
declare const entities$3_simne: typeof simne;
declare const entities$3_simplus: typeof simplus;
declare const entities$3_simrarr: typeof simrarr;
declare const entities$3_slarr: typeof slarr;
declare const entities$3_SmallCircle: typeof SmallCircle;
declare const entities$3_smallsetminus: typeof smallsetminus;
declare const entities$3_smashp: typeof smashp;
declare const entities$3_smeparsl: typeof smeparsl;
declare const entities$3_smid: typeof smid;
declare const entities$3_smile: typeof smile;
declare const entities$3_smt: typeof smt;
declare const entities$3_smte: typeof smte;
declare const entities$3_smtes: typeof smtes;
declare const entities$3_SOFTcy: typeof SOFTcy;
declare const entities$3_softcy: typeof softcy;
declare const entities$3_solbar: typeof solbar;
declare const entities$3_solb: typeof solb;
declare const entities$3_sol: typeof sol;
declare const entities$3_Sopf: typeof Sopf;
declare const entities$3_sopf: typeof sopf;
declare const entities$3_spades: typeof spades;
declare const entities$3_spadesuit: typeof spadesuit;
declare const entities$3_spar: typeof spar;
declare const entities$3_sqcap: typeof sqcap;
declare const entities$3_sqcaps: typeof sqcaps;
declare const entities$3_sqcup: typeof sqcup;
declare const entities$3_sqcups: typeof sqcups;
declare const entities$3_Sqrt: typeof Sqrt;
declare const entities$3_sqsub: typeof sqsub;
declare const entities$3_sqsube: typeof sqsube;
declare const entities$3_sqsubset: typeof sqsubset;
declare const entities$3_sqsubseteq: typeof sqsubseteq;
declare const entities$3_sqsup: typeof sqsup;
declare const entities$3_sqsupe: typeof sqsupe;
declare const entities$3_sqsupset: typeof sqsupset;
declare const entities$3_sqsupseteq: typeof sqsupseteq;
declare const entities$3_square: typeof square;
declare const entities$3_Square: typeof Square;
declare const entities$3_SquareIntersection: typeof SquareIntersection;
declare const entities$3_SquareSubset: typeof SquareSubset;
declare const entities$3_SquareSubsetEqual: typeof SquareSubsetEqual;
declare const entities$3_SquareSuperset: typeof SquareSuperset;
declare const entities$3_SquareSupersetEqual: typeof SquareSupersetEqual;
declare const entities$3_SquareUnion: typeof SquareUnion;
declare const entities$3_squarf: typeof squarf;
declare const entities$3_squ: typeof squ;
declare const entities$3_squf: typeof squf;
declare const entities$3_srarr: typeof srarr;
declare const entities$3_Sscr: typeof Sscr;
declare const entities$3_sscr: typeof sscr;
declare const entities$3_ssetmn: typeof ssetmn;
declare const entities$3_ssmile: typeof ssmile;
declare const entities$3_sstarf: typeof sstarf;
declare const entities$3_Star: typeof Star;
declare const entities$3_star: typeof star;
declare const entities$3_starf: typeof starf;
declare const entities$3_straightepsilon: typeof straightepsilon;
declare const entities$3_straightphi: typeof straightphi;
declare const entities$3_strns: typeof strns;
declare const entities$3_sub: typeof sub;
declare const entities$3_Sub: typeof Sub;
declare const entities$3_subdot: typeof subdot;
declare const entities$3_subE: typeof subE;
declare const entities$3_sube: typeof sube;
declare const entities$3_subedot: typeof subedot;
declare const entities$3_submult: typeof submult;
declare const entities$3_subnE: typeof subnE;
declare const entities$3_subne: typeof subne;
declare const entities$3_subplus: typeof subplus;
declare const entities$3_subrarr: typeof subrarr;
declare const entities$3_subset: typeof subset;
declare const entities$3_Subset: typeof Subset;
declare const entities$3_subseteq: typeof subseteq;
declare const entities$3_subseteqq: typeof subseteqq;
declare const entities$3_SubsetEqual: typeof SubsetEqual;
declare const entities$3_subsetneq: typeof subsetneq;
declare const entities$3_subsetneqq: typeof subsetneqq;
declare const entities$3_subsim: typeof subsim;
declare const entities$3_subsub: typeof subsub;
declare const entities$3_subsup: typeof subsup;
declare const entities$3_succapprox: typeof succapprox;
declare const entities$3_succ: typeof succ;
declare const entities$3_succcurlyeq: typeof succcurlyeq;
declare const entities$3_Succeeds: typeof Succeeds;
declare const entities$3_SucceedsEqual: typeof SucceedsEqual;
declare const entities$3_SucceedsSlantEqual: typeof SucceedsSlantEqual;
declare const entities$3_SucceedsTilde: typeof SucceedsTilde;
declare const entities$3_succeq: typeof succeq;
declare const entities$3_succnapprox: typeof succnapprox;
declare const entities$3_succneqq: typeof succneqq;
declare const entities$3_succnsim: typeof succnsim;
declare const entities$3_succsim: typeof succsim;
declare const entities$3_SuchThat: typeof SuchThat;
declare const entities$3_sum: typeof sum;
declare const entities$3_Sum: typeof Sum;
declare const entities$3_sung: typeof sung;
declare const entities$3_sup1: typeof sup1;
declare const entities$3_sup2: typeof sup2;
declare const entities$3_sup3: typeof sup3;
declare const entities$3_sup: typeof sup;
declare const entities$3_Sup: typeof Sup;
declare const entities$3_supdot: typeof supdot;
declare const entities$3_supdsub: typeof supdsub;
declare const entities$3_supE: typeof supE;
declare const entities$3_supe: typeof supe;
declare const entities$3_supedot: typeof supedot;
declare const entities$3_Superset: typeof Superset;
declare const entities$3_SupersetEqual: typeof SupersetEqual;
declare const entities$3_suphsol: typeof suphsol;
declare const entities$3_suphsub: typeof suphsub;
declare const entities$3_suplarr: typeof suplarr;
declare const entities$3_supmult: typeof supmult;
declare const entities$3_supnE: typeof supnE;
declare const entities$3_supne: typeof supne;
declare const entities$3_supplus: typeof supplus;
declare const entities$3_supset: typeof supset;
declare const entities$3_Supset: typeof Supset;
declare const entities$3_supseteq: typeof supseteq;
declare const entities$3_supseteqq: typeof supseteqq;
declare const entities$3_supsetneq: typeof supsetneq;
declare const entities$3_supsetneqq: typeof supsetneqq;
declare const entities$3_supsim: typeof supsim;
declare const entities$3_supsub: typeof supsub;
declare const entities$3_supsup: typeof supsup;
declare const entities$3_swarhk: typeof swarhk;
declare const entities$3_swarr: typeof swarr;
declare const entities$3_swArr: typeof swArr;
declare const entities$3_swarrow: typeof swarrow;
declare const entities$3_swnwar: typeof swnwar;
declare const entities$3_szlig: typeof szlig;
declare const entities$3_Tab: typeof Tab;
declare const entities$3_target: typeof target;
declare const entities$3_Tau: typeof Tau;
declare const entities$3_tau: typeof tau;
declare const entities$3_tbrk: typeof tbrk;
declare const entities$3_Tcaron: typeof Tcaron;
declare const entities$3_tcaron: typeof tcaron;
declare const entities$3_Tcedil: typeof Tcedil;
declare const entities$3_tcedil: typeof tcedil;
declare const entities$3_Tcy: typeof Tcy;
declare const entities$3_tcy: typeof tcy;
declare const entities$3_tdot: typeof tdot;
declare const entities$3_telrec: typeof telrec;
declare const entities$3_Tfr: typeof Tfr;
declare const entities$3_tfr: typeof tfr;
declare const entities$3_there4: typeof there4;
declare const entities$3_therefore: typeof therefore;
declare const entities$3_Therefore: typeof Therefore;
declare const entities$3_Theta: typeof Theta;
declare const entities$3_theta: typeof theta;
declare const entities$3_thetasym: typeof thetasym;
declare const entities$3_thetav: typeof thetav;
declare const entities$3_thickapprox: typeof thickapprox;
declare const entities$3_thicksim: typeof thicksim;
declare const entities$3_ThickSpace: typeof ThickSpace;
declare const entities$3_ThinSpace: typeof ThinSpace;
declare const entities$3_thinsp: typeof thinsp;
declare const entities$3_thkap: typeof thkap;
declare const entities$3_thksim: typeof thksim;
declare const entities$3_THORN: typeof THORN;
declare const entities$3_thorn: typeof thorn;
declare const entities$3_tilde: typeof tilde;
declare const entities$3_Tilde: typeof Tilde;
declare const entities$3_TildeEqual: typeof TildeEqual;
declare const entities$3_TildeFullEqual: typeof TildeFullEqual;
declare const entities$3_TildeTilde: typeof TildeTilde;
declare const entities$3_timesbar: typeof timesbar;
declare const entities$3_timesb: typeof timesb;
declare const entities$3_times: typeof times;
declare const entities$3_timesd: typeof timesd;
declare const entities$3_tint: typeof tint;
declare const entities$3_toea: typeof toea;
declare const entities$3_topbot: typeof topbot;
declare const entities$3_topcir: typeof topcir;
declare const entities$3_top: typeof top;
declare const entities$3_Topf: typeof Topf;
declare const entities$3_topf: typeof topf;
declare const entities$3_topfork: typeof topfork;
declare const entities$3_tosa: typeof tosa;
declare const entities$3_tprime: typeof tprime;
declare const entities$3_trade: typeof trade;
declare const entities$3_TRADE: typeof TRADE;
declare const entities$3_triangle: typeof triangle;
declare const entities$3_triangledown: typeof triangledown;
declare const entities$3_triangleleft: typeof triangleleft;
declare const entities$3_trianglelefteq: typeof trianglelefteq;
declare const entities$3_triangleq: typeof triangleq;
declare const entities$3_triangleright: typeof triangleright;
declare const entities$3_trianglerighteq: typeof trianglerighteq;
declare const entities$3_tridot: typeof tridot;
declare const entities$3_trie: typeof trie;
declare const entities$3_triminus: typeof triminus;
declare const entities$3_TripleDot: typeof TripleDot;
declare const entities$3_triplus: typeof triplus;
declare const entities$3_trisb: typeof trisb;
declare const entities$3_tritime: typeof tritime;
declare const entities$3_trpezium: typeof trpezium;
declare const entities$3_Tscr: typeof Tscr;
declare const entities$3_tscr: typeof tscr;
declare const entities$3_TScy: typeof TScy;
declare const entities$3_tscy: typeof tscy;
declare const entities$3_TSHcy: typeof TSHcy;
declare const entities$3_tshcy: typeof tshcy;
declare const entities$3_Tstrok: typeof Tstrok;
declare const entities$3_tstrok: typeof tstrok;
declare const entities$3_twixt: typeof twixt;
declare const entities$3_twoheadleftarrow: typeof twoheadleftarrow;
declare const entities$3_twoheadrightarrow: typeof twoheadrightarrow;
declare const entities$3_Uacute: typeof Uacute;
declare const entities$3_uacute: typeof uacute;
declare const entities$3_uarr: typeof uarr;
declare const entities$3_Uarr: typeof Uarr;
declare const entities$3_uArr: typeof uArr;
declare const entities$3_Uarrocir: typeof Uarrocir;
declare const entities$3_Ubrcy: typeof Ubrcy;
declare const entities$3_ubrcy: typeof ubrcy;
declare const entities$3_Ubreve: typeof Ubreve;
declare const entities$3_ubreve: typeof ubreve;
declare const entities$3_Ucirc: typeof Ucirc;
declare const entities$3_ucirc: typeof ucirc;
declare const entities$3_Ucy: typeof Ucy;
declare const entities$3_ucy: typeof ucy;
declare const entities$3_udarr: typeof udarr;
declare const entities$3_Udblac: typeof Udblac;
declare const entities$3_udblac: typeof udblac;
declare const entities$3_udhar: typeof udhar;
declare const entities$3_ufisht: typeof ufisht;
declare const entities$3_Ufr: typeof Ufr;
declare const entities$3_ufr: typeof ufr;
declare const entities$3_Ugrave: typeof Ugrave;
declare const entities$3_ugrave: typeof ugrave;
declare const entities$3_uHar: typeof uHar;
declare const entities$3_uharl: typeof uharl;
declare const entities$3_uharr: typeof uharr;
declare const entities$3_uhblk: typeof uhblk;
declare const entities$3_ulcorn: typeof ulcorn;
declare const entities$3_ulcorner: typeof ulcorner;
declare const entities$3_ulcrop: typeof ulcrop;
declare const entities$3_ultri: typeof ultri;
declare const entities$3_Umacr: typeof Umacr;
declare const entities$3_umacr: typeof umacr;
declare const entities$3_uml: typeof uml;
declare const entities$3_UnderBar: typeof UnderBar;
declare const entities$3_UnderBrace: typeof UnderBrace;
declare const entities$3_UnderBracket: typeof UnderBracket;
declare const entities$3_UnderParenthesis: typeof UnderParenthesis;
declare const entities$3_Union: typeof Union;
declare const entities$3_UnionPlus: typeof UnionPlus;
declare const entities$3_Uogon: typeof Uogon;
declare const entities$3_uogon: typeof uogon;
declare const entities$3_Uopf: typeof Uopf;
declare const entities$3_uopf: typeof uopf;
declare const entities$3_UpArrowBar: typeof UpArrowBar;
declare const entities$3_uparrow: typeof uparrow;
declare const entities$3_UpArrow: typeof UpArrow;
declare const entities$3_Uparrow: typeof Uparrow;
declare const entities$3_UpArrowDownArrow: typeof UpArrowDownArrow;
declare const entities$3_updownarrow: typeof updownarrow;
declare const entities$3_UpDownArrow: typeof UpDownArrow;
declare const entities$3_Updownarrow: typeof Updownarrow;
declare const entities$3_UpEquilibrium: typeof UpEquilibrium;
declare const entities$3_upharpoonleft: typeof upharpoonleft;
declare const entities$3_upharpoonright: typeof upharpoonright;
declare const entities$3_uplus: typeof uplus;
declare const entities$3_UpperLeftArrow: typeof UpperLeftArrow;
declare const entities$3_UpperRightArrow: typeof UpperRightArrow;
declare const entities$3_upsi: typeof upsi;
declare const entities$3_Upsi: typeof Upsi;
declare const entities$3_upsih: typeof upsih;
declare const entities$3_Upsilon: typeof Upsilon;
declare const entities$3_upsilon: typeof upsilon;
declare const entities$3_UpTeeArrow: typeof UpTeeArrow;
declare const entities$3_UpTee: typeof UpTee;
declare const entities$3_upuparrows: typeof upuparrows;
declare const entities$3_urcorn: typeof urcorn;
declare const entities$3_urcorner: typeof urcorner;
declare const entities$3_urcrop: typeof urcrop;
declare const entities$3_Uring: typeof Uring;
declare const entities$3_uring: typeof uring;
declare const entities$3_urtri: typeof urtri;
declare const entities$3_Uscr: typeof Uscr;
declare const entities$3_uscr: typeof uscr;
declare const entities$3_utdot: typeof utdot;
declare const entities$3_Utilde: typeof Utilde;
declare const entities$3_utilde: typeof utilde;
declare const entities$3_utri: typeof utri;
declare const entities$3_utrif: typeof utrif;
declare const entities$3_uuarr: typeof uuarr;
declare const entities$3_Uuml: typeof Uuml;
declare const entities$3_uuml: typeof uuml;
declare const entities$3_uwangle: typeof uwangle;
declare const entities$3_vangrt: typeof vangrt;
declare const entities$3_varepsilon: typeof varepsilon;
declare const entities$3_varkappa: typeof varkappa;
declare const entities$3_varnothing: typeof varnothing;
declare const entities$3_varphi: typeof varphi;
declare const entities$3_varpi: typeof varpi;
declare const entities$3_varpropto: typeof varpropto;
declare const entities$3_varr: typeof varr;
declare const entities$3_vArr: typeof vArr;
declare const entities$3_varrho: typeof varrho;
declare const entities$3_varsigma: typeof varsigma;
declare const entities$3_varsubsetneq: typeof varsubsetneq;
declare const entities$3_varsubsetneqq: typeof varsubsetneqq;
declare const entities$3_varsupsetneq: typeof varsupsetneq;
declare const entities$3_varsupsetneqq: typeof varsupsetneqq;
declare const entities$3_vartheta: typeof vartheta;
declare const entities$3_vartriangleleft: typeof vartriangleleft;
declare const entities$3_vartriangleright: typeof vartriangleright;
declare const entities$3_vBar: typeof vBar;
declare const entities$3_Vbar: typeof Vbar;
declare const entities$3_vBarv: typeof vBarv;
declare const entities$3_Vcy: typeof Vcy;
declare const entities$3_vcy: typeof vcy;
declare const entities$3_vdash: typeof vdash;
declare const entities$3_vDash: typeof vDash;
declare const entities$3_Vdash: typeof Vdash;
declare const entities$3_VDash: typeof VDash;
declare const entities$3_Vdashl: typeof Vdashl;
declare const entities$3_veebar: typeof veebar;
declare const entities$3_vee: typeof vee;
declare const entities$3_Vee: typeof Vee;
declare const entities$3_veeeq: typeof veeeq;
declare const entities$3_vellip: typeof vellip;
declare const entities$3_verbar: typeof verbar;
declare const entities$3_Verbar: typeof Verbar;
declare const entities$3_vert: typeof vert;
declare const entities$3_Vert: typeof Vert;
declare const entities$3_VerticalBar: typeof VerticalBar;
declare const entities$3_VerticalLine: typeof VerticalLine;
declare const entities$3_VerticalSeparator: typeof VerticalSeparator;
declare const entities$3_VerticalTilde: typeof VerticalTilde;
declare const entities$3_VeryThinSpace: typeof VeryThinSpace;
declare const entities$3_Vfr: typeof Vfr;
declare const entities$3_vfr: typeof vfr;
declare const entities$3_vltri: typeof vltri;
declare const entities$3_vnsub: typeof vnsub;
declare const entities$3_vnsup: typeof vnsup;
declare const entities$3_Vopf: typeof Vopf;
declare const entities$3_vopf: typeof vopf;
declare const entities$3_vprop: typeof vprop;
declare const entities$3_vrtri: typeof vrtri;
declare const entities$3_Vscr: typeof Vscr;
declare const entities$3_vscr: typeof vscr;
declare const entities$3_vsubnE: typeof vsubnE;
declare const entities$3_vsubne: typeof vsubne;
declare const entities$3_vsupnE: typeof vsupnE;
declare const entities$3_vsupne: typeof vsupne;
declare const entities$3_Vvdash: typeof Vvdash;
declare const entities$3_vzigzag: typeof vzigzag;
declare const entities$3_Wcirc: typeof Wcirc;
declare const entities$3_wcirc: typeof wcirc;
declare const entities$3_wedbar: typeof wedbar;
declare const entities$3_wedge: typeof wedge;
declare const entities$3_Wedge: typeof Wedge;
declare const entities$3_wedgeq: typeof wedgeq;
declare const entities$3_weierp: typeof weierp;
declare const entities$3_Wfr: typeof Wfr;
declare const entities$3_wfr: typeof wfr;
declare const entities$3_Wopf: typeof Wopf;
declare const entities$3_wopf: typeof wopf;
declare const entities$3_wp: typeof wp;
declare const entities$3_wr: typeof wr;
declare const entities$3_wreath: typeof wreath;
declare const entities$3_Wscr: typeof Wscr;
declare const entities$3_wscr: typeof wscr;
declare const entities$3_xcap: typeof xcap;
declare const entities$3_xcirc: typeof xcirc;
declare const entities$3_xcup: typeof xcup;
declare const entities$3_xdtri: typeof xdtri;
declare const entities$3_Xfr: typeof Xfr;
declare const entities$3_xfr: typeof xfr;
declare const entities$3_xharr: typeof xharr;
declare const entities$3_xhArr: typeof xhArr;
declare const entities$3_Xi: typeof Xi;
declare const entities$3_xi: typeof xi;
declare const entities$3_xlarr: typeof xlarr;
declare const entities$3_xlArr: typeof xlArr;
declare const entities$3_xmap: typeof xmap;
declare const entities$3_xnis: typeof xnis;
declare const entities$3_xodot: typeof xodot;
declare const entities$3_Xopf: typeof Xopf;
declare const entities$3_xopf: typeof xopf;
declare const entities$3_xoplus: typeof xoplus;
declare const entities$3_xotime: typeof xotime;
declare const entities$3_xrarr: typeof xrarr;
declare const entities$3_xrArr: typeof xrArr;
declare const entities$3_Xscr: typeof Xscr;
declare const entities$3_xscr: typeof xscr;
declare const entities$3_xsqcup: typeof xsqcup;
declare const entities$3_xuplus: typeof xuplus;
declare const entities$3_xutri: typeof xutri;
declare const entities$3_xvee: typeof xvee;
declare const entities$3_xwedge: typeof xwedge;
declare const entities$3_Yacute: typeof Yacute;
declare const entities$3_yacute: typeof yacute;
declare const entities$3_YAcy: typeof YAcy;
declare const entities$3_yacy: typeof yacy;
declare const entities$3_Ycirc: typeof Ycirc;
declare const entities$3_ycirc: typeof ycirc;
declare const entities$3_Ycy: typeof Ycy;
declare const entities$3_ycy: typeof ycy;
declare const entities$3_yen: typeof yen;
declare const entities$3_Yfr: typeof Yfr;
declare const entities$3_yfr: typeof yfr;
declare const entities$3_YIcy: typeof YIcy;
declare const entities$3_yicy: typeof yicy;
declare const entities$3_Yopf: typeof Yopf;
declare const entities$3_yopf: typeof yopf;
declare const entities$3_Yscr: typeof Yscr;
declare const entities$3_yscr: typeof yscr;
declare const entities$3_YUcy: typeof YUcy;
declare const entities$3_yucy: typeof yucy;
declare const entities$3_yuml: typeof yuml;
declare const entities$3_Yuml: typeof Yuml;
declare const entities$3_Zacute: typeof Zacute;
declare const entities$3_zacute: typeof zacute;
declare const entities$3_Zcaron: typeof Zcaron;
declare const entities$3_zcaron: typeof zcaron;
declare const entities$3_Zcy: typeof Zcy;
declare const entities$3_zcy: typeof zcy;
declare const entities$3_Zdot: typeof Zdot;
declare const entities$3_zdot: typeof zdot;
declare const entities$3_zeetrf: typeof zeetrf;
declare const entities$3_ZeroWidthSpace: typeof ZeroWidthSpace;
declare const entities$3_Zeta: typeof Zeta;
declare const entities$3_zeta: typeof zeta;
declare const entities$3_zfr: typeof zfr;
declare const entities$3_Zfr: typeof Zfr;
declare const entities$3_ZHcy: typeof ZHcy;
declare const entities$3_zhcy: typeof zhcy;
declare const entities$3_zigrarr: typeof zigrarr;
declare const entities$3_zopf: typeof zopf;
declare const entities$3_Zopf: typeof Zopf;
declare const entities$3_Zscr: typeof Zscr;
declare const entities$3_zscr: typeof zscr;
declare const entities$3_zwj: typeof zwj;
declare const entities$3_zwnj: typeof zwnj;
declare namespace entities$3 {
  export {
    entities$3_Aacute as Aacute,
    entities$3_aacute as aacute,
    entities$3_Abreve as Abreve,
    entities$3_abreve as abreve,
    entities$3_ac as ac,
    entities$3_acd as acd,
    entities$3_acE as acE,
    entities$3_Acirc as Acirc,
    entities$3_acirc as acirc,
    entities$3_acute as acute,
    entities$3_Acy as Acy,
    entities$3_acy as acy,
    entities$3_AElig as AElig,
    entities$3_aelig as aelig,
    entities$3_af as af,
    entities$3_Afr as Afr,
    entities$3_afr as afr,
    entities$3_Agrave as Agrave,
    entities$3_agrave as agrave,
    entities$3_alefsym as alefsym,
    entities$3_aleph as aleph,
    entities$3_Alpha as Alpha,
    entities$3_alpha as alpha,
    entities$3_Amacr as Amacr,
    entities$3_amacr as amacr,
    entities$3_amalg as amalg,
    entities$3_amp as amp,
    entities$3_AMP as AMP,
    entities$3_andand as andand,
    entities$3_And as And,
    entities$3_and as and,
    entities$3_andd as andd,
    entities$3_andslope as andslope,
    entities$3_andv as andv,
    entities$3_ang as ang,
    entities$3_ange as ange,
    entities$3_angle as angle,
    entities$3_angmsdaa as angmsdaa,
    entities$3_angmsdab as angmsdab,
    entities$3_angmsdac as angmsdac,
    entities$3_angmsdad as angmsdad,
    entities$3_angmsdae as angmsdae,
    entities$3_angmsdaf as angmsdaf,
    entities$3_angmsdag as angmsdag,
    entities$3_angmsdah as angmsdah,
    entities$3_angmsd as angmsd,
    entities$3_angrt as angrt,
    entities$3_angrtvb as angrtvb,
    entities$3_angrtvbd as angrtvbd,
    entities$3_angsph as angsph,
    entities$3_angst as angst,
    entities$3_angzarr as angzarr,
    entities$3_Aogon as Aogon,
    entities$3_aogon as aogon,
    entities$3_Aopf as Aopf,
    entities$3_aopf as aopf,
    entities$3_apacir as apacir,
    entities$3_ap as ap,
    entities$3_apE as apE,
    entities$3_ape as ape,
    entities$3_apid as apid,
    entities$3_apos as apos,
    entities$3_ApplyFunction as ApplyFunction,
    entities$3_approx as approx,
    entities$3_approxeq as approxeq,
    entities$3_Aring as Aring,
    entities$3_aring as aring,
    entities$3_Ascr as Ascr,
    entities$3_ascr as ascr,
    entities$3_Assign as Assign,
    entities$3_ast as ast,
    entities$3_asymp as asymp,
    entities$3_asympeq as asympeq,
    entities$3_Atilde as Atilde,
    entities$3_atilde as atilde,
    entities$3_Auml as Auml,
    entities$3_auml as auml,
    entities$3_awconint as awconint,
    entities$3_awint as awint,
    entities$3_backcong as backcong,
    entities$3_backepsilon as backepsilon,
    entities$3_backprime as backprime,
    entities$3_backsim as backsim,
    entities$3_backsimeq as backsimeq,
    entities$3_Backslash as Backslash,
    entities$3_Barv as Barv,
    entities$3_barvee as barvee,
    entities$3_barwed as barwed,
    entities$3_Barwed as Barwed,
    entities$3_barwedge as barwedge,
    entities$3_bbrk as bbrk,
    entities$3_bbrktbrk as bbrktbrk,
    entities$3_bcong as bcong,
    entities$3_Bcy as Bcy,
    entities$3_bcy as bcy,
    entities$3_bdquo as bdquo,
    entities$3_becaus as becaus,
    entities$3_because as because,
    entities$3_Because as Because,
    entities$3_bemptyv as bemptyv,
    entities$3_bepsi as bepsi,
    entities$3_bernou as bernou,
    entities$3_Bernoullis as Bernoullis,
    entities$3_Beta as Beta,
    entities$3_beta as beta,
    entities$3_beth as beth,
    entities$3_between as between,
    entities$3_Bfr as Bfr,
    entities$3_bfr as bfr,
    entities$3_bigcap as bigcap,
    entities$3_bigcirc as bigcirc,
    entities$3_bigcup as bigcup,
    entities$3_bigodot as bigodot,
    entities$3_bigoplus as bigoplus,
    entities$3_bigotimes as bigotimes,
    entities$3_bigsqcup as bigsqcup,
    entities$3_bigstar as bigstar,
    entities$3_bigtriangledown as bigtriangledown,
    entities$3_bigtriangleup as bigtriangleup,
    entities$3_biguplus as biguplus,
    entities$3_bigvee as bigvee,
    entities$3_bigwedge as bigwedge,
    entities$3_bkarow as bkarow,
    entities$3_blacklozenge as blacklozenge,
    entities$3_blacksquare as blacksquare,
    entities$3_blacktriangle as blacktriangle,
    entities$3_blacktriangledown as blacktriangledown,
    entities$3_blacktriangleleft as blacktriangleleft,
    entities$3_blacktriangleright as blacktriangleright,
    entities$3_blank as blank,
    entities$3_blk12 as blk12,
    entities$3_blk14 as blk14,
    entities$3_blk34 as blk34,
    block$1 as block,
    entities$3_bne as bne,
    entities$3_bnequiv as bnequiv,
    entities$3_bNot as bNot,
    entities$3_bnot as bnot,
    entities$3_Bopf as Bopf,
    entities$3_bopf as bopf,
    entities$3_bot as bot,
    entities$3_bottom as bottom,
    entities$3_bowtie as bowtie,
    entities$3_boxbox as boxbox,
    entities$3_boxdl as boxdl,
    entities$3_boxdL as boxdL,
    entities$3_boxDl as boxDl,
    entities$3_boxDL as boxDL,
    entities$3_boxdr as boxdr,
    entities$3_boxdR as boxdR,
    entities$3_boxDr as boxDr,
    entities$3_boxDR as boxDR,
    entities$3_boxh as boxh,
    entities$3_boxH as boxH,
    entities$3_boxhd as boxhd,
    entities$3_boxHd as boxHd,
    entities$3_boxhD as boxhD,
    entities$3_boxHD as boxHD,
    entities$3_boxhu as boxhu,
    entities$3_boxHu as boxHu,
    entities$3_boxhU as boxhU,
    entities$3_boxHU as boxHU,
    entities$3_boxminus as boxminus,
    entities$3_boxplus as boxplus,
    entities$3_boxtimes as boxtimes,
    entities$3_boxul as boxul,
    entities$3_boxuL as boxuL,
    entities$3_boxUl as boxUl,
    entities$3_boxUL as boxUL,
    entities$3_boxur as boxur,
    entities$3_boxuR as boxuR,
    entities$3_boxUr as boxUr,
    entities$3_boxUR as boxUR,
    entities$3_boxv as boxv,
    entities$3_boxV as boxV,
    entities$3_boxvh as boxvh,
    entities$3_boxvH as boxvH,
    entities$3_boxVh as boxVh,
    entities$3_boxVH as boxVH,
    entities$3_boxvl as boxvl,
    entities$3_boxvL as boxvL,
    entities$3_boxVl as boxVl,
    entities$3_boxVL as boxVL,
    entities$3_boxvr as boxvr,
    entities$3_boxvR as boxvR,
    entities$3_boxVr as boxVr,
    entities$3_boxVR as boxVR,
    entities$3_bprime as bprime,
    entities$3_breve as breve,
    entities$3_Breve as Breve,
    entities$3_brvbar as brvbar,
    entities$3_bscr as bscr,
    entities$3_Bscr as Bscr,
    entities$3_bsemi as bsemi,
    entities$3_bsim as bsim,
    entities$3_bsime as bsime,
    entities$3_bsolb as bsolb,
    entities$3_bsol as bsol,
    entities$3_bsolhsub as bsolhsub,
    entities$3_bull as bull,
    entities$3_bullet as bullet,
    entities$3_bump as bump,
    entities$3_bumpE as bumpE,
    entities$3_bumpe as bumpe,
    entities$3_Bumpeq as Bumpeq,
    entities$3_bumpeq as bumpeq,
    entities$3_Cacute as Cacute,
    entities$3_cacute as cacute,
    entities$3_capand as capand,
    entities$3_capbrcup as capbrcup,
    entities$3_capcap as capcap,
    entities$3_cap as cap,
    entities$3_Cap as Cap,
    entities$3_capcup as capcup,
    entities$3_capdot as capdot,
    entities$3_CapitalDifferentialD as CapitalDifferentialD,
    entities$3_caps as caps,
    entities$3_caret as caret,
    entities$3_caron as caron,
    entities$3_Cayleys as Cayleys,
    entities$3_ccaps as ccaps,
    entities$3_Ccaron as Ccaron,
    entities$3_ccaron as ccaron,
    entities$3_Ccedil as Ccedil,
    entities$3_ccedil as ccedil,
    entities$3_Ccirc as Ccirc,
    entities$3_ccirc as ccirc,
    entities$3_Cconint as Cconint,
    entities$3_ccups as ccups,
    entities$3_ccupssm as ccupssm,
    entities$3_Cdot as Cdot,
    entities$3_cdot as cdot,
    entities$3_cedil as cedil,
    entities$3_Cedilla as Cedilla,
    entities$3_cemptyv as cemptyv,
    entities$3_cent as cent,
    entities$3_centerdot as centerdot,
    entities$3_CenterDot as CenterDot,
    entities$3_cfr as cfr,
    entities$3_Cfr as Cfr,
    entities$3_CHcy as CHcy,
    entities$3_chcy as chcy,
    entities$3_check as check,
    entities$3_checkmark as checkmark,
    entities$3_Chi as Chi,
    entities$3_chi as chi,
    entities$3_circ as circ,
    entities$3_circeq as circeq,
    entities$3_circlearrowleft as circlearrowleft,
    entities$3_circlearrowright as circlearrowright,
    entities$3_circledast as circledast,
    entities$3_circledcirc as circledcirc,
    entities$3_circleddash as circleddash,
    entities$3_CircleDot as CircleDot,
    entities$3_circledR as circledR,
    entities$3_circledS as circledS,
    entities$3_CircleMinus as CircleMinus,
    entities$3_CirclePlus as CirclePlus,
    entities$3_CircleTimes as CircleTimes,
    entities$3_cir as cir,
    entities$3_cirE as cirE,
    entities$3_cire as cire,
    entities$3_cirfnint as cirfnint,
    entities$3_cirmid as cirmid,
    entities$3_cirscir as cirscir,
    entities$3_ClockwiseContourIntegral as ClockwiseContourIntegral,
    entities$3_CloseCurlyDoubleQuote as CloseCurlyDoubleQuote,
    entities$3_CloseCurlyQuote as CloseCurlyQuote,
    entities$3_clubs as clubs,
    entities$3_clubsuit as clubsuit,
    entities$3_colon as colon,
    entities$3_Colon as Colon,
    entities$3_Colone as Colone,
    entities$3_colone as colone,
    entities$3_coloneq as coloneq,
    entities$3_comma as comma,
    entities$3_commat as commat,
    entities$3_comp as comp,
    entities$3_compfn as compfn,
    entities$3_complement as complement,
    entities$3_complexes as complexes,
    entities$3_cong as cong,
    entities$3_congdot as congdot,
    entities$3_Congruent as Congruent,
    entities$3_conint as conint,
    entities$3_Conint as Conint,
    entities$3_ContourIntegral as ContourIntegral,
    entities$3_copf as copf,
    entities$3_Copf as Copf,
    entities$3_coprod as coprod,
    entities$3_Coproduct as Coproduct,
    entities$3_copy as copy,
    entities$3_COPY as COPY,
    entities$3_copysr as copysr,
    entities$3_CounterClockwiseContourIntegral as CounterClockwiseContourIntegral,
    entities$3_crarr as crarr,
    entities$3_cross as cross,
    entities$3_Cross as Cross,
    entities$3_Cscr as Cscr,
    entities$3_cscr as cscr,
    entities$3_csub as csub,
    entities$3_csube as csube,
    entities$3_csup as csup,
    entities$3_csupe as csupe,
    entities$3_ctdot as ctdot,
    entities$3_cudarrl as cudarrl,
    entities$3_cudarrr as cudarrr,
    entities$3_cuepr as cuepr,
    entities$3_cuesc as cuesc,
    entities$3_cularr as cularr,
    entities$3_cularrp as cularrp,
    entities$3_cupbrcap as cupbrcap,
    entities$3_cupcap as cupcap,
    entities$3_CupCap as CupCap,
    entities$3_cup as cup,
    entities$3_Cup as Cup,
    entities$3_cupcup as cupcup,
    entities$3_cupdot as cupdot,
    entities$3_cupor as cupor,
    entities$3_cups as cups,
    entities$3_curarr as curarr,
    entities$3_curarrm as curarrm,
    entities$3_curlyeqprec as curlyeqprec,
    entities$3_curlyeqsucc as curlyeqsucc,
    entities$3_curlyvee as curlyvee,
    entities$3_curlywedge as curlywedge,
    entities$3_curren as curren,
    entities$3_curvearrowleft as curvearrowleft,
    entities$3_curvearrowright as curvearrowright,
    entities$3_cuvee as cuvee,
    entities$3_cuwed as cuwed,
    entities$3_cwconint as cwconint,
    entities$3_cwint as cwint,
    entities$3_cylcty as cylcty,
    entities$3_dagger as dagger,
    entities$3_Dagger as Dagger,
    entities$3_daleth as daleth,
    entities$3_darr as darr,
    entities$3_Darr as Darr,
    entities$3_dArr as dArr,
    entities$3_dash as dash,
    entities$3_Dashv as Dashv,
    entities$3_dashv as dashv,
    entities$3_dbkarow as dbkarow,
    entities$3_dblac as dblac,
    entities$3_Dcaron as Dcaron,
    entities$3_dcaron as dcaron,
    entities$3_Dcy as Dcy,
    entities$3_dcy as dcy,
    entities$3_ddagger as ddagger,
    entities$3_ddarr as ddarr,
    entities$3_DD as DD,
    entities$3_dd as dd,
    entities$3_DDotrahd as DDotrahd,
    entities$3_ddotseq as ddotseq,
    entities$3_deg as deg,
    entities$3_Del as Del,
    entities$3_Delta as Delta,
    entities$3_delta as delta,
    entities$3_demptyv as demptyv,
    entities$3_dfisht as dfisht,
    entities$3_Dfr as Dfr,
    entities$3_dfr as dfr,
    entities$3_dHar as dHar,
    entities$3_dharl as dharl,
    entities$3_dharr as dharr,
    entities$3_DiacriticalAcute as DiacriticalAcute,
    entities$3_DiacriticalDot as DiacriticalDot,
    entities$3_DiacriticalDoubleAcute as DiacriticalDoubleAcute,
    entities$3_DiacriticalGrave as DiacriticalGrave,
    entities$3_DiacriticalTilde as DiacriticalTilde,
    entities$3_diam as diam,
    entities$3_diamond as diamond,
    entities$3_Diamond as Diamond,
    entities$3_diamondsuit as diamondsuit,
    entities$3_diams as diams,
    entities$3_die as die,
    entities$3_DifferentialD as DifferentialD,
    entities$3_digamma as digamma,
    entities$3_disin as disin,
    entities$3_div as div,
    entities$3_divide as divide,
    entities$3_divideontimes as divideontimes,
    entities$3_divonx as divonx,
    entities$3_DJcy as DJcy,
    entities$3_djcy as djcy,
    entities$3_dlcorn as dlcorn,
    entities$3_dlcrop as dlcrop,
    entities$3_dollar as dollar,
    entities$3_Dopf as Dopf,
    entities$3_dopf as dopf,
    entities$3_Dot as Dot,
    entities$3_dot as dot,
    entities$3_DotDot as DotDot,
    entities$3_doteq as doteq,
    entities$3_doteqdot as doteqdot,
    entities$3_DotEqual as DotEqual,
    entities$3_dotminus as dotminus,
    entities$3_dotplus as dotplus,
    entities$3_dotsquare as dotsquare,
    entities$3_doublebarwedge as doublebarwedge,
    entities$3_DoubleContourIntegral as DoubleContourIntegral,
    entities$3_DoubleDot as DoubleDot,
    entities$3_DoubleDownArrow as DoubleDownArrow,
    entities$3_DoubleLeftArrow as DoubleLeftArrow,
    entities$3_DoubleLeftRightArrow as DoubleLeftRightArrow,
    entities$3_DoubleLeftTee as DoubleLeftTee,
    entities$3_DoubleLongLeftArrow as DoubleLongLeftArrow,
    entities$3_DoubleLongLeftRightArrow as DoubleLongLeftRightArrow,
    entities$3_DoubleLongRightArrow as DoubleLongRightArrow,
    entities$3_DoubleRightArrow as DoubleRightArrow,
    entities$3_DoubleRightTee as DoubleRightTee,
    entities$3_DoubleUpArrow as DoubleUpArrow,
    entities$3_DoubleUpDownArrow as DoubleUpDownArrow,
    entities$3_DoubleVerticalBar as DoubleVerticalBar,
    entities$3_DownArrowBar as DownArrowBar,
    entities$3_downarrow as downarrow,
    entities$3_DownArrow as DownArrow,
    entities$3_Downarrow as Downarrow,
    entities$3_DownArrowUpArrow as DownArrowUpArrow,
    entities$3_DownBreve as DownBreve,
    entities$3_downdownarrows as downdownarrows,
    entities$3_downharpoonleft as downharpoonleft,
    entities$3_downharpoonright as downharpoonright,
    entities$3_DownLeftRightVector as DownLeftRightVector,
    entities$3_DownLeftTeeVector as DownLeftTeeVector,
    entities$3_DownLeftVectorBar as DownLeftVectorBar,
    entities$3_DownLeftVector as DownLeftVector,
    entities$3_DownRightTeeVector as DownRightTeeVector,
    entities$3_DownRightVectorBar as DownRightVectorBar,
    entities$3_DownRightVector as DownRightVector,
    entities$3_DownTeeArrow as DownTeeArrow,
    entities$3_DownTee as DownTee,
    entities$3_drbkarow as drbkarow,
    entities$3_drcorn as drcorn,
    entities$3_drcrop as drcrop,
    entities$3_Dscr as Dscr,
    entities$3_dscr as dscr,
    entities$3_DScy as DScy,
    entities$3_dscy as dscy,
    entities$3_dsol as dsol,
    entities$3_Dstrok as Dstrok,
    entities$3_dstrok as dstrok,
    entities$3_dtdot as dtdot,
    entities$3_dtri as dtri,
    entities$3_dtrif as dtrif,
    entities$3_duarr as duarr,
    entities$3_duhar as duhar,
    entities$3_dwangle as dwangle,
    entities$3_DZcy as DZcy,
    entities$3_dzcy as dzcy,
    entities$3_dzigrarr as dzigrarr,
    entities$3_Eacute as Eacute,
    entities$3_eacute as eacute,
    entities$3_easter as easter,
    entities$3_Ecaron as Ecaron,
    entities$3_ecaron as ecaron,
    entities$3_Ecirc as Ecirc,
    entities$3_ecirc as ecirc,
    entities$3_ecir as ecir,
    entities$3_ecolon as ecolon,
    entities$3_Ecy as Ecy,
    entities$3_ecy as ecy,
    entities$3_eDDot as eDDot,
    entities$3_Edot as Edot,
    entities$3_edot as edot,
    entities$3_eDot as eDot,
    entities$3_ee as ee,
    entities$3_efDot as efDot,
    entities$3_Efr as Efr,
    entities$3_efr as efr,
    entities$3_eg as eg,
    entities$3_Egrave as Egrave,
    entities$3_egrave as egrave,
    entities$3_egs as egs,
    entities$3_egsdot as egsdot,
    entities$3_el as el,
    entities$3_Element as Element,
    entities$3_elinters as elinters,
    entities$3_ell as ell,
    entities$3_els as els,
    entities$3_elsdot as elsdot,
    entities$3_Emacr as Emacr,
    entities$3_emacr as emacr,
    entities$3_empty as empty,
    entities$3_emptyset as emptyset,
    entities$3_EmptySmallSquare as EmptySmallSquare,
    entities$3_emptyv as emptyv,
    entities$3_EmptyVerySmallSquare as EmptyVerySmallSquare,
    entities$3_emsp13 as emsp13,
    entities$3_emsp14 as emsp14,
    entities$3_emsp as emsp,
    entities$3_ENG as ENG,
    entities$3_eng as eng,
    entities$3_ensp as ensp,
    entities$3_Eogon as Eogon,
    entities$3_eogon as eogon,
    entities$3_Eopf as Eopf,
    entities$3_eopf as eopf,
    entities$3_epar as epar,
    entities$3_eparsl as eparsl,
    entities$3_eplus as eplus,
    entities$3_epsi as epsi,
    entities$3_Epsilon as Epsilon,
    entities$3_epsilon as epsilon,
    entities$3_epsiv as epsiv,
    entities$3_eqcirc as eqcirc,
    entities$3_eqcolon as eqcolon,
    entities$3_eqsim as eqsim,
    entities$3_eqslantgtr as eqslantgtr,
    entities$3_eqslantless as eqslantless,
    entities$3_Equal as Equal,
    entities$3_equals as equals,
    entities$3_EqualTilde as EqualTilde,
    entities$3_equest as equest,
    entities$3_Equilibrium as Equilibrium,
    entities$3_equiv as equiv,
    entities$3_equivDD as equivDD,
    entities$3_eqvparsl as eqvparsl,
    entities$3_erarr as erarr,
    entities$3_erDot as erDot,
    entities$3_escr as escr,
    entities$3_Escr as Escr,
    entities$3_esdot as esdot,
    entities$3_Esim as Esim,
    entities$3_esim as esim,
    entities$3_Eta as Eta,
    entities$3_eta as eta,
    entities$3_ETH as ETH,
    entities$3_eth as eth,
    entities$3_Euml as Euml,
    entities$3_euml as euml,
    entities$3_euro as euro,
    entities$3_excl as excl,
    entities$3_exist as exist,
    entities$3_Exists as Exists,
    entities$3_expectation as expectation,
    entities$3_exponentiale as exponentiale,
    entities$3_ExponentialE as ExponentialE,
    entities$3_fallingdotseq as fallingdotseq,
    entities$3_Fcy as Fcy,
    entities$3_fcy as fcy,
    entities$3_female as female,
    entities$3_ffilig as ffilig,
    entities$3_fflig as fflig,
    entities$3_ffllig as ffllig,
    entities$3_Ffr as Ffr,
    entities$3_ffr as ffr,
    entities$3_filig as filig,
    entities$3_FilledSmallSquare as FilledSmallSquare,
    entities$3_FilledVerySmallSquare as FilledVerySmallSquare,
    entities$3_fjlig as fjlig,
    entities$3_flat as flat,
    entities$3_fllig as fllig,
    entities$3_fltns as fltns,
    entities$3_fnof as fnof,
    entities$3_Fopf as Fopf,
    entities$3_fopf as fopf,
    entities$3_forall as forall,
    entities$3_ForAll as ForAll,
    entities$3_fork as fork,
    entities$3_forkv as forkv,
    entities$3_Fouriertrf as Fouriertrf,
    entities$3_fpartint as fpartint,
    entities$3_frac12 as frac12,
    entities$3_frac13 as frac13,
    entities$3_frac14 as frac14,
    entities$3_frac15 as frac15,
    entities$3_frac16 as frac16,
    entities$3_frac18 as frac18,
    entities$3_frac23 as frac23,
    entities$3_frac25 as frac25,
    entities$3_frac34 as frac34,
    entities$3_frac35 as frac35,
    entities$3_frac38 as frac38,
    entities$3_frac45 as frac45,
    entities$3_frac56 as frac56,
    entities$3_frac58 as frac58,
    entities$3_frac78 as frac78,
    entities$3_frasl as frasl,
    entities$3_frown as frown,
    entities$3_fscr as fscr,
    entities$3_Fscr as Fscr,
    entities$3_gacute as gacute,
    entities$3_Gamma as Gamma,
    entities$3_gamma as gamma,
    entities$3_Gammad as Gammad,
    entities$3_gammad as gammad,
    entities$3_gap as gap,
    entities$3_Gbreve as Gbreve,
    entities$3_gbreve as gbreve,
    entities$3_Gcedil as Gcedil,
    entities$3_Gcirc as Gcirc,
    entities$3_gcirc as gcirc,
    entities$3_Gcy as Gcy,
    entities$3_gcy as gcy,
    entities$3_Gdot as Gdot,
    entities$3_gdot as gdot,
    entities$3_ge as ge,
    entities$3_gE as gE,
    entities$3_gEl as gEl,
    entities$3_gel as gel,
    entities$3_geq as geq,
    entities$3_geqq as geqq,
    entities$3_geqslant as geqslant,
    entities$3_gescc as gescc,
    entities$3_ges as ges,
    entities$3_gesdot as gesdot,
    entities$3_gesdoto as gesdoto,
    entities$3_gesdotol as gesdotol,
    entities$3_gesl as gesl,
    entities$3_gesles as gesles,
    entities$3_Gfr as Gfr,
    entities$3_gfr as gfr,
    entities$3_gg as gg,
    entities$3_Gg as Gg,
    entities$3_ggg as ggg,
    entities$3_gimel as gimel,
    entities$3_GJcy as GJcy,
    entities$3_gjcy as gjcy,
    entities$3_gla as gla,
    entities$3_gl as gl,
    entities$3_glE as glE,
    entities$3_glj as glj,
    entities$3_gnap as gnap,
    entities$3_gnapprox as gnapprox,
    entities$3_gne as gne,
    entities$3_gnE as gnE,
    entities$3_gneq as gneq,
    entities$3_gneqq as gneqq,
    entities$3_gnsim as gnsim,
    entities$3_Gopf as Gopf,
    entities$3_gopf as gopf,
    entities$3_grave as grave,
    entities$3_GreaterEqual as GreaterEqual,
    entities$3_GreaterEqualLess as GreaterEqualLess,
    entities$3_GreaterFullEqual as GreaterFullEqual,
    entities$3_GreaterGreater as GreaterGreater,
    entities$3_GreaterLess as GreaterLess,
    entities$3_GreaterSlantEqual as GreaterSlantEqual,
    entities$3_GreaterTilde as GreaterTilde,
    entities$3_Gscr as Gscr,
    entities$3_gscr as gscr,
    entities$3_gsim as gsim,
    entities$3_gsime as gsime,
    entities$3_gsiml as gsiml,
    entities$3_gtcc as gtcc,
    entities$3_gtcir as gtcir,
    entities$3_gt as gt,
    entities$3_GT as GT,
    entities$3_Gt as Gt,
    entities$3_gtdot as gtdot,
    entities$3_gtlPar as gtlPar,
    entities$3_gtquest as gtquest,
    entities$3_gtrapprox as gtrapprox,
    entities$3_gtrarr as gtrarr,
    entities$3_gtrdot as gtrdot,
    entities$3_gtreqless as gtreqless,
    entities$3_gtreqqless as gtreqqless,
    entities$3_gtrless as gtrless,
    entities$3_gtrsim as gtrsim,
    entities$3_gvertneqq as gvertneqq,
    entities$3_gvnE as gvnE,
    entities$3_Hacek as Hacek,
    entities$3_hairsp as hairsp,
    entities$3_half as half,
    entities$3_hamilt as hamilt,
    entities$3_HARDcy as HARDcy,
    entities$3_hardcy as hardcy,
    entities$3_harrcir as harrcir,
    entities$3_harr as harr,
    entities$3_hArr as hArr,
    entities$3_harrw as harrw,
    entities$3_Hat as Hat,
    entities$3_hbar as hbar,
    entities$3_Hcirc as Hcirc,
    entities$3_hcirc as hcirc,
    entities$3_hearts as hearts,
    entities$3_heartsuit as heartsuit,
    entities$3_hellip as hellip,
    entities$3_hercon as hercon,
    entities$3_hfr as hfr,
    entities$3_Hfr as Hfr,
    entities$3_HilbertSpace as HilbertSpace,
    entities$3_hksearow as hksearow,
    entities$3_hkswarow as hkswarow,
    entities$3_hoarr as hoarr,
    entities$3_homtht as homtht,
    entities$3_hookleftarrow as hookleftarrow,
    entities$3_hookrightarrow as hookrightarrow,
    entities$3_hopf as hopf,
    entities$3_Hopf as Hopf,
    entities$3_horbar as horbar,
    entities$3_HorizontalLine as HorizontalLine,
    entities$3_hscr as hscr,
    entities$3_Hscr as Hscr,
    entities$3_hslash as hslash,
    entities$3_Hstrok as Hstrok,
    entities$3_hstrok as hstrok,
    entities$3_HumpDownHump as HumpDownHump,
    entities$3_HumpEqual as HumpEqual,
    entities$3_hybull as hybull,
    entities$3_hyphen as hyphen,
    entities$3_Iacute as Iacute,
    entities$3_iacute as iacute,
    entities$3_ic as ic,
    entities$3_Icirc as Icirc,
    entities$3_icirc as icirc,
    entities$3_Icy as Icy,
    entities$3_icy as icy,
    entities$3_Idot as Idot,
    entities$3_IEcy as IEcy,
    entities$3_iecy as iecy,
    entities$3_iexcl as iexcl,
    entities$3_iff as iff,
    entities$3_ifr as ifr,
    entities$3_Ifr as Ifr,
    entities$3_Igrave as Igrave,
    entities$3_igrave as igrave,
    entities$3_ii as ii,
    entities$3_iiiint as iiiint,
    entities$3_iiint as iiint,
    entities$3_iinfin as iinfin,
    entities$3_iiota as iiota,
    entities$3_IJlig as IJlig,
    entities$3_ijlig as ijlig,
    entities$3_Imacr as Imacr,
    entities$3_imacr as imacr,
    image$1 as image,
    entities$3_ImaginaryI as ImaginaryI,
    entities$3_imagline as imagline,
    entities$3_imagpart as imagpart,
    entities$3_imath as imath,
    entities$3_Im as Im,
    entities$3_imof as imof,
    entities$3_imped as imped,
    entities$3_Implies as Implies,
    entities$3_incare as incare,
    entities$3_infin as infin,
    entities$3_infintie as infintie,
    entities$3_inodot as inodot,
    entities$3_intcal as intcal,
    entities$3_int as int,
    entities$3_Int as Int,
    entities$3_integers as integers,
    entities$3_Integral as Integral,
    entities$3_intercal as intercal,
    entities$3_Intersection as Intersection,
    entities$3_intlarhk as intlarhk,
    entities$3_intprod as intprod,
    entities$3_InvisibleComma as InvisibleComma,
    entities$3_InvisibleTimes as InvisibleTimes,
    entities$3_IOcy as IOcy,
    entities$3_iocy as iocy,
    entities$3_Iogon as Iogon,
    entities$3_iogon as iogon,
    entities$3_Iopf as Iopf,
    entities$3_iopf as iopf,
    entities$3_Iota as Iota,
    entities$3_iota as iota,
    entities$3_iprod as iprod,
    entities$3_iquest as iquest,
    entities$3_iscr as iscr,
    entities$3_Iscr as Iscr,
    entities$3_isin as isin,
    entities$3_isindot as isindot,
    entities$3_isinE as isinE,
    entities$3_isins as isins,
    entities$3_isinsv as isinsv,
    entities$3_isinv as isinv,
    entities$3_it as it,
    entities$3_Itilde as Itilde,
    entities$3_itilde as itilde,
    entities$3_Iukcy as Iukcy,
    entities$3_iukcy as iukcy,
    entities$3_Iuml as Iuml,
    entities$3_iuml as iuml,
    entities$3_Jcirc as Jcirc,
    entities$3_jcirc as jcirc,
    entities$3_Jcy as Jcy,
    entities$3_jcy as jcy,
    entities$3_Jfr as Jfr,
    entities$3_jfr as jfr,
    entities$3_jmath as jmath,
    entities$3_Jopf as Jopf,
    entities$3_jopf as jopf,
    entities$3_Jscr as Jscr,
    entities$3_jscr as jscr,
    entities$3_Jsercy as Jsercy,
    entities$3_jsercy as jsercy,
    entities$3_Jukcy as Jukcy,
    entities$3_jukcy as jukcy,
    entities$3_Kappa as Kappa,
    entities$3_kappa as kappa,
    entities$3_kappav as kappav,
    entities$3_Kcedil as Kcedil,
    entities$3_kcedil as kcedil,
    entities$3_Kcy as Kcy,
    entities$3_kcy as kcy,
    entities$3_Kfr as Kfr,
    entities$3_kfr as kfr,
    entities$3_kgreen as kgreen,
    entities$3_KHcy as KHcy,
    entities$3_khcy as khcy,
    entities$3_KJcy as KJcy,
    entities$3_kjcy as kjcy,
    entities$3_Kopf as Kopf,
    entities$3_kopf as kopf,
    entities$3_Kscr as Kscr,
    entities$3_kscr as kscr,
    entities$3_lAarr as lAarr,
    entities$3_Lacute as Lacute,
    entities$3_lacute as lacute,
    entities$3_laemptyv as laemptyv,
    entities$3_lagran as lagran,
    entities$3_Lambda as Lambda,
    entities$3_lambda as lambda,
    entities$3_lang as lang,
    entities$3_Lang as Lang,
    entities$3_langd as langd,
    entities$3_langle as langle,
    entities$3_lap as lap,
    entities$3_Laplacetrf as Laplacetrf,
    entities$3_laquo as laquo,
    entities$3_larrb as larrb,
    entities$3_larrbfs as larrbfs,
    entities$3_larr as larr,
    entities$3_Larr as Larr,
    entities$3_lArr as lArr,
    entities$3_larrfs as larrfs,
    entities$3_larrhk as larrhk,
    entities$3_larrlp as larrlp,
    entities$3_larrpl as larrpl,
    entities$3_larrsim as larrsim,
    entities$3_larrtl as larrtl,
    entities$3_latail as latail,
    entities$3_lAtail as lAtail,
    entities$3_lat as lat,
    entities$3_late as late,
    entities$3_lates as lates,
    entities$3_lbarr as lbarr,
    entities$3_lBarr as lBarr,
    entities$3_lbbrk as lbbrk,
    entities$3_lbrace as lbrace,
    entities$3_lbrack as lbrack,
    entities$3_lbrke as lbrke,
    entities$3_lbrksld as lbrksld,
    entities$3_lbrkslu as lbrkslu,
    entities$3_Lcaron as Lcaron,
    entities$3_lcaron as lcaron,
    entities$3_Lcedil as Lcedil,
    entities$3_lcedil as lcedil,
    entities$3_lceil as lceil,
    entities$3_lcub as lcub,
    entities$3_Lcy as Lcy,
    entities$3_lcy as lcy,
    entities$3_ldca as ldca,
    entities$3_ldquo as ldquo,
    entities$3_ldquor as ldquor,
    entities$3_ldrdhar as ldrdhar,
    entities$3_ldrushar as ldrushar,
    entities$3_ldsh as ldsh,
    entities$3_le as le,
    entities$3_lE as lE,
    entities$3_LeftAngleBracket as LeftAngleBracket,
    entities$3_LeftArrowBar as LeftArrowBar,
    entities$3_leftarrow as leftarrow,
    entities$3_LeftArrow as LeftArrow,
    entities$3_Leftarrow as Leftarrow,
    entities$3_LeftArrowRightArrow as LeftArrowRightArrow,
    entities$3_leftarrowtail as leftarrowtail,
    entities$3_LeftCeiling as LeftCeiling,
    entities$3_LeftDoubleBracket as LeftDoubleBracket,
    entities$3_LeftDownTeeVector as LeftDownTeeVector,
    entities$3_LeftDownVectorBar as LeftDownVectorBar,
    entities$3_LeftDownVector as LeftDownVector,
    entities$3_LeftFloor as LeftFloor,
    entities$3_leftharpoondown as leftharpoondown,
    entities$3_leftharpoonup as leftharpoonup,
    entities$3_leftleftarrows as leftleftarrows,
    entities$3_leftrightarrow as leftrightarrow,
    entities$3_LeftRightArrow as LeftRightArrow,
    entities$3_Leftrightarrow as Leftrightarrow,
    entities$3_leftrightarrows as leftrightarrows,
    entities$3_leftrightharpoons as leftrightharpoons,
    entities$3_leftrightsquigarrow as leftrightsquigarrow,
    entities$3_LeftRightVector as LeftRightVector,
    entities$3_LeftTeeArrow as LeftTeeArrow,
    entities$3_LeftTee as LeftTee,
    entities$3_LeftTeeVector as LeftTeeVector,
    entities$3_leftthreetimes as leftthreetimes,
    entities$3_LeftTriangleBar as LeftTriangleBar,
    entities$3_LeftTriangle as LeftTriangle,
    entities$3_LeftTriangleEqual as LeftTriangleEqual,
    entities$3_LeftUpDownVector as LeftUpDownVector,
    entities$3_LeftUpTeeVector as LeftUpTeeVector,
    entities$3_LeftUpVectorBar as LeftUpVectorBar,
    entities$3_LeftUpVector as LeftUpVector,
    entities$3_LeftVectorBar as LeftVectorBar,
    entities$3_LeftVector as LeftVector,
    entities$3_lEg as lEg,
    entities$3_leg as leg,
    entities$3_leq as leq,
    entities$3_leqq as leqq,
    entities$3_leqslant as leqslant,
    entities$3_lescc as lescc,
    entities$3_les as les,
    entities$3_lesdot as lesdot,
    entities$3_lesdoto as lesdoto,
    entities$3_lesdotor as lesdotor,
    entities$3_lesg as lesg,
    entities$3_lesges as lesges,
    entities$3_lessapprox as lessapprox,
    entities$3_lessdot as lessdot,
    entities$3_lesseqgtr as lesseqgtr,
    entities$3_lesseqqgtr as lesseqqgtr,
    entities$3_LessEqualGreater as LessEqualGreater,
    entities$3_LessFullEqual as LessFullEqual,
    entities$3_LessGreater as LessGreater,
    entities$3_lessgtr as lessgtr,
    entities$3_LessLess as LessLess,
    entities$3_lesssim as lesssim,
    entities$3_LessSlantEqual as LessSlantEqual,
    entities$3_LessTilde as LessTilde,
    entities$3_lfisht as lfisht,
    entities$3_lfloor as lfloor,
    entities$3_Lfr as Lfr,
    entities$3_lfr as lfr,
    entities$3_lg as lg,
    entities$3_lgE as lgE,
    entities$3_lHar as lHar,
    entities$3_lhard as lhard,
    entities$3_lharu as lharu,
    entities$3_lharul as lharul,
    entities$3_lhblk as lhblk,
    entities$3_LJcy as LJcy,
    entities$3_ljcy as ljcy,
    entities$3_llarr as llarr,
    entities$3_ll as ll,
    entities$3_Ll as Ll,
    entities$3_llcorner as llcorner,
    entities$3_Lleftarrow as Lleftarrow,
    entities$3_llhard as llhard,
    entities$3_lltri as lltri,
    entities$3_Lmidot as Lmidot,
    entities$3_lmidot as lmidot,
    entities$3_lmoustache as lmoustache,
    entities$3_lmoust as lmoust,
    entities$3_lnap as lnap,
    entities$3_lnapprox as lnapprox,
    entities$3_lne as lne,
    entities$3_lnE as lnE,
    entities$3_lneq as lneq,
    entities$3_lneqq as lneqq,
    entities$3_lnsim as lnsim,
    entities$3_loang as loang,
    entities$3_loarr as loarr,
    entities$3_lobrk as lobrk,
    entities$3_longleftarrow as longleftarrow,
    entities$3_LongLeftArrow as LongLeftArrow,
    entities$3_Longleftarrow as Longleftarrow,
    entities$3_longleftrightarrow as longleftrightarrow,
    entities$3_LongLeftRightArrow as LongLeftRightArrow,
    entities$3_Longleftrightarrow as Longleftrightarrow,
    entities$3_longmapsto as longmapsto,
    entities$3_longrightarrow as longrightarrow,
    entities$3_LongRightArrow as LongRightArrow,
    entities$3_Longrightarrow as Longrightarrow,
    entities$3_looparrowleft as looparrowleft,
    entities$3_looparrowright as looparrowright,
    entities$3_lopar as lopar,
    entities$3_Lopf as Lopf,
    entities$3_lopf as lopf,
    entities$3_loplus as loplus,
    entities$3_lotimes as lotimes,
    entities$3_lowast as lowast,
    entities$3_lowbar as lowbar,
    entities$3_LowerLeftArrow as LowerLeftArrow,
    entities$3_LowerRightArrow as LowerRightArrow,
    entities$3_loz as loz,
    entities$3_lozenge as lozenge,
    entities$3_lozf as lozf,
    entities$3_lpar as lpar,
    entities$3_lparlt as lparlt,
    entities$3_lrarr as lrarr,
    entities$3_lrcorner as lrcorner,
    entities$3_lrhar as lrhar,
    entities$3_lrhard as lrhard,
    entities$3_lrm as lrm,
    entities$3_lrtri as lrtri,
    entities$3_lsaquo as lsaquo,
    entities$3_lscr as lscr,
    entities$3_Lscr as Lscr,
    entities$3_lsh as lsh,
    entities$3_Lsh as Lsh,
    entities$3_lsim as lsim,
    entities$3_lsime as lsime,
    entities$3_lsimg as lsimg,
    entities$3_lsqb as lsqb,
    entities$3_lsquo as lsquo,
    entities$3_lsquor as lsquor,
    entities$3_Lstrok as Lstrok,
    entities$3_lstrok as lstrok,
    entities$3_ltcc as ltcc,
    entities$3_ltcir as ltcir,
    entities$3_lt as lt,
    entities$3_LT as LT,
    entities$3_Lt as Lt,
    entities$3_ltdot as ltdot,
    entities$3_lthree as lthree,
    entities$3_ltimes as ltimes,
    entities$3_ltlarr as ltlarr,
    entities$3_ltquest as ltquest,
    entities$3_ltri as ltri,
    entities$3_ltrie as ltrie,
    entities$3_ltrif as ltrif,
    entities$3_ltrPar as ltrPar,
    entities$3_lurdshar as lurdshar,
    entities$3_luruhar as luruhar,
    entities$3_lvertneqq as lvertneqq,
    entities$3_lvnE as lvnE,
    entities$3_macr as macr,
    entities$3_male as male,
    entities$3_malt as malt,
    entities$3_maltese as maltese,
    entities$3_map as map,
    entities$3_mapsto as mapsto,
    entities$3_mapstodown as mapstodown,
    entities$3_mapstoleft as mapstoleft,
    entities$3_mapstoup as mapstoup,
    entities$3_marker as marker,
    entities$3_mcomma as mcomma,
    entities$3_Mcy as Mcy,
    entities$3_mcy as mcy,
    entities$3_mdash as mdash,
    entities$3_mDDot as mDDot,
    entities$3_measuredangle as measuredangle,
    entities$3_MediumSpace as MediumSpace,
    entities$3_Mellintrf as Mellintrf,
    entities$3_Mfr as Mfr,
    entities$3_mfr as mfr,
    entities$3_mho as mho,
    entities$3_micro as micro,
    entities$3_midast as midast,
    entities$3_midcir as midcir,
    entities$3_mid as mid,
    entities$3_middot as middot,
    entities$3_minusb as minusb,
    entities$3_minus as minus,
    entities$3_minusd as minusd,
    entities$3_minusdu as minusdu,
    entities$3_MinusPlus as MinusPlus,
    entities$3_mlcp as mlcp,
    entities$3_mldr as mldr,
    entities$3_mnplus as mnplus,
    entities$3_models as models,
    entities$3_Mopf as Mopf,
    entities$3_mopf as mopf,
    entities$3_mp as mp,
    entities$3_mscr as mscr,
    entities$3_Mscr as Mscr,
    entities$3_mstpos as mstpos,
    entities$3_Mu as Mu,
    entities$3_mu as mu,
    entities$3_multimap as multimap,
    entities$3_mumap as mumap,
    entities$3_nabla as nabla,
    entities$3_Nacute as Nacute,
    entities$3_nacute as nacute,
    entities$3_nang as nang,
    entities$3_nap as nap,
    entities$3_napE as napE,
    entities$3_napid as napid,
    entities$3_napos as napos,
    entities$3_napprox as napprox,
    entities$3_natural as natural,
    entities$3_naturals as naturals,
    entities$3_natur as natur,
    entities$3_nbsp as nbsp,
    entities$3_nbump as nbump,
    entities$3_nbumpe as nbumpe,
    entities$3_ncap as ncap,
    entities$3_Ncaron as Ncaron,
    entities$3_ncaron as ncaron,
    entities$3_Ncedil as Ncedil,
    entities$3_ncedil as ncedil,
    entities$3_ncong as ncong,
    entities$3_ncongdot as ncongdot,
    entities$3_ncup as ncup,
    entities$3_Ncy as Ncy,
    entities$3_ncy as ncy,
    entities$3_ndash as ndash,
    entities$3_nearhk as nearhk,
    entities$3_nearr as nearr,
    entities$3_neArr as neArr,
    entities$3_nearrow as nearrow,
    entities$3_ne as ne,
    entities$3_nedot as nedot,
    entities$3_NegativeMediumSpace as NegativeMediumSpace,
    entities$3_NegativeThickSpace as NegativeThickSpace,
    entities$3_NegativeThinSpace as NegativeThinSpace,
    entities$3_NegativeVeryThinSpace as NegativeVeryThinSpace,
    entities$3_nequiv as nequiv,
    entities$3_nesear as nesear,
    entities$3_nesim as nesim,
    entities$3_NestedGreaterGreater as NestedGreaterGreater,
    entities$3_NestedLessLess as NestedLessLess,
    entities$3_NewLine as NewLine,
    entities$3_nexist as nexist,
    entities$3_nexists as nexists,
    entities$3_Nfr as Nfr,
    entities$3_nfr as nfr,
    entities$3_ngE as ngE,
    entities$3_nge as nge,
    entities$3_ngeq as ngeq,
    entities$3_ngeqq as ngeqq,
    entities$3_ngeqslant as ngeqslant,
    entities$3_nges as nges,
    entities$3_nGg as nGg,
    entities$3_ngsim as ngsim,
    entities$3_nGt as nGt,
    entities$3_ngt as ngt,
    entities$3_ngtr as ngtr,
    entities$3_nGtv as nGtv,
    entities$3_nharr as nharr,
    entities$3_nhArr as nhArr,
    entities$3_nhpar as nhpar,
    entities$3_ni as ni,
    entities$3_nis as nis,
    entities$3_nisd as nisd,
    entities$3_niv as niv,
    entities$3_NJcy as NJcy,
    entities$3_njcy as njcy,
    entities$3_nlarr as nlarr,
    entities$3_nlArr as nlArr,
    entities$3_nldr as nldr,
    entities$3_nlE as nlE,
    entities$3_nle as nle,
    entities$3_nleftarrow as nleftarrow,
    entities$3_nLeftarrow as nLeftarrow,
    entities$3_nleftrightarrow as nleftrightarrow,
    entities$3_nLeftrightarrow as nLeftrightarrow,
    entities$3_nleq as nleq,
    entities$3_nleqq as nleqq,
    entities$3_nleqslant as nleqslant,
    entities$3_nles as nles,
    entities$3_nless as nless,
    entities$3_nLl as nLl,
    entities$3_nlsim as nlsim,
    entities$3_nLt as nLt,
    entities$3_nlt as nlt,
    entities$3_nltri as nltri,
    entities$3_nltrie as nltrie,
    entities$3_nLtv as nLtv,
    entities$3_nmid as nmid,
    entities$3_NoBreak as NoBreak,
    entities$3_NonBreakingSpace as NonBreakingSpace,
    entities$3_nopf as nopf,
    entities$3_Nopf as Nopf,
    entities$3_Not as Not,
    entities$3_not as not,
    entities$3_NotCongruent as NotCongruent,
    entities$3_NotCupCap as NotCupCap,
    entities$3_NotDoubleVerticalBar as NotDoubleVerticalBar,
    entities$3_NotElement as NotElement,
    entities$3_NotEqual as NotEqual,
    entities$3_NotEqualTilde as NotEqualTilde,
    entities$3_NotExists as NotExists,
    entities$3_NotGreater as NotGreater,
    entities$3_NotGreaterEqual as NotGreaterEqual,
    entities$3_NotGreaterFullEqual as NotGreaterFullEqual,
    entities$3_NotGreaterGreater as NotGreaterGreater,
    entities$3_NotGreaterLess as NotGreaterLess,
    entities$3_NotGreaterSlantEqual as NotGreaterSlantEqual,
    entities$3_NotGreaterTilde as NotGreaterTilde,
    entities$3_NotHumpDownHump as NotHumpDownHump,
    entities$3_NotHumpEqual as NotHumpEqual,
    entities$3_notin as notin,
    entities$3_notindot as notindot,
    entities$3_notinE as notinE,
    entities$3_notinva as notinva,
    entities$3_notinvb as notinvb,
    entities$3_notinvc as notinvc,
    entities$3_NotLeftTriangleBar as NotLeftTriangleBar,
    entities$3_NotLeftTriangle as NotLeftTriangle,
    entities$3_NotLeftTriangleEqual as NotLeftTriangleEqual,
    entities$3_NotLess as NotLess,
    entities$3_NotLessEqual as NotLessEqual,
    entities$3_NotLessGreater as NotLessGreater,
    entities$3_NotLessLess as NotLessLess,
    entities$3_NotLessSlantEqual as NotLessSlantEqual,
    entities$3_NotLessTilde as NotLessTilde,
    entities$3_NotNestedGreaterGreater as NotNestedGreaterGreater,
    entities$3_NotNestedLessLess as NotNestedLessLess,
    entities$3_notni as notni,
    entities$3_notniva as notniva,
    entities$3_notnivb as notnivb,
    entities$3_notnivc as notnivc,
    entities$3_NotPrecedes as NotPrecedes,
    entities$3_NotPrecedesEqual as NotPrecedesEqual,
    entities$3_NotPrecedesSlantEqual as NotPrecedesSlantEqual,
    entities$3_NotReverseElement as NotReverseElement,
    entities$3_NotRightTriangleBar as NotRightTriangleBar,
    entities$3_NotRightTriangle as NotRightTriangle,
    entities$3_NotRightTriangleEqual as NotRightTriangleEqual,
    entities$3_NotSquareSubset as NotSquareSubset,
    entities$3_NotSquareSubsetEqual as NotSquareSubsetEqual,
    entities$3_NotSquareSuperset as NotSquareSuperset,
    entities$3_NotSquareSupersetEqual as NotSquareSupersetEqual,
    entities$3_NotSubset as NotSubset,
    entities$3_NotSubsetEqual as NotSubsetEqual,
    entities$3_NotSucceeds as NotSucceeds,
    entities$3_NotSucceedsEqual as NotSucceedsEqual,
    entities$3_NotSucceedsSlantEqual as NotSucceedsSlantEqual,
    entities$3_NotSucceedsTilde as NotSucceedsTilde,
    entities$3_NotSuperset as NotSuperset,
    entities$3_NotSupersetEqual as NotSupersetEqual,
    entities$3_NotTilde as NotTilde,
    entities$3_NotTildeEqual as NotTildeEqual,
    entities$3_NotTildeFullEqual as NotTildeFullEqual,
    entities$3_NotTildeTilde as NotTildeTilde,
    entities$3_NotVerticalBar as NotVerticalBar,
    entities$3_nparallel as nparallel,
    entities$3_npar as npar,
    entities$3_nparsl as nparsl,
    entities$3_npart as npart,
    entities$3_npolint as npolint,
    entities$3_npr as npr,
    entities$3_nprcue as nprcue,
    entities$3_nprec as nprec,
    entities$3_npreceq as npreceq,
    entities$3_npre as npre,
    entities$3_nrarrc as nrarrc,
    entities$3_nrarr as nrarr,
    entities$3_nrArr as nrArr,
    entities$3_nrarrw as nrarrw,
    entities$3_nrightarrow as nrightarrow,
    entities$3_nRightarrow as nRightarrow,
    entities$3_nrtri as nrtri,
    entities$3_nrtrie as nrtrie,
    entities$3_nsc as nsc,
    entities$3_nsccue as nsccue,
    entities$3_nsce as nsce,
    entities$3_Nscr as Nscr,
    entities$3_nscr as nscr,
    entities$3_nshortmid as nshortmid,
    entities$3_nshortparallel as nshortparallel,
    entities$3_nsim as nsim,
    entities$3_nsime as nsime,
    entities$3_nsimeq as nsimeq,
    entities$3_nsmid as nsmid,
    entities$3_nspar as nspar,
    entities$3_nsqsube as nsqsube,
    entities$3_nsqsupe as nsqsupe,
    entities$3_nsub as nsub,
    entities$3_nsubE as nsubE,
    entities$3_nsube as nsube,
    entities$3_nsubset as nsubset,
    entities$3_nsubseteq as nsubseteq,
    entities$3_nsubseteqq as nsubseteqq,
    entities$3_nsucc as nsucc,
    entities$3_nsucceq as nsucceq,
    entities$3_nsup as nsup,
    entities$3_nsupE as nsupE,
    entities$3_nsupe as nsupe,
    entities$3_nsupset as nsupset,
    entities$3_nsupseteq as nsupseteq,
    entities$3_nsupseteqq as nsupseteqq,
    entities$3_ntgl as ntgl,
    entities$3_Ntilde as Ntilde,
    entities$3_ntilde as ntilde,
    entities$3_ntlg as ntlg,
    entities$3_ntriangleleft as ntriangleleft,
    entities$3_ntrianglelefteq as ntrianglelefteq,
    entities$3_ntriangleright as ntriangleright,
    entities$3_ntrianglerighteq as ntrianglerighteq,
    entities$3_Nu as Nu,
    entities$3_nu as nu,
    entities$3_num as num,
    entities$3_numero as numero,
    entities$3_numsp as numsp,
    entities$3_nvap as nvap,
    entities$3_nvdash as nvdash,
    entities$3_nvDash as nvDash,
    entities$3_nVdash as nVdash,
    entities$3_nVDash as nVDash,
    entities$3_nvge as nvge,
    entities$3_nvgt as nvgt,
    entities$3_nvHarr as nvHarr,
    entities$3_nvinfin as nvinfin,
    entities$3_nvlArr as nvlArr,
    entities$3_nvle as nvle,
    entities$3_nvlt as nvlt,
    entities$3_nvltrie as nvltrie,
    entities$3_nvrArr as nvrArr,
    entities$3_nvrtrie as nvrtrie,
    entities$3_nvsim as nvsim,
    entities$3_nwarhk as nwarhk,
    entities$3_nwarr as nwarr,
    entities$3_nwArr as nwArr,
    entities$3_nwarrow as nwarrow,
    entities$3_nwnear as nwnear,
    entities$3_Oacute as Oacute,
    entities$3_oacute as oacute,
    entities$3_oast as oast,
    entities$3_Ocirc as Ocirc,
    entities$3_ocirc as ocirc,
    entities$3_ocir as ocir,
    entities$3_Ocy as Ocy,
    entities$3_ocy as ocy,
    entities$3_odash as odash,
    entities$3_Odblac as Odblac,
    entities$3_odblac as odblac,
    entities$3_odiv as odiv,
    entities$3_odot as odot,
    entities$3_odsold as odsold,
    entities$3_OElig as OElig,
    entities$3_oelig as oelig,
    entities$3_ofcir as ofcir,
    entities$3_Ofr as Ofr,
    entities$3_ofr as ofr,
    entities$3_ogon as ogon,
    entities$3_Ograve as Ograve,
    entities$3_ograve as ograve,
    entities$3_ogt as ogt,
    entities$3_ohbar as ohbar,
    entities$3_ohm as ohm,
    entities$3_oint as oint,
    entities$3_olarr as olarr,
    entities$3_olcir as olcir,
    entities$3_olcross as olcross,
    entities$3_oline as oline,
    entities$3_olt as olt,
    entities$3_Omacr as Omacr,
    entities$3_omacr as omacr,
    entities$3_Omega as Omega,
    entities$3_omega as omega,
    entities$3_Omicron as Omicron,
    entities$3_omicron as omicron,
    entities$3_omid as omid,
    entities$3_ominus as ominus,
    entities$3_Oopf as Oopf,
    entities$3_oopf as oopf,
    entities$3_opar as opar,
    entities$3_OpenCurlyDoubleQuote as OpenCurlyDoubleQuote,
    entities$3_OpenCurlyQuote as OpenCurlyQuote,
    entities$3_operp as operp,
    entities$3_oplus as oplus,
    entities$3_orarr as orarr,
    entities$3_Or as Or,
    entities$3_or as or,
    entities$3_ord as ord,
    entities$3_order as order,
    entities$3_orderof as orderof,
    entities$3_ordf as ordf,
    entities$3_ordm as ordm,
    entities$3_origof as origof,
    entities$3_oror as oror,
    entities$3_orslope as orslope,
    entities$3_orv as orv,
    entities$3_oS as oS,
    entities$3_Oscr as Oscr,
    entities$3_oscr as oscr,
    entities$3_Oslash as Oslash,
    entities$3_oslash as oslash,
    entities$3_osol as osol,
    entities$3_Otilde as Otilde,
    entities$3_otilde as otilde,
    entities$3_otimesas as otimesas,
    entities$3_Otimes as Otimes,
    entities$3_otimes as otimes,
    entities$3_Ouml as Ouml,
    entities$3_ouml as ouml,
    entities$3_ovbar as ovbar,
    entities$3_OverBar as OverBar,
    entities$3_OverBrace as OverBrace,
    entities$3_OverBracket as OverBracket,
    entities$3_OverParenthesis as OverParenthesis,
    entities$3_para as para,
    entities$3_parallel as parallel,
    entities$3_par as par,
    entities$3_parsim as parsim,
    entities$3_parsl as parsl,
    entities$3_part as part,
    entities$3_PartialD as PartialD,
    entities$3_Pcy as Pcy,
    entities$3_pcy as pcy,
    entities$3_percnt as percnt,
    entities$3_period as period,
    entities$3_permil as permil,
    entities$3_perp as perp,
    entities$3_pertenk as pertenk,
    entities$3_Pfr as Pfr,
    entities$3_pfr as pfr,
    entities$3_Phi as Phi,
    entities$3_phi as phi,
    entities$3_phiv as phiv,
    entities$3_phmmat as phmmat,
    entities$3_phone as phone,
    entities$3_Pi as Pi,
    entities$3_pi as pi,
    entities$3_pitchfork as pitchfork,
    entities$3_piv as piv,
    entities$3_planck as planck,
    entities$3_planckh as planckh,
    entities$3_plankv as plankv,
    entities$3_plusacir as plusacir,
    entities$3_plusb as plusb,
    entities$3_pluscir as pluscir,
    entities$3_plus as plus,
    entities$3_plusdo as plusdo,
    entities$3_plusdu as plusdu,
    entities$3_pluse as pluse,
    entities$3_PlusMinus as PlusMinus,
    entities$3_plusmn as plusmn,
    entities$3_plussim as plussim,
    entities$3_plustwo as plustwo,
    entities$3_pm as pm,
    entities$3_Poincareplane as Poincareplane,
    entities$3_pointint as pointint,
    entities$3_popf as popf,
    entities$3_Popf as Popf,
    entities$3_pound as pound,
    entities$3_prap as prap,
    entities$3_Pr as Pr,
    entities$3_pr as pr,
    entities$3_prcue as prcue,
    entities$3_precapprox as precapprox,
    entities$3_prec as prec,
    entities$3_preccurlyeq as preccurlyeq,
    entities$3_Precedes as Precedes,
    entities$3_PrecedesEqual as PrecedesEqual,
    entities$3_PrecedesSlantEqual as PrecedesSlantEqual,
    entities$3_PrecedesTilde as PrecedesTilde,
    entities$3_preceq as preceq,
    entities$3_precnapprox as precnapprox,
    entities$3_precneqq as precneqq,
    entities$3_precnsim as precnsim,
    entities$3_pre as pre,
    entities$3_prE as prE,
    entities$3_precsim as precsim,
    entities$3_prime as prime,
    entities$3_Prime as Prime,
    entities$3_primes as primes,
    entities$3_prnap as prnap,
    entities$3_prnE as prnE,
    entities$3_prnsim as prnsim,
    entities$3_prod as prod,
    entities$3_Product as Product,
    entities$3_profalar as profalar,
    entities$3_profline as profline,
    entities$3_profsurf as profsurf,
    entities$3_prop as prop,
    entities$3_Proportional as Proportional,
    entities$3_Proportion as Proportion,
    entities$3_propto as propto,
    entities$3_prsim as prsim,
    entities$3_prurel as prurel,
    entities$3_Pscr as Pscr,
    entities$3_pscr as pscr,
    entities$3_Psi as Psi,
    entities$3_psi as psi,
    entities$3_puncsp as puncsp,
    entities$3_Qfr as Qfr,
    entities$3_qfr as qfr,
    entities$3_qint as qint,
    entities$3_qopf as qopf,
    entities$3_Qopf as Qopf,
    entities$3_qprime as qprime,
    entities$3_Qscr as Qscr,
    entities$3_qscr as qscr,
    entities$3_quaternions as quaternions,
    entities$3_quatint as quatint,
    entities$3_quest as quest,
    entities$3_questeq as questeq,
    entities$3_quot as quot,
    entities$3_QUOT as QUOT,
    entities$3_rAarr as rAarr,
    entities$3_race as race,
    entities$3_Racute as Racute,
    entities$3_racute as racute,
    entities$3_radic as radic,
    entities$3_raemptyv as raemptyv,
    entities$3_rang as rang,
    entities$3_Rang as Rang,
    entities$3_rangd as rangd,
    entities$3_range as range,
    entities$3_rangle as rangle,
    entities$3_raquo as raquo,
    entities$3_rarrap as rarrap,
    entities$3_rarrb as rarrb,
    entities$3_rarrbfs as rarrbfs,
    entities$3_rarrc as rarrc,
    entities$3_rarr as rarr,
    entities$3_Rarr as Rarr,
    entities$3_rArr as rArr,
    entities$3_rarrfs as rarrfs,
    entities$3_rarrhk as rarrhk,
    entities$3_rarrlp as rarrlp,
    entities$3_rarrpl as rarrpl,
    entities$3_rarrsim as rarrsim,
    entities$3_Rarrtl as Rarrtl,
    entities$3_rarrtl as rarrtl,
    entities$3_rarrw as rarrw,
    entities$3_ratail as ratail,
    entities$3_rAtail as rAtail,
    entities$3_ratio as ratio,
    entities$3_rationals as rationals,
    entities$3_rbarr as rbarr,
    entities$3_rBarr as rBarr,
    entities$3_RBarr as RBarr,
    entities$3_rbbrk as rbbrk,
    entities$3_rbrace as rbrace,
    entities$3_rbrack as rbrack,
    entities$3_rbrke as rbrke,
    entities$3_rbrksld as rbrksld,
    entities$3_rbrkslu as rbrkslu,
    entities$3_Rcaron as Rcaron,
    entities$3_rcaron as rcaron,
    entities$3_Rcedil as Rcedil,
    entities$3_rcedil as rcedil,
    entities$3_rceil as rceil,
    entities$3_rcub as rcub,
    entities$3_Rcy as Rcy,
    entities$3_rcy as rcy,
    entities$3_rdca as rdca,
    entities$3_rdldhar as rdldhar,
    entities$3_rdquo as rdquo,
    entities$3_rdquor as rdquor,
    entities$3_rdsh as rdsh,
    entities$3_real as real,
    entities$3_realine as realine,
    entities$3_realpart as realpart,
    entities$3_reals as reals,
    entities$3_Re as Re,
    entities$3_rect as rect,
    entities$3_reg as reg,
    entities$3_REG as REG,
    entities$3_ReverseElement as ReverseElement,
    entities$3_ReverseEquilibrium as ReverseEquilibrium,
    entities$3_ReverseUpEquilibrium as ReverseUpEquilibrium,
    entities$3_rfisht as rfisht,
    entities$3_rfloor as rfloor,
    entities$3_rfr as rfr,
    entities$3_Rfr as Rfr,
    entities$3_rHar as rHar,
    entities$3_rhard as rhard,
    entities$3_rharu as rharu,
    entities$3_rharul as rharul,
    entities$3_Rho as Rho,
    entities$3_rho as rho,
    entities$3_rhov as rhov,
    entities$3_RightAngleBracket as RightAngleBracket,
    entities$3_RightArrowBar as RightArrowBar,
    entities$3_rightarrow as rightarrow,
    entities$3_RightArrow as RightArrow,
    entities$3_Rightarrow as Rightarrow,
    entities$3_RightArrowLeftArrow as RightArrowLeftArrow,
    entities$3_rightarrowtail as rightarrowtail,
    entities$3_RightCeiling as RightCeiling,
    entities$3_RightDoubleBracket as RightDoubleBracket,
    entities$3_RightDownTeeVector as RightDownTeeVector,
    entities$3_RightDownVectorBar as RightDownVectorBar,
    entities$3_RightDownVector as RightDownVector,
    entities$3_RightFloor as RightFloor,
    entities$3_rightharpoondown as rightharpoondown,
    entities$3_rightharpoonup as rightharpoonup,
    entities$3_rightleftarrows as rightleftarrows,
    entities$3_rightleftharpoons as rightleftharpoons,
    entities$3_rightrightarrows as rightrightarrows,
    entities$3_rightsquigarrow as rightsquigarrow,
    entities$3_RightTeeArrow as RightTeeArrow,
    entities$3_RightTee as RightTee,
    entities$3_RightTeeVector as RightTeeVector,
    entities$3_rightthreetimes as rightthreetimes,
    entities$3_RightTriangleBar as RightTriangleBar,
    entities$3_RightTriangle as RightTriangle,
    entities$3_RightTriangleEqual as RightTriangleEqual,
    entities$3_RightUpDownVector as RightUpDownVector,
    entities$3_RightUpTeeVector as RightUpTeeVector,
    entities$3_RightUpVectorBar as RightUpVectorBar,
    entities$3_RightUpVector as RightUpVector,
    entities$3_RightVectorBar as RightVectorBar,
    entities$3_RightVector as RightVector,
    entities$3_ring as ring,
    entities$3_risingdotseq as risingdotseq,
    entities$3_rlarr as rlarr,
    entities$3_rlhar as rlhar,
    entities$3_rlm as rlm,
    entities$3_rmoustache as rmoustache,
    entities$3_rmoust as rmoust,
    entities$3_rnmid as rnmid,
    entities$3_roang as roang,
    entities$3_roarr as roarr,
    entities$3_robrk as robrk,
    entities$3_ropar as ropar,
    entities$3_ropf as ropf,
    entities$3_Ropf as Ropf,
    entities$3_roplus as roplus,
    entities$3_rotimes as rotimes,
    entities$3_RoundImplies as RoundImplies,
    entities$3_rpar as rpar,
    entities$3_rpargt as rpargt,
    entities$3_rppolint as rppolint,
    entities$3_rrarr as rrarr,
    entities$3_Rrightarrow as Rrightarrow,
    entities$3_rsaquo as rsaquo,
    entities$3_rscr as rscr,
    entities$3_Rscr as Rscr,
    entities$3_rsh as rsh,
    entities$3_Rsh as Rsh,
    entities$3_rsqb as rsqb,
    entities$3_rsquo as rsquo,
    entities$3_rsquor as rsquor,
    entities$3_rthree as rthree,
    entities$3_rtimes as rtimes,
    entities$3_rtri as rtri,
    entities$3_rtrie as rtrie,
    entities$3_rtrif as rtrif,
    entities$3_rtriltri as rtriltri,
    entities$3_RuleDelayed as RuleDelayed,
    entities$3_ruluhar as ruluhar,
    entities$3_rx as rx,
    entities$3_Sacute as Sacute,
    entities$3_sacute as sacute,
    entities$3_sbquo as sbquo,
    entities$3_scap as scap,
    entities$3_Scaron as Scaron,
    entities$3_scaron as scaron,
    entities$3_Sc as Sc,
    entities$3_sc as sc,
    entities$3_sccue as sccue,
    entities$3_sce as sce,
    entities$3_scE as scE,
    entities$3_Scedil as Scedil,
    entities$3_scedil as scedil,
    entities$3_Scirc as Scirc,
    entities$3_scirc as scirc,
    entities$3_scnap as scnap,
    entities$3_scnE as scnE,
    entities$3_scnsim as scnsim,
    entities$3_scpolint as scpolint,
    entities$3_scsim as scsim,
    entities$3_Scy as Scy,
    entities$3_scy as scy,
    entities$3_sdotb as sdotb,
    entities$3_sdot as sdot,
    entities$3_sdote as sdote,
    entities$3_searhk as searhk,
    entities$3_searr as searr,
    entities$3_seArr as seArr,
    entities$3_searrow as searrow,
    entities$3_sect as sect,
    entities$3_semi as semi,
    entities$3_seswar as seswar,
    entities$3_setminus as setminus,
    entities$3_setmn as setmn,
    entities$3_sext as sext,
    entities$3_Sfr as Sfr,
    entities$3_sfr as sfr,
    entities$3_sfrown as sfrown,
    entities$3_sharp as sharp,
    entities$3_SHCHcy as SHCHcy,
    entities$3_shchcy as shchcy,
    entities$3_SHcy as SHcy,
    entities$3_shcy as shcy,
    entities$3_ShortDownArrow as ShortDownArrow,
    entities$3_ShortLeftArrow as ShortLeftArrow,
    entities$3_shortmid as shortmid,
    entities$3_shortparallel as shortparallel,
    entities$3_ShortRightArrow as ShortRightArrow,
    entities$3_ShortUpArrow as ShortUpArrow,
    entities$3_shy as shy,
    entities$3_Sigma as Sigma,
    entities$3_sigma as sigma,
    entities$3_sigmaf as sigmaf,
    entities$3_sigmav as sigmav,
    entities$3_sim as sim,
    entities$3_simdot as simdot,
    entities$3_sime as sime,
    entities$3_simeq as simeq,
    entities$3_simg as simg,
    entities$3_simgE as simgE,
    entities$3_siml as siml,
    entities$3_simlE as simlE,
    entities$3_simne as simne,
    entities$3_simplus as simplus,
    entities$3_simrarr as simrarr,
    entities$3_slarr as slarr,
    entities$3_SmallCircle as SmallCircle,
    entities$3_smallsetminus as smallsetminus,
    entities$3_smashp as smashp,
    entities$3_smeparsl as smeparsl,
    entities$3_smid as smid,
    entities$3_smile as smile,
    entities$3_smt as smt,
    entities$3_smte as smte,
    entities$3_smtes as smtes,
    entities$3_SOFTcy as SOFTcy,
    entities$3_softcy as softcy,
    entities$3_solbar as solbar,
    entities$3_solb as solb,
    entities$3_sol as sol,
    entities$3_Sopf as Sopf,
    entities$3_sopf as sopf,
    entities$3_spades as spades,
    entities$3_spadesuit as spadesuit,
    entities$3_spar as spar,
    entities$3_sqcap as sqcap,
    entities$3_sqcaps as sqcaps,
    entities$3_sqcup as sqcup,
    entities$3_sqcups as sqcups,
    entities$3_Sqrt as Sqrt,
    entities$3_sqsub as sqsub,
    entities$3_sqsube as sqsube,
    entities$3_sqsubset as sqsubset,
    entities$3_sqsubseteq as sqsubseteq,
    entities$3_sqsup as sqsup,
    entities$3_sqsupe as sqsupe,
    entities$3_sqsupset as sqsupset,
    entities$3_sqsupseteq as sqsupseteq,
    entities$3_square as square,
    entities$3_Square as Square,
    entities$3_SquareIntersection as SquareIntersection,
    entities$3_SquareSubset as SquareSubset,
    entities$3_SquareSubsetEqual as SquareSubsetEqual,
    entities$3_SquareSuperset as SquareSuperset,
    entities$3_SquareSupersetEqual as SquareSupersetEqual,
    entities$3_SquareUnion as SquareUnion,
    entities$3_squarf as squarf,
    entities$3_squ as squ,
    entities$3_squf as squf,
    entities$3_srarr as srarr,
    entities$3_Sscr as Sscr,
    entities$3_sscr as sscr,
    entities$3_ssetmn as ssetmn,
    entities$3_ssmile as ssmile,
    entities$3_sstarf as sstarf,
    entities$3_Star as Star,
    entities$3_star as star,
    entities$3_starf as starf,
    entities$3_straightepsilon as straightepsilon,
    entities$3_straightphi as straightphi,
    entities$3_strns as strns,
    entities$3_sub as sub,
    entities$3_Sub as Sub,
    entities$3_subdot as subdot,
    entities$3_subE as subE,
    entities$3_sube as sube,
    entities$3_subedot as subedot,
    entities$3_submult as submult,
    entities$3_subnE as subnE,
    entities$3_subne as subne,
    entities$3_subplus as subplus,
    entities$3_subrarr as subrarr,
    entities$3_subset as subset,
    entities$3_Subset as Subset,
    entities$3_subseteq as subseteq,
    entities$3_subseteqq as subseteqq,
    entities$3_SubsetEqual as SubsetEqual,
    entities$3_subsetneq as subsetneq,
    entities$3_subsetneqq as subsetneqq,
    entities$3_subsim as subsim,
    entities$3_subsub as subsub,
    entities$3_subsup as subsup,
    entities$3_succapprox as succapprox,
    entities$3_succ as succ,
    entities$3_succcurlyeq as succcurlyeq,
    entities$3_Succeeds as Succeeds,
    entities$3_SucceedsEqual as SucceedsEqual,
    entities$3_SucceedsSlantEqual as SucceedsSlantEqual,
    entities$3_SucceedsTilde as SucceedsTilde,
    entities$3_succeq as succeq,
    entities$3_succnapprox as succnapprox,
    entities$3_succneqq as succneqq,
    entities$3_succnsim as succnsim,
    entities$3_succsim as succsim,
    entities$3_SuchThat as SuchThat,
    entities$3_sum as sum,
    entities$3_Sum as Sum,
    entities$3_sung as sung,
    entities$3_sup1 as sup1,
    entities$3_sup2 as sup2,
    entities$3_sup3 as sup3,
    entities$3_sup as sup,
    entities$3_Sup as Sup,
    entities$3_supdot as supdot,
    entities$3_supdsub as supdsub,
    entities$3_supE as supE,
    entities$3_supe as supe,
    entities$3_supedot as supedot,
    entities$3_Superset as Superset,
    entities$3_SupersetEqual as SupersetEqual,
    entities$3_suphsol as suphsol,
    entities$3_suphsub as suphsub,
    entities$3_suplarr as suplarr,
    entities$3_supmult as supmult,
    entities$3_supnE as supnE,
    entities$3_supne as supne,
    entities$3_supplus as supplus,
    entities$3_supset as supset,
    entities$3_Supset as Supset,
    entities$3_supseteq as supseteq,
    entities$3_supseteqq as supseteqq,
    entities$3_supsetneq as supsetneq,
    entities$3_supsetneqq as supsetneqq,
    entities$3_supsim as supsim,
    entities$3_supsub as supsub,
    entities$3_supsup as supsup,
    entities$3_swarhk as swarhk,
    entities$3_swarr as swarr,
    entities$3_swArr as swArr,
    entities$3_swarrow as swarrow,
    entities$3_swnwar as swnwar,
    entities$3_szlig as szlig,
    entities$3_Tab as Tab,
    entities$3_target as target,
    entities$3_Tau as Tau,
    entities$3_tau as tau,
    entities$3_tbrk as tbrk,
    entities$3_Tcaron as Tcaron,
    entities$3_tcaron as tcaron,
    entities$3_Tcedil as Tcedil,
    entities$3_tcedil as tcedil,
    entities$3_Tcy as Tcy,
    entities$3_tcy as tcy,
    entities$3_tdot as tdot,
    entities$3_telrec as telrec,
    entities$3_Tfr as Tfr,
    entities$3_tfr as tfr,
    entities$3_there4 as there4,
    entities$3_therefore as therefore,
    entities$3_Therefore as Therefore,
    entities$3_Theta as Theta,
    entities$3_theta as theta,
    entities$3_thetasym as thetasym,
    entities$3_thetav as thetav,
    entities$3_thickapprox as thickapprox,
    entities$3_thicksim as thicksim,
    entities$3_ThickSpace as ThickSpace,
    entities$3_ThinSpace as ThinSpace,
    entities$3_thinsp as thinsp,
    entities$3_thkap as thkap,
    entities$3_thksim as thksim,
    entities$3_THORN as THORN,
    entities$3_thorn as thorn,
    entities$3_tilde as tilde,
    entities$3_Tilde as Tilde,
    entities$3_TildeEqual as TildeEqual,
    entities$3_TildeFullEqual as TildeFullEqual,
    entities$3_TildeTilde as TildeTilde,
    entities$3_timesbar as timesbar,
    entities$3_timesb as timesb,
    entities$3_times as times,
    entities$3_timesd as timesd,
    entities$3_tint as tint,
    entities$3_toea as toea,
    entities$3_topbot as topbot,
    entities$3_topcir as topcir,
    entities$3_top as top,
    entities$3_Topf as Topf,
    entities$3_topf as topf,
    entities$3_topfork as topfork,
    entities$3_tosa as tosa,
    entities$3_tprime as tprime,
    entities$3_trade as trade,
    entities$3_TRADE as TRADE,
    entities$3_triangle as triangle,
    entities$3_triangledown as triangledown,
    entities$3_triangleleft as triangleleft,
    entities$3_trianglelefteq as trianglelefteq,
    entities$3_triangleq as triangleq,
    entities$3_triangleright as triangleright,
    entities$3_trianglerighteq as trianglerighteq,
    entities$3_tridot as tridot,
    entities$3_trie as trie,
    entities$3_triminus as triminus,
    entities$3_TripleDot as TripleDot,
    entities$3_triplus as triplus,
    entities$3_trisb as trisb,
    entities$3_tritime as tritime,
    entities$3_trpezium as trpezium,
    entities$3_Tscr as Tscr,
    entities$3_tscr as tscr,
    entities$3_TScy as TScy,
    entities$3_tscy as tscy,
    entities$3_TSHcy as TSHcy,
    entities$3_tshcy as tshcy,
    entities$3_Tstrok as Tstrok,
    entities$3_tstrok as tstrok,
    entities$3_twixt as twixt,
    entities$3_twoheadleftarrow as twoheadleftarrow,
    entities$3_twoheadrightarrow as twoheadrightarrow,
    entities$3_Uacute as Uacute,
    entities$3_uacute as uacute,
    entities$3_uarr as uarr,
    entities$3_Uarr as Uarr,
    entities$3_uArr as uArr,
    entities$3_Uarrocir as Uarrocir,
    entities$3_Ubrcy as Ubrcy,
    entities$3_ubrcy as ubrcy,
    entities$3_Ubreve as Ubreve,
    entities$3_ubreve as ubreve,
    entities$3_Ucirc as Ucirc,
    entities$3_ucirc as ucirc,
    entities$3_Ucy as Ucy,
    entities$3_ucy as ucy,
    entities$3_udarr as udarr,
    entities$3_Udblac as Udblac,
    entities$3_udblac as udblac,
    entities$3_udhar as udhar,
    entities$3_ufisht as ufisht,
    entities$3_Ufr as Ufr,
    entities$3_ufr as ufr,
    entities$3_Ugrave as Ugrave,
    entities$3_ugrave as ugrave,
    entities$3_uHar as uHar,
    entities$3_uharl as uharl,
    entities$3_uharr as uharr,
    entities$3_uhblk as uhblk,
    entities$3_ulcorn as ulcorn,
    entities$3_ulcorner as ulcorner,
    entities$3_ulcrop as ulcrop,
    entities$3_ultri as ultri,
    entities$3_Umacr as Umacr,
    entities$3_umacr as umacr,
    entities$3_uml as uml,
    entities$3_UnderBar as UnderBar,
    entities$3_UnderBrace as UnderBrace,
    entities$3_UnderBracket as UnderBracket,
    entities$3_UnderParenthesis as UnderParenthesis,
    entities$3_Union as Union,
    entities$3_UnionPlus as UnionPlus,
    entities$3_Uogon as Uogon,
    entities$3_uogon as uogon,
    entities$3_Uopf as Uopf,
    entities$3_uopf as uopf,
    entities$3_UpArrowBar as UpArrowBar,
    entities$3_uparrow as uparrow,
    entities$3_UpArrow as UpArrow,
    entities$3_Uparrow as Uparrow,
    entities$3_UpArrowDownArrow as UpArrowDownArrow,
    entities$3_updownarrow as updownarrow,
    entities$3_UpDownArrow as UpDownArrow,
    entities$3_Updownarrow as Updownarrow,
    entities$3_UpEquilibrium as UpEquilibrium,
    entities$3_upharpoonleft as upharpoonleft,
    entities$3_upharpoonright as upharpoonright,
    entities$3_uplus as uplus,
    entities$3_UpperLeftArrow as UpperLeftArrow,
    entities$3_UpperRightArrow as UpperRightArrow,
    entities$3_upsi as upsi,
    entities$3_Upsi as Upsi,
    entities$3_upsih as upsih,
    entities$3_Upsilon as Upsilon,
    entities$3_upsilon as upsilon,
    entities$3_UpTeeArrow as UpTeeArrow,
    entities$3_UpTee as UpTee,
    entities$3_upuparrows as upuparrows,
    entities$3_urcorn as urcorn,
    entities$3_urcorner as urcorner,
    entities$3_urcrop as urcrop,
    entities$3_Uring as Uring,
    entities$3_uring as uring,
    entities$3_urtri as urtri,
    entities$3_Uscr as Uscr,
    entities$3_uscr as uscr,
    entities$3_utdot as utdot,
    entities$3_Utilde as Utilde,
    entities$3_utilde as utilde,
    entities$3_utri as utri,
    entities$3_utrif as utrif,
    entities$3_uuarr as uuarr,
    entities$3_Uuml as Uuml,
    entities$3_uuml as uuml,
    entities$3_uwangle as uwangle,
    entities$3_vangrt as vangrt,
    entities$3_varepsilon as varepsilon,
    entities$3_varkappa as varkappa,
    entities$3_varnothing as varnothing,
    entities$3_varphi as varphi,
    entities$3_varpi as varpi,
    entities$3_varpropto as varpropto,
    entities$3_varr as varr,
    entities$3_vArr as vArr,
    entities$3_varrho as varrho,
    entities$3_varsigma as varsigma,
    entities$3_varsubsetneq as varsubsetneq,
    entities$3_varsubsetneqq as varsubsetneqq,
    entities$3_varsupsetneq as varsupsetneq,
    entities$3_varsupsetneqq as varsupsetneqq,
    entities$3_vartheta as vartheta,
    entities$3_vartriangleleft as vartriangleleft,
    entities$3_vartriangleright as vartriangleright,
    entities$3_vBar as vBar,
    entities$3_Vbar as Vbar,
    entities$3_vBarv as vBarv,
    entities$3_Vcy as Vcy,
    entities$3_vcy as vcy,
    entities$3_vdash as vdash,
    entities$3_vDash as vDash,
    entities$3_Vdash as Vdash,
    entities$3_VDash as VDash,
    entities$3_Vdashl as Vdashl,
    entities$3_veebar as veebar,
    entities$3_vee as vee,
    entities$3_Vee as Vee,
    entities$3_veeeq as veeeq,
    entities$3_vellip as vellip,
    entities$3_verbar as verbar,
    entities$3_Verbar as Verbar,
    entities$3_vert as vert,
    entities$3_Vert as Vert,
    entities$3_VerticalBar as VerticalBar,
    entities$3_VerticalLine as VerticalLine,
    entities$3_VerticalSeparator as VerticalSeparator,
    entities$3_VerticalTilde as VerticalTilde,
    entities$3_VeryThinSpace as VeryThinSpace,
    entities$3_Vfr as Vfr,
    entities$3_vfr as vfr,
    entities$3_vltri as vltri,
    entities$3_vnsub as vnsub,
    entities$3_vnsup as vnsup,
    entities$3_Vopf as Vopf,
    entities$3_vopf as vopf,
    entities$3_vprop as vprop,
    entities$3_vrtri as vrtri,
    entities$3_Vscr as Vscr,
    entities$3_vscr as vscr,
    entities$3_vsubnE as vsubnE,
    entities$3_vsubne as vsubne,
    entities$3_vsupnE as vsupnE,
    entities$3_vsupne as vsupne,
    entities$3_Vvdash as Vvdash,
    entities$3_vzigzag as vzigzag,
    entities$3_Wcirc as Wcirc,
    entities$3_wcirc as wcirc,
    entities$3_wedbar as wedbar,
    entities$3_wedge as wedge,
    entities$3_Wedge as Wedge,
    entities$3_wedgeq as wedgeq,
    entities$3_weierp as weierp,
    entities$3_Wfr as Wfr,
    entities$3_wfr as wfr,
    entities$3_Wopf as Wopf,
    entities$3_wopf as wopf,
    entities$3_wp as wp,
    entities$3_wr as wr,
    entities$3_wreath as wreath,
    entities$3_Wscr as Wscr,
    entities$3_wscr as wscr,
    entities$3_xcap as xcap,
    entities$3_xcirc as xcirc,
    entities$3_xcup as xcup,
    entities$3_xdtri as xdtri,
    entities$3_Xfr as Xfr,
    entities$3_xfr as xfr,
    entities$3_xharr as xharr,
    entities$3_xhArr as xhArr,
    entities$3_Xi as Xi,
    entities$3_xi as xi,
    entities$3_xlarr as xlarr,
    entities$3_xlArr as xlArr,
    entities$3_xmap as xmap,
    entities$3_xnis as xnis,
    entities$3_xodot as xodot,
    entities$3_Xopf as Xopf,
    entities$3_xopf as xopf,
    entities$3_xoplus as xoplus,
    entities$3_xotime as xotime,
    entities$3_xrarr as xrarr,
    entities$3_xrArr as xrArr,
    entities$3_Xscr as Xscr,
    entities$3_xscr as xscr,
    entities$3_xsqcup as xsqcup,
    entities$3_xuplus as xuplus,
    entities$3_xutri as xutri,
    entities$3_xvee as xvee,
    entities$3_xwedge as xwedge,
    entities$3_Yacute as Yacute,
    entities$3_yacute as yacute,
    entities$3_YAcy as YAcy,
    entities$3_yacy as yacy,
    entities$3_Ycirc as Ycirc,
    entities$3_ycirc as ycirc,
    entities$3_Ycy as Ycy,
    entities$3_ycy as ycy,
    entities$3_yen as yen,
    entities$3_Yfr as Yfr,
    entities$3_yfr as yfr,
    entities$3_YIcy as YIcy,
    entities$3_yicy as yicy,
    entities$3_Yopf as Yopf,
    entities$3_yopf as yopf,
    entities$3_Yscr as Yscr,
    entities$3_yscr as yscr,
    entities$3_YUcy as YUcy,
    entities$3_yucy as yucy,
    entities$3_yuml as yuml,
    entities$3_Yuml as Yuml,
    entities$3_Zacute as Zacute,
    entities$3_zacute as zacute,
    entities$3_Zcaron as Zcaron,
    entities$3_zcaron as zcaron,
    entities$3_Zcy as Zcy,
    entities$3_zcy as zcy,
    entities$3_Zdot as Zdot,
    entities$3_zdot as zdot,
    entities$3_zeetrf as zeetrf,
    entities$3_ZeroWidthSpace as ZeroWidthSpace,
    entities$3_Zeta as Zeta,
    entities$3_zeta as zeta,
    entities$3_zfr as zfr,
    entities$3_Zfr as Zfr,
    entities$3_ZHcy as ZHcy,
    entities$3_zhcy as zhcy,
    entities$3_zigrarr as zigrarr,
    entities$3_zopf as zopf,
    entities$3_Zopf as Zopf,
    entities$3_Zscr as Zscr,
    entities$3_zscr as zscr,
    entities$3_zwj as zwj,
    entities$3_zwnj as zwnj,
    entities$2 as default,
  };
}

var require$$0 = /*@__PURE__*/getAugmentedNamespace(entities$3);

/*eslint quotes:0*/
var entities$1 = require$$0;

var regex$4=/[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

var mdurl$1 = {};

var encodeCache = {};


// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) { return cache; }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}


// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i, l, code, nextCode, cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped  = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";


var encode_1 = encode;

/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i, ch, cache = decodeCache[exclude];
  if (cache) { return cache; }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}


// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    var i, l, b1, b2, b3, b4, chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);

          if (chr < 0x80) {
            result += '\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);

          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {
            result += '\ufffd\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\ufffd\ufffd\ufffd\ufffd';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\ufffd';
    }

    return result;
  });
}


decode.defaultChars   = ';/?:@&=+$,#';
decode.componentChars = '';


var decode_1 = decode;

var format = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = [ '<', '>', '"', '`', ' ', '\r', '\n', '\t' ],

    // RFC 2396: characters not allowed for various reasons.
    unwise = [ '{', '}', '|', '\\', '^', '`' ].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = [ '\'' ].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),
    hostEndingChars = [ '/', '?', '#' ],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    /* eslint-disable no-script-url */
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    };
    /* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, slashesDenoteHost) {
  var i, l, lowerProto, hec, slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') { hostEnd--; }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function(host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

var parse = urlParse;

mdurl$1.encode = encode_1;
mdurl$1.decode = decode_1;
mdurl$1.format = format;
mdurl$1.parse  = parse;

var uc_micro = {};

var regex$3=/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

var regex$2=/[\0-\x1F\x7F-\x9F]/;

var regex$1=/[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

var regex=/[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

uc_micro.Any = regex$3;
uc_micro.Cc  = regex$2;
uc_micro.Cf  = regex$1;
uc_micro.P   = regex$4;
uc_micro.Z   = regex;

(function (exports) {


function _class(obj) { return Object.prototype.toString.call(obj); }

function isString(obj) { return _class(obj) === '[object String]'; }

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) { return false; }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }
  // control codes
  if (c >= 0x00 && c <= 0x08) { return false; }
  if (c === 0x0B) { return false; }
  if (c >= 0x0E && c <= 0x1F) { return false; }
  if (c >= 0x7F && c <= 0x9F) { return false; }
  // out of range
  if (c > 0x10FFFF) { return false; }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}


var UNESCAPE_MD_RE  = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = entities$1;

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ?
      parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);

    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) { return str; }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) { return str; }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) { return escaped; }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) { return true; }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = regex$4;

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}


// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21/* ! */:
    case 0x22/* " */:
    case 0x23/* # */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x26/* & */:
    case 0x27/* ' */:
    case 0x28/* ( */:
    case 0x29/* ) */:
    case 0x2A/* * */:
    case 0x2B/* + */:
    case 0x2C/* , */:
    case 0x2D/* - */:
    case 0x2E/* . */:
    case 0x2F/* / */:
    case 0x3A/* : */:
    case 0x3B/* ; */:
    case 0x3C/* < */:
    case 0x3D/* = */:
    case 0x3E/* > */:
    case 0x3F/* ? */:
    case 0x40/* @ */:
    case 0x5B/* [ */:
    case 0x5C/* \ */:
    case 0x5D/* ] */:
    case 0x5E/* ^ */:
    case 0x5F/* _ */:
    case 0x60/* ` */:
    case 0x7B/* { */:
    case 0x7C/* | */:
    case 0x7D/* } */:
    case 0x7E/* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // Trim and collapse whitespace
  //
  str = str.trim().replace(/\s+/g, ' ');

  // In node v10 'ẞ'.toLowerCase() === 'Ṿ', which is presumed to be a bug
  // fixed in v12 (couldn't find any details).
  //
  // So treat this one as a special case
  // (remove this when node v10 is no longer supported).
  //
  if ('ẞ'.toLowerCase() === 'Ṿ') {
    str = str.replace(/ẞ/g, 'ß');
  }

  // .toLowerCase().toUpperCase() should get rid of all differences
  // between letter variants.
  //
  // Simple .toLowerCase() doesn't normalize 125 code points correctly,
  // and .toUpperCase doesn't normalize 6 of them (list of exceptions:
  // İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently
  // uppercased versions).
  //
  // Here's an example showing how it happens. Lets take greek letter omega:
  // uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)
  //
  // Unicode entries:
  // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;
  // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398
  // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398
  // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;
  //
  // Case-insensitive comparison should treat all of them as equivalent.
  //
  // But .toLowerCase() doesn't change ϑ (it's already lowercase),
  // and .toUpperCase() doesn't change ϴ (already uppercase).
  //
  // Applying first lower then upper case normalizes any character:
  // '\u0398\u03f4\u03b8\u03d1'.toLowerCase().toUpperCase() === '\u0398\u0398\u0398\u0398'
  //
  // Note: this is equivalent to unicode case folding; unicode normalization
  // is a different step that is not required here.
  //
  // Final result should be uppercased, because it's later stored in an object
  // (this avoid a conflict with Object.prototype members,
  // most notably, `__proto__`)
  //
  return str.toLowerCase().toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib                 = {};
exports.lib.mdurl           = mdurl$1;
exports.lib.ucmicro         = uc_micro;

exports.assign              = assign;
exports.isString            = isString;
exports.has                 = has;
exports.unescapeMd          = unescapeMd;
exports.unescapeAll         = unescapeAll;
exports.isValidEntityCode   = isValidEntityCode;
exports.fromCodePoint       = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml          = escapeHtml;
exports.arrayReplaceAt      = arrayReplaceAt;
exports.isSpace             = isSpace;
exports.isWhiteSpace        = isWhiteSpace;
exports.isMdAsciiPunct      = isMdAsciiPunct;
exports.isPunctChar         = isPunctChar;
exports.escapeRE            = escapeRE;
exports.normalizeReference  = normalizeReference;
}(utils$1));

var helpers$1 = {};

var parse_link_label = function parseLinkLabel(state, start, disableNested) {
  var level, found, marker, prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
      if (prevPos === state.pos - 1) {
        // increase level if we find text `[`, which is not a part of any token
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

var unescapeAll$2 = utils$1.unescapeAll;


var parse_link_destination = function parseLinkDestination(str, pos, max) {
  var code, level,
      lines = 0,
      start = pos,
      result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ''
      };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
    pos++;
    while (pos < max) {
      code = str.charCodeAt(pos);
      if (code === 0x0A /* \n */) { return result; }
      if (code === 0x3C /* < */) { return result; }
      if (code === 0x3E /* > */) {
        result.pos = pos + 1;
        result.str = unescapeAll$2(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code === 0x5C /* \ */ && pos + 1 < max) {
        pos += 2;
        continue;
      }

      pos++;
    }

    // no closing '>'
    return result;
  }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) { break; }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) { break; }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 0x20) { break; }
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
      level++;
      if (level > 32) { return result; }
    }

    if (code === 0x29 /* ) */) {
      if (level === 0) { break; }
      level--;
    }

    pos++;
  }

  if (start === pos) { return result; }
  if (level !== 0) { return result; }

  result.str = unescapeAll$2(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

var unescapeAll$1 = utils$1.unescapeAll;


var parse_link_title = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ''
      };

  if (pos >= max) { return result; }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return result; }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) { marker = 0x29; }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll$1(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x28 /* ( */ && marker === 0x29 /* ) */) {
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

helpers$1.parseLinkLabel       = parse_link_label;
helpers$1.parseLinkDestination = parse_link_destination;
helpers$1.parseLinkTitle       = parse_link_title;

/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/


var assign$1          = utils$1.assign;
var unescapeAll     = utils$1.unescapeAll;
var escapeHtml      = utils$1.escapeHtml;


////////////////////////////////////////////////////////////////////////////////

var default_rules = {};


default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return  '<code' + slf.renderAttrs(token) + '>' +
          escapeHtml(tokens[idx].content) +
          '</code>';
};


default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return  '<pre' + slf.renderAttrs(token) + '><code>' +
          escapeHtml(tokens[idx].content) +
          '</code></pre>\n';
};


default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      langAttrs = '',
      highlighted, i, arr, tmpAttrs, tmpToken;

  if (info) {
    arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join('');
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without modifying original token.
  // May be, one day we will add .deepClone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i        = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push([ 'class', options.langPrefix + langName ]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return  '<pre><code' + slf.renderAttrs(tmpToken) + '>'
          + highlighted
          + '</code></pre>\n';
  }


  return  '<pre><code' + slf.renderAttrs(token) + '>'
        + highlighted
        + '</code></pre>\n';
};


default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] =
    slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};


default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n';
};


default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};


default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};


/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer$1() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independent static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign$1({}, default_rules);
}


/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer$1.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) { return ''; }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};


/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer$1.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;

        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};


/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer$1.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};


/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer$1.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    } else if (tokens[i].type === 'softbreak') {
      result += '\n';
    }
  }

  return result;
};


/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer$1.prototype.render = function (tokens, options, env) {
  var i, len, type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

var renderer = Renderer$1;

/**
 * class Ruler
 *
 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
 *
 * - keep rules in defined order
 * - assign the name to each rule
 * - enable/disable rules
 * - add/replace rules
 * - allow assign rules to additional named chains (in the same)
 * - cacheing lists of active rules
 *
 * You will not need use this class directly until write plugins. For simple
 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
 * [[MarkdownIt.use]].
 **/


/**
 * new Ruler()
 **/
function Ruler$3() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler$3.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};


// Build rules lookup cache
//
Ruler$3.prototype.__compile__ = function () {
  var self = this;
  var chains = [ '' ];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) { return; }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) { return; }

      if (chain && rule.alt.indexOf(chain) < 0) { return; }

      self.__cache__[chain].push(rule.fn);
    });
  });
};


/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typographer replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler$3.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) { throw new Error('Parser rule not found: ' + name); }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};


/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler$3.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};


/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler$3.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler$3.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};


/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler$3.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) { return; }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};


/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler$3.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  this.__rules__.forEach(function (rule) { rule.enabled = false; });

  this.enable(list, ignoreInvalid);
};


/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler$3.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) { return; }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};


/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler$3.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

var ruler = Ruler$3;

// https://spec.commonmark.org/0.29/#line-ending
var NEWLINES_RE  = /\r\n?|\n/g;
var NULL_RE      = /\0/g;


var normalize = function normalize(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

var block = function block(state) {
  var token;

  if (state.inlineMode) {
    token          = new state.Token('inline', '', 0);
    token.content  = state.src;
    token.map      = [ 0, 1 ];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

var inline = function inline(state) {
  var tokens = state.tokens, tok, i, l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

var arrayReplaceAt = utils$1.arrayReplaceAt;


function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}


var linkify = function linkify(state) {
  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,
      level, htmlLinkLevel, url, fullUrl, urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) { return; }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' ||
        !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) { continue; }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) { continue; }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token         = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level   = level;
            nodes.push(token);
          }

          token         = new state.Token('link_open', 'a', 1);
          token.attrs   = [ [ 'href', fullUrl ] ];
          token.level   = level++;
          token.markup  = 'linkify';
          token.info    = 'auto';
          nodes.push(token);

          token         = new state.Token('text', '', 0);
          token.content = urlText;
          token.level   = level;
          nodes.push(token);

          token         = new state.Token('link_close', 'a', -1);
          token.level   = --level;
          token.markup  = 'linkify';
          token.info    = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token         = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level   = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i, token, inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i, token, inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content
          .replace(/\+-/g, '±')
          // .., ..., ....... -> …
          // but ?..... & !..... -> ?.. & !..
          .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..')
          .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
          // em-dash
          .replace(/(^|[^-])---(?=[^-]|$)/mg, '$1\u2014')
          // en-dash
          .replace(/(^|\s)--(?=\s|$)/mg, '$1\u2013')
          .replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, '$1\u2013');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}


var replacements = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) { return; }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') { continue; }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }

  }
};

var isWhiteSpace$1   = utils$1.isWhiteSpace;
var isPunctChar$1    = utils$1.isPunctChar;
var isMdAsciiPunct$1 = utils$1.isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */


function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,
      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,
      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) { break; }
    }
    stack.length = j + 1;

    if (token.type !== 'text') { continue; }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER:
    while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) { break; }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = (t[0] === "'");

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20
          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20
          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace$1(lastChar);
      isNextWhiteSpace = isWhiteSpace$1(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
          // special case: 1"" - count first quote as an inch
          canClose = canOpen = false;
        }
      }

      if (canOpen && canClose) {
        // Replace quotes in the middle of punctuation sequence, but not
        // in the middle of the words, i.e.:
        //
        // 1. foo " bar " baz - not replaced
        // 2. foo-"-bar-"-baz - replaced
        // 3. foo"bar"baz     - not replaced
        //
        canOpen = isLastPunctChar;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) { break; }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(
              tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) { pos += openQuote.length - 1; }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}


var smartquotes = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) { return; }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' ||
        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/
function Token$3(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type     = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag      = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs    = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map      = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting  = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level    = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content  = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup   = '';

  /**
   * Token#info -> String
   *
   * Additional information:
   *
   * - Info string for "fence" tokens
   * - The value "auto" for autolink "link_open" and "link_close" tokens
   * - The string value of the item marker for ordered-list "list_item_open" tokens
   **/
  this.info     = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta     = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block    = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden   = false;
}


/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token$3.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) { return -1; }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) { return i; }
  }
  return -1;
};


/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token$3.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [ attrData ];
  }
};


/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token$3.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [ name, value ];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};


/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token$3.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name), value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};


/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token$3.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([ name, value ]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};


var token = Token$3;

var Token$2 = token;


function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token$2;


var state_core = StateCore;

/** internal
 * class Core
 *
 * Top-level rules executor. Glues block/inline parsers and does intermediate
 * transformations.
 **/


var Ruler$2  = ruler;


var _rules$2 = [
  [ 'normalize',      normalize      ],
  [ 'block',          block          ],
  [ 'inline',         inline         ],
  [ 'linkify',        linkify        ],
  [ 'replacements',   replacements   ],
  [ 'smartquotes',    smartquotes    ]
];


/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler$2();

  for (var i = 0; i < _rules$2.length; i++) {
    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
  }
}


/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = state_core;


var parser_core = Core;

var isSpace$a = utils$1.isSpace;


function getLine(state, line) {
  var pos = state.bMarks[line] + state.tShift[line],
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      isEscaped = false,
      lastPos = 0,
      current = '';

  ch  = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x7c/* | */) {
      if (!isEscaped) {
        // pipe separating cells, '|'
        result.push(current + str.substring(lastPos, pos));
        current = '';
        lastPos = pos + 1;
      } else {
        // escaped pipe, '\|'
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }

    isEscaped = (ch === 0x5c/* \ */);
    pos++;

    ch = str.charCodeAt(pos);
  }

  result.push(current + str.substring(lastPos));

  return result;
}


var table = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, l, nextLine, columns, columnCount, token,
      aligns, t, tableLines, tbodyLines, oldParentType, terminate,
      terminatorRules, firstCh, secondCh;

  // should have at least two lines
  if (startLine + 2 > endLine) { return false; }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) { return false; }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false; }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) { return false; }

  firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 0x7C/* | */ && firstCh !== 0x2D/* - */ && firstCh !== 0x3A/* : */) { return false; }

  if (pos >= state.eMarks[nextLine]) { return false; }

  secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 0x7C/* | */ && secondCh !== 0x2D/* - */ && secondCh !== 0x3A/* : */ && !isSpace$a(secondCh)) {
    return false;
  }

  // if first character is '-', then second character must not be a space
  // (due to parsing ambiguity with list)
  if (firstCh === 0x2D/* - */ && isSpace$a(secondCh)) { return false; }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace$a(ch)) { return false; }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) { return false; }
    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {
      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');
    } else if (t.charCodeAt(0) === 0x3A/* : */) {
      aligns.push('left');
    } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) { return false; }
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === '') columns.shift();
  if (columns.length && columns[columns.length - 1] === '') columns.pop();

  // header row will define an amount of columns in the entire table,
  // and align row should be exactly the same (the rest of the rows can differ)
  columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) { return false; }

  if (silent) { return true; }

  oldParentType = state.parentType;
  state.parentType = 'table';

  // use 'blockquote' lists for termination because it's
  // the most similar to tables
  terminatorRules = state.md.block.ruler.getRules('blockquote');

  token     = state.push('table_open', 'table', 1);
  token.map = tableLines = [ startLine, 0 ];

  token     = state.push('thead_open', 'thead', 1);
  token.map = [ startLine, startLine + 1 ];

  token     = state.push('tr_open', 'tr', 1);
  token.map = [ startLine, startLine + 1 ];

  for (i = 0; i < columns.length; i++) {
    token          = state.push('th_open', 'th', 1);
    if (aligns[i]) {
      token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
    }

    token          = state.push('inline', '', 0);
    token.content  = columns[i].trim();
    token.children = [];

    token          = state.push('th_close', 'th', -1);
  }

  token     = state.push('tr_close', 'tr', -1);
  token     = state.push('thead_close', 'thead', -1);

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) { break; }

    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) { break; }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) { break; }
    if (state.sCount[nextLine] - state.blkIndent >= 4) { break; }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === '') columns.shift();
    if (columns.length && columns[columns.length - 1] === '') columns.pop();

    if (nextLine === startLine + 2) {
      token     = state.push('tbody_open', 'tbody', 1);
      token.map = tbodyLines = [ startLine + 2, 0 ];
    }

    token     = state.push('tr_open', 'tr', 1);
    token.map = [ nextLine, nextLine + 1 ];

    for (i = 0; i < columnCount; i++) {
      token          = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
      }

      token          = state.push('inline', '', 0);
      token.content  = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token          = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }

  if (tbodyLines) {
    token = state.push('tbody_close', 'tbody', -1);
    tbodyLines[1] = nextLine;
  }

  token = state.push('table_close', 'table', -1);
  tableLines[1] = nextLine;

  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
};

var code = function code(state, startLine, endLine/*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) { return false; }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token         = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + '\n';
  token.map     = [ startLine, state.line ];

  return true;
};

var fence = function fence(state, startLine, endLine, silent) {
  var marker, len, params, nextLine, mem, token, markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  if (pos + 3 > max) { return false; }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {
    return false;
  }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) { return false; }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (marker === 0x60 /* ` */) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }

  // Since start is found, we can report success here in validation mode
  if (silent) { return true; }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) { continue; }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) { continue; }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) { continue; }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token         = state.push('fence', 'code', 0);
  token.info    = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup  = markup;
  token.map     = [ startLine, state.line ];

  return true;
};

var isSpace$9 = utils$1.isSpace;


var blockquote = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      isOutdented,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) { return true; }

  // set offset past spaces and ">"
  initial = offset = state.sCount[startLine] + 1;

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
    // ' >   test '
    //     ^ -- position start of line here:
    pos++;
    initial++;
    offset++;
    adjustTab = false;
    spaceAfterMarker = true;
  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
    spaceAfterMarker = true;

    if ((state.bsCount[startLine] + offset) % 4 === 3) {
      // '  >\t  test '
      //       ^ -- position start of line here (tab has width===1)
      pos++;
      initial++;
      offset++;
      adjustTab = false;
    } else {
      // ' >\t  test '
      //    ^ -- position start of line here + shift bsCount slightly
      //         to make extra space appear
      adjustTab = true;
    }
  } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [ state.bMarks[startLine] ];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace$9(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [ state.bsCount[startLine] ];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [ state.sCount[startLine] ];
  state.sCount[startLine] = offset - initial;

  oldTShift = [ state.tShift[startLine] ];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    isOutdented = state.sCount[nextLine] < state.blkIndent;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {
      // This line is inside the blockquote.

      // set offset past spaces and ">"
      initial = offset = state.sCount[nextLine] + 1;

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
        // ' >   test '
        //     ^ -- position start of line here:
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
        spaceAfterMarker = true;

        if ((state.bsCount[nextLine] + offset) % 4 === 3) {
          // '  >\t  test '
          //       ^ -- position start of line here (tab has width===1)
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          // ' >\t  test '
          //    ^ -- position start of line here + shift bsCount slightly
          //         to make extra space appear
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace$9(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) { break; }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token        = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map    = lines = [ startLine, 0 ];

  state.md.block.tokenize(state, startLine, nextLine);

  token        = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

var isSpace$8 = utils$1.isSpace;


var hr = function hr(state, startLine, endLine, silent) {
  var marker, cnt, ch, token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x5F/* _ */) {
    return false;
  }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace$8(ch)) { return false; }
    if (ch === marker) { cnt++; }
  }

  if (cnt < 3) { return false; }

  if (silent) { return true; }

  state.line = startLine + 1;

  token        = state.push('hr', 'hr', 0);
  token.map    = [ startLine, state.line ];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

var isSpace$7 = utils$1.isSpace;


// Search `[-+*][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x2B/* + */) {
    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace$7(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) { return -1; }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }

  for (;;) {
    // EOL -> fail
    if (pos >= max) { return -1; }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {

      // List marker should have no more than 9 digits
      // (prevents integer overflow in browsers)
      if (pos - start >= 10) { return -1; }

      continue;
    }

    // found valid marker
    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {
      break;
    }

    return -1;
  }


  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace$7(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i, l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}


var list = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldListIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  // Special case:
  //  - item 1
  //   - item 2
  //    - item 3
  //     - item 4
  //      - this one is a paragraph continuation
  if (state.listIndent >= 0 &&
      state.sCount[startLine] - state.listIndent >= 4 &&
      state.sCount[startLine] < state.blkIndent) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.sCount[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.slice(start, posAfterMarker - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;

  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;

  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) { return true; }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token       = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [ [ 'start', markerValue ] ];
    }

  } else {
    token       = state.push('bullet_list_open', 'ul', 1);
  }

  token.map    = listLines = [ startLine, 0 ];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 0x20) {
        offset++;
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) { indentAfterMarker = 1; }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token        = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map    = itemLines = [ startLine, 0 ];
    if (isOrdered) {
      token.info = state.src.slice(start, posAfterMarker - 1);
    }

    // change current state, then restore it after parser subcall
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldSCount = state.sCount[startLine];

    //  - example list
    // ^ listIndent position will be here
    //   ^ blkIndent position will be here
    //
    oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;

    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldSCount;
    state.tight = oldTight;

    token        = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) { break; }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) { break; }

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4) { break; }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
      start = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }
  }

  // Finalize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

var normalizeReference$2   = utils$1.normalizeReference;
var isSpace$6              = utils$1.isSpace;


var reference = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&
        state.src.charCodeAt(pos - 1) !== 0x5C/* \ */) {
      if (pos + 1 === max) { return false; }
      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }
      break;
    }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) { continue; }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
      return false;
    } else if (ch === 0x5D /* ] */) {
      labelEnd = pos;
      break;
    } else if (ch === 0x0A /* \n */) {
      lines++;
    } else if (ch === 0x5C /* \ */) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace$6(ch)) ; else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) { return false; }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) { return false; }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace$6(ch)) ; else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace$6(ch)) { break; }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace$6(ch)) { break; }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference$2(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) { return true; }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

var html_blocks = [
  'address',
  'article',
  'aside',
  'base',
  'basefont',
  'blockquote',
  'body',
  'caption',
  'center',
  'col',
  'colgroup',
  'dd',
  'details',
  'dialog',
  'dir',
  'div',
  'dl',
  'dt',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'frame',
  'frameset',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hr',
  'html',
  'iframe',
  'legend',
  'li',
  'link',
  'main',
  'menu',
  'menuitem',
  'nav',
  'noframes',
  'ol',
  'optgroup',
  'option',
  'p',
  'param',
  'section',
  'source',
  'summary',
  'table',
  'tbody',
  'td',
  'tfoot',
  'th',
  'thead',
  'title',
  'tr',
  'track',
  'ul'
];

var html_re = {};

var attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted      = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute   = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag    = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag   = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing  = '<[?][\\s\\S]*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata       = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE$1 = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +
                        '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

html_re.HTML_TAG_RE = HTML_TAG_RE$1;
html_re.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE$1;

var block_names = html_blocks;
var HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [
  [ /^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true ],
  [ /^<!--/,        /-->/,   true ],
  [ /^<\?/,         /\?>/,   true ],
  [ /^<![A-Z]/,     />/,     true ],
  [ /^<!\[CDATA\[/, /\]\]>/, true ],
  [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true ],
  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'),  /^$/, false ]
];


var html_block = function html_block(state, startLine, endLine, silent) {
  var i, nextLine, token, lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  if (!state.md.options.html) { return false; }

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }
  }

  if (i === HTML_SEQUENCES.length) { return false; }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) { break; }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) { nextLine++; }
        break;
      }
    }
  }

  state.line = nextLine;

  token         = state.push('html_block', '', 0);
  token.map     = [ startLine, nextLine ];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

var isSpace$5 = utils$1.isSpace;


var heading = function heading(state, startLine, endLine, silent) {
  var ch, level, tmp, token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  ch  = state.src.charCodeAt(pos);

  if (ch !== 0x23/* # */ || pos >= max) { return false; }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23/* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || (pos < max && !isSpace$5(ch))) { return false; }

  if (silent) { return true; }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token        = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map    = [ startLine, state.line ];

  token          = state.push('inline', '', 0);
  token.content  = state.src.slice(pos, max).trim();
  token.map      = [ startLine, state.line ];
  token.children = [];

  token        = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

var lheading = function lheading(state, startLine, endLine/*, silent*/) {
  var content, terminate, i, l, token, pos, max, level, marker,
      nextLine = startLine + 1, oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {
          pos = state.skipChars(pos, marker);
          pos = state.skipSpaces(pos);

          if (pos >= max) {
            level = (marker === 0x3D/* = */ ? 1 : 2);
            break;
          }
        }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) { continue; }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token          = state.push('heading_open', 'h' + String(level), 1);
  token.markup   = String.fromCharCode(marker);
  token.map      = [ startLine, state.line ];

  token          = state.push('inline', '', 0);
  token.content  = content;
  token.map      = [ startLine, state.line - 1 ];
  token.children = [];

  token          = state.push('heading_close', 'h' + String(level), -1);
  token.markup   = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

var paragraph = function paragraph(state, startLine/*, endLine*/) {
  var content, terminate, i, l, token, oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) { continue; }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token          = state.push('paragraph_open', 'p', 1);
  token.map      = [ startLine, state.line ];

  token          = state.push('inline', '', 0);
  token.content  = content;
  token.map      = [ startLine, state.line ];
  token.children = [];

  token          = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

var Token$1 = token;
var isSpace$4 = utils$1.isSpace;


function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md     = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = [];  // line begin offsets for fast jumps
  this.eMarks = [];  // line end offsets for fast jumps
  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)
  this.sCount = [];  // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent  = 0; // required block content indent (for example, if we are
                       // inside a list, it would be positioned after list marker)
  this.line       = 0; // line index in src
  this.lineMax    = 0; // lines count
  this.tight      = false;  // loose/tight mode for lists
  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)
  this.listIndent = -1; // indent of the current list block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace$4(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) { pos++; }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token$1(type, tag, nesting);
  token.block = true;

  if (nesting < 0) this.level--; // closing tag
  token.level = this.level;
  if (nesting > 0) this.level++; // opening tag

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace$4(ch)) { break; }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) { return pos; }

  while (pos > min) {
    if (!isSpace$4(this.src.charCodeAt(--pos))) { return pos + 1; }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) { break; }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) { return pos; }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i, lineIndent, ch, first, last, queue, lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace$4(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token$1;


var state_block = StateBlock;

/** internal
 * class ParserBlock
 *
 * Block-level tokenizer.
 **/


var Ruler$1           = ruler;


var _rules$1 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  [ 'table',      table,      [ 'paragraph', 'reference' ] ],
  [ 'code',       code ],
  [ 'fence',      fence,      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'blockquote', blockquote, [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'hr',         hr,         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'list',       list,       [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'reference',  reference ],
  [ 'html_block', html_block, [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'heading',    heading,    [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'lheading',   lheading ],
  [ 'paragraph',  paragraph ]
];


/**
 * new ParserBlock()
 **/
function ParserBlock$1() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler$1();

  for (var i = 0; i < _rules$1.length; i++) {
    this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() });
  }
}


// Generate tokens for input range
//
ParserBlock$1.prototype.tokenize = function (state, startLine, endLine) {
  var ok, i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) { break; }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) { break; }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) { break; }
    }

    // set state.tight if we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};


/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock$1.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) { return; }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};


ParserBlock$1.prototype.State = state_block;


var parser_block = ParserBlock$1;

// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A/* \n */:
    case 0x21/* ! */:
    case 0x23/* # */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x26/* & */:
    case 0x2A/* * */:
    case 0x2B/* + */:
    case 0x2D/* - */:
    case 0x3A/* : */:
    case 0x3C/* < */:
    case 0x3D/* = */:
    case 0x3E/* > */:
    case 0x40/* @ */:
    case 0x5B/* [ */:
    case 0x5C/* \ */:
    case 0x5D/* ] */:
    case 0x5E/* ^ */:
    case 0x5F/* _ */:
    case 0x60/* ` */:
    case 0x7B/* { */:
    case 0x7D/* } */:
    case 0x7E/* ~ */:
      return true;
    default:
      return false;
  }
}

var text = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) { return false; }

  if (!silent) { state.pending += state.src.slice(state.pos, pos); }

  state.pos = pos;

  return true;
};

var isSpace$3 = utils$1.isSpace;


var newline = function newline(state, silent) {
  var pmax, max, ws, pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A/* \n */) { return false; }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        // Find whitespaces tail of pending chars.
        ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 0x20) ws--;

        state.pending = state.pending.slice(0, ws);
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }

    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace$3(state.src.charCodeAt(pos))) { pos++; }

  state.pos = pos;
  return true;
};

var isSpace$2 = utils$1.isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) { ESCAPED.push(0); }

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'
  .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1; });


var _escape = function escape(state, silent) {
  var ch, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C/* \ */) { return false; }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) { state.pending += state.src[pos]; }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace$2(ch)) { break; }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) { state.pending += '\\'; }
  state.pos++;
  return true;
};

var backticks = function backtick(state, silent) {
  var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60/* ` */) { return false; }

  start = pos;
  pos++;
  max = state.posMax;

  // scan marker length
  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }

  marker = state.src.slice(start, pos);
  openerLength = marker.length;

  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent) state.pending += marker;
    state.pos += openerLength;
    return true;
  }

  matchStart = matchEnd = pos;

  // Nothing found in the cache, scan until the end of the line (or until marker is found)
  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    // scan marker length
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }

    closerLength = matchEnd - matchStart;

    if (closerLength === openerLength) {
      // Found matching closer length.
      if (!silent) {
        token     = state.push('code_inline', 'code', 0);
        token.markup  = marker;
        token.content = state.src.slice(pos, matchStart)
          .replace(/\n/g, ' ')
          .replace(/^ (.+) $/, '$1');
      }
      state.pos = matchEnd;
      return true;
    }

    // Some different length found, put it in cache as upper limit of where closer can be found
    state.backticks[closerLength] = matchStart;
  }

  // Scanned through the end, didn't find anything
  state.backticksScanned = true;

  if (!silent) state.pending += marker;
  state.pos += openerLength;
  return true;
};

var strikethrough = {};

// Insert each marker as a separate text token, and add it to delimiter list
//
strikethrough.tokenize = function strikethrough(state, silent) {
  var i, scanned, token, len, ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) { return false; }

  if (marker !== 0x7E/* ~ */) { return false; }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) { return false; }

  if (len % 2) {
    token         = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token         = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      length: 0,     // disable "rule of 3" length checks meant for emphasis
      token:  state.tokens.length - 1,
      end:    -1,
      open:   scanned.can_open,
      close:  scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};


function postProcess$1(state, delimiters) {
  var i, j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      max = delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E/* ~ */) {
      continue;
    }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token         = state.tokens[startDelim.token];
    token.type    = 's_open';
    token.tag     = 's';
    token.nesting = 1;
    token.markup  = '~~';
    token.content = '';

    token         = state.tokens[endDelim.token];
    token.type    = 's_close';
    token.tag     = 's';
    token.nesting = -1;
    token.markup  = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' &&
        state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
}


// Walk through delimiter list and replace text tokens with tags
//
strikethrough.postProcess = function strikethrough(state) {
  var curr,
      tokens_meta = state.tokens_meta,
      max = state.tokens_meta.length;

  postProcess$1(state, state.delimiters);

  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess$1(state, tokens_meta[curr].delimiters);
    }
  }
};

var emphasis = {};

// Insert each marker as a separate text token, and add it to delimiter list
//
emphasis.tokenize = function emphasis(state, silent) {
  var i, scanned, token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) { return false; }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token         = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // A position of the token this delimiter corresponds to.
      //
      token:  state.tokens.length - 1,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end:    -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open:   scanned.can_open,
      close:  scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};


function postProcess(state, delimiters) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      max = delimiters.length;

  for (i = max - 1; i >= 0; i--) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {
      continue;
    }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the previous delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i > 0 &&
               delimiters[i - 1].end === startDelim.end + 1 &&
               // check that first two markers match and adjacent
               delimiters[i - 1].marker === startDelim.marker &&
               delimiters[i - 1].token === startDelim.token - 1 &&
               // check that last two markers are adjacent (we can safely assume they match)
               delimiters[startDelim.end + 1].token === endDelim.token + 1;

    ch = String.fromCharCode(startDelim.marker);

    token         = state.tokens[startDelim.token];
    token.type    = isStrong ? 'strong_open' : 'em_open';
    token.tag     = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup  = isStrong ? ch + ch : ch;
    token.content = '';

    token         = state.tokens[endDelim.token];
    token.type    = isStrong ? 'strong_close' : 'em_close';
    token.tag     = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup  = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = '';
      state.tokens[delimiters[startDelim.end + 1].token].content = '';
      i--;
    }
  }
}


// Walk through delimiter list and replace text tokens with tags
//
emphasis.postProcess = function emphasis(state) {
  var curr,
      tokens_meta = state.tokens_meta,
      max = state.tokens_meta.length;

  postProcess(state, state.delimiters);

  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
};

var normalizeReference$1   = utils$1.normalizeReference;
var isSpace$1              = utils$1.isSpace;


var link = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      token,
      href = '',
      title = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) { return false; }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
    //
    // Inline link
    //

    // might have found a valid shortcut link, disable reference parsing
    parseReference = false;

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace$1(code) && code !== 0x0A) { break; }
    }
    if (pos >= max) { return false; }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = '';
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace$1(code) && code !== 0x0A) { break; }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace$1(code) && code !== 0x0A) { break; }
        }
      }
    }

    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
      // parsing a valid shortcut link failed, fallback to reference
      parseReference = true;
    }
    pos++;
  }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') { return false; }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) { label = state.src.slice(labelStart, labelEnd); }

    ref = state.env.references[normalizeReference$1(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token        = state.push('link_open', 'a', 1);
    token.attrs  = attrs = [ [ 'href', href ] ];
    if (title) {
      attrs.push([ 'title', title ]);
    }

    state.md.inline.tokenize(state);

    token        = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

var normalizeReference   = utils$1.normalizeReference;
var isSpace              = utils$1.isSpace;


var image = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) { return false; }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
    //
    // Inline link
    //

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace(code) && code !== 0x0A) { break; }
    }
    if (pos >= max) { return false; }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = '';
      }
    }

    // [link](  <href>  "title"  )
    //                ^^ skipping these spaces
    start = pos;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace(code) && code !== 0x0A) { break; }
    }

    // [link](  <href>  "title"  )
    //                  ^^^^^^^ parsing link title
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;

      // [link](  <href>  "title"  )
      //                         ^^ skipping these spaces
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) { break; }
      }
    } else {
      title = '';
    }

    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') { return false; }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) { label = state.src.slice(labelStart, labelEnd); }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(
      content,
      state.md,
      state.env,
      tokens = []
    );

    token          = state.push('image', 'img', 0);
    token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];
    token.children = tokens;
    token.content  = content;

    if (title) {
      attrs.push([ 'title', title ]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/*eslint max-len:0*/
var EMAIL_RE    = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;


var autolink = function autolink(state, silent) {
  var url, fullUrl, token, ch, start, max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  start = state.pos;
  max = state.posMax;

  for (;;) {
    if (++pos >= max) return false;

    ch = state.src.charCodeAt(pos);

    if (ch === 0x3C /* < */) return false;
    if (ch === 0x3E /* > */) break;
  }

  url = state.src.slice(start + 1, pos);

  if (AUTOLINK_RE.test(url)) {
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) { return false; }

    if (!silent) {
      token         = state.push('link_open', 'a', 1);
      token.attrs   = [ [ 'href', fullUrl ] ];
      token.markup  = 'autolink';
      token.info    = 'auto';

      token         = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token         = state.push('link_close', 'a', -1);
      token.markup  = 'autolink';
      token.info    = 'auto';
    }

    state.pos += url.length + 2;
    return true;
  }

  if (EMAIL_RE.test(url)) {
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) { return false; }

    if (!silent) {
      token         = state.push('link_open', 'a', 1);
      token.attrs   = [ [ 'href', fullUrl ] ];
      token.markup  = 'autolink';
      token.info    = 'auto';

      token         = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token         = state.push('link_close', 'a', -1);
      token.markup  = 'autolink';
      token.info    = 'auto';
    }

    state.pos += url.length + 2;
    return true;
  }

  return false;
};

var HTML_TAG_RE = html_re.HTML_TAG_RE;


function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
}


var html_inline = function html_inline(state, silent) {
  var ch, match, max, token,
      pos = state.pos;

  if (!state.md.options.html) { return false; }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||
      pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21/* ! */ &&
      ch !== 0x3F/* ? */ &&
      ch !== 0x2F/* / */ &&
      !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) { return false; }

  if (!silent) {
    token         = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

var entities          = entities$1;
var has               = utils$1.has;
var isValidEntityCode = utils$1.isValidEntityCode;
var fromCodePoint     = utils$1.fromCodePoint;


var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;


var entity = function entity(state, silent) {
  var ch, code, match, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
      match = state.src.slice(pos).match(DIGITAL_RE);
      if (match) {
        if (!silent) {
          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
        }
        state.pos += match[0].length;
        return true;
      }
    } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) { state.pending += entities[match[1]]; }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) { state.pending += '&'; }
  state.pos++;
  return true;
};

function processDelimiters(state, delimiters) {
  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,
      isOddMatch, lastJump,
      openersBottom = {},
      max = delimiters.length;

  if (!max) return;

  // headerIdx is the first delimiter of the current (where closer is) delimiter run
  var headerIdx = 0;
  var lastTokenIdx = -2; // needs any value lower than -1
  var jumps = [];

  for (closerIdx = 0; closerIdx < max; closerIdx++) {
    closer = delimiters[closerIdx];

    jumps.push(0);

    // markers belong to same delimiter run if:
    //  - they have adjacent tokens
    //  - AND markers are the same
    //
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }

    lastTokenIdx = closer.token;

    // Length is only used for emphasis-specific "rule of 3",
    // if it's not defined (in strikethrough or 3rd party plugins),
    // we can default it to 0 to disable those checks.
    //
    closer.length = closer.length || 0;

    if (!closer.close) continue;

    // Previously calculated lower bounds (previous fails)
    // for each marker, each delimiter length modulo 3,
    // and for whether this closer can be an opener;
    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [ -1, -1, -1, -1, -1, -1 ];
    }

    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length % 3)];

    openerIdx = headerIdx - jumps[headerIdx] - 1;

    newMinOpenerIdx = openerIdx;

    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      opener = delimiters[openerIdx];

      if (opener.marker !== closer.marker) continue;

      if (opener.open && opener.end < 0) {

        isOddMatch = false;

        // from spec:
        //
        // If one of the delimiters can both open and close emphasis, then the
        // sum of the lengths of the delimiter runs containing the opening and
        // closing delimiters must not be a multiple of 3 unless both lengths
        // are multiples of 3.
        //
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }

        if (!isOddMatch) {
          // If previous delimiter cannot be an opener, we can safely skip
          // the entire sequence in future checks. This is required to make
          // sure algorithm has linear complexity (see *_*_*_*_*_... case).
          //
          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?
            jumps[openerIdx - 1] + 1 :
            0;

          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;

          closer.open  = false;
          opener.end   = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          // treat next token as start of run,
          // it optimizes skips in **<...>**a**<...>** pathological case
          lastTokenIdx = -2;
          break;
        }
      }
    }

    if (newMinOpenerIdx !== -1) {
      // If match for this delimiter run failed, we want to set lower bound for
      // future lookups. This is required to make sure algorithm has linear
      // complexity.
      //
      // See details here:
      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442
      //
      openersBottom[closer.marker][(closer.open ? 3 : 0) + ((closer.length || 0) % 3)] = newMinOpenerIdx;
    }
  }
}


var balance_pairs = function link_pairs(state) {
  var curr,
      tokens_meta = state.tokens_meta,
      max = state.tokens_meta.length;

  processDelimiters(state, state.delimiters);

  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(state, tokens_meta[curr].delimiters);
    }
  }
};

var text_collapse = function text_collapse(state) {
  var curr, last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels after emphasis/strikethrough turns some text nodes
    // into opening/closing tags
    if (tokens[curr].nesting < 0) level--; // closing tag
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0) level++; // opening tag

    if (tokens[curr].type === 'text' &&
        curr + 1 < max &&
        tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) { tokens[last] = tokens[curr]; }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

var Token          = token;
var isWhiteSpace   = utils$1.isWhiteSpace;
var isPunctChar    = utils$1.isPunctChar;
var isMdAsciiPunct = utils$1.isMdAsciiPunct;


function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).
  this.cache = {};

  // List of emphasis-like delimiters for current tag
  this.delimiters = [];

  // Stack of delimiter lists for upper level tags
  this._prev_delimiters = [];

  // backtick length => last seen position
  this.backticks = {};
  this.backticksScanned = false;
}


// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};


// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);
  var token_meta = null;

  if (nesting < 0) {
    // closing tag
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }

  token.level = this.level;

  if (nesting > 0) {
    // opening tag
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  this.tokens_meta.push(token_meta);
  return token;
};


// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start, lastChar, nextChar, count, can_open, can_close,
      isLastWhiteSpace, isLastPunctChar,
      isNextWhiteSpace, isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking  || isNextPunctChar);
  } else {
    can_open  = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open:  can_open,
    can_close: can_close,
    length:    count
  };
};


// re-export Token class to use in block rules
StateInline.prototype.Token = Token;


var state_inline = StateInline;

/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/


var Ruler           = ruler;


////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [
  [ 'text',            text ],
  [ 'newline',         newline ],
  [ 'escape',          _escape ],
  [ 'backticks',       backticks ],
  [ 'strikethrough',   strikethrough.tokenize ],
  [ 'emphasis',        emphasis.tokenize ],
  [ 'link',            link ],
  [ 'image',           image ],
  [ 'autolink',        autolink ],
  [ 'html_inline',     html_inline ],
  [ 'entity',          entity ]
];

var _rules2 = [
  [ 'balance_pairs',   balance_pairs ],
  [ 'strikethrough',   strikethrough.postProcess ],
  [ 'emphasis',        emphasis.postProcess ],
  [ 'text_collapse',   text_collapse ]
];


/**
 * new ParserInline()
 **/
function ParserInline$1() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}


// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline$1.prototype.skipToken = function (state) {
  var ok, i, pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;


  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) { break; }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) { state.pos++; }
  cache[pos] = state.pos;
};


// Generate tokens for input range
//
ParserInline$1.prototype.tokenize = function (state) {
  var ok, i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) { break; }
      }
    }

    if (ok) {
      if (state.pos >= end) { break; }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};


/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline$1.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};


ParserInline$1.prototype.State = state_inline;


var parser_inline = ParserInline$1;

var re = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = regex$3.source;
  re.src_Cc  = regex$2.source;
  re.src_Z   = regex.source;
  re.src_P   = regex$4.source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [ re.src_Z, re.src_P, re.src_Cc ].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [ re.src_Z, re.src_Cc ].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uff5c]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter       = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 =

    '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth    = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port =

    '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator =

    '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path =

    '(?:' +
      '[/?#]' +
        '(?:' +
          '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-;]).|' +
          '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' +
          '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' +
          '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' +
          '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' +
          "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" +
          "\\'(?=" + re.src_pseudo_letter + '|[-]).|' +  // allow `I'm_king` if no pair found
          '\\.{2,}[a-zA-Z0-9%/&]|' + // google has many dots in "google search" links (#66, #81).
                                     // github has ... in commit range links,
                                     // Restrict to
                                     // - english
                                     // - percent-encoded
                                     // - parts of file path
                                     // - params separator
                                     // until more examples found.
          '\\.(?!' + re.src_ZCc + '|[.]).|' +
          (opts && opts['---'] ?
            '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
            :
            '\\-+|'
          ) +
          ',(?!' + re.src_ZCc + ').|' +       // allow `,,,` in paths
          ';(?!' + re.src_ZCc + ').|' +       // allow `;` if not followed by space-like char
          '\\!+(?!' + re.src_ZCc + '|[!]).|' +  // allow `!!!` in paths, but not at the end
          '\\?(?!' + re.src_ZCc + '|[?]).' +
        ')+' +
      '|\\/' +
    ')?';

  // Allow anything in markdown spec, forbid quote (") at the first position
  // because emails enclosed in quotes are far more common
  re.src_email_name =

    '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';

  re.src_xn =

    'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

    // Allow letters & digits (http://test1)
    '(?:' +
      re.src_xn +
      '|' +
      re.src_pseudo_letter + '{1,63}' +
    ')';

  re.src_domain =

    '(?:' +
      re.src_xn +
      '|' +
      '(?:' + re.src_pseudo_letter + ')' +
      '|' +
      '(?:' + re.src_pseudo_letter + '(?:-|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' +
    ')';

  re.src_host =

    '(?:' +
    // Don't need IP check, because digits are already allowed in normal domain names
    //   src_ip4 +
    // '|' +
      '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain/*_root*/ + ')' +
    ')';

  re.tpl_host_fuzzy =

    '(?:' +
      re.src_ip4 +
    '|' +
      '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' +
    ')';

  re.tpl_host_no_ip_fuzzy =

    '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict =

    re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict =

    re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict =

    re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict =

    re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict =

    re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;


  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test =

    'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy =

      '(^|' + text_separators + '|"|\\(|' + re.src_ZCc + ')' +
      '(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
      // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' +
      '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
      // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' +
      '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) { return Object.prototype.toString.call(obj); }
function isString(obj) { return _class(obj) === '[object String]'; }
function isObject(obj) { return _class(obj) === '[object Object]'; }
function isRegExp(obj) { return _class(obj) === '[object RegExp]'; }
function isFunction(obj) { return _class(obj) === '[object Function]'; }


function escapeRE(str) { return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&'); }

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};


function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}


var defaultSchemas = {
  'http:': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http =  new RegExp(
          '^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'
        );
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:':  'http:',
  'ftp:':    'http:',
  '//':      {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
      // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http =  new RegExp(
          '^' +
          self.re.src_auth +
          // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' +
          self.re.src_port +
          self.re.src_host_terminator +
          self.re.src_path,

          'i'
        );
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') { return 0; }
        if (pos >= 3 && text[pos - 3] === '/') { return 0; }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto =  new RegExp(
          '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'
        );
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__   = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re$1 = self.re = re(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re$1.src_xn);

  re$1.src_tlds = tlds.join('|');

  function untpl(tpl) { return tpl.replace('%TLDS%', re$1.src_tlds); }

  re$1.email_fuzzy      = RegExp(untpl(re$1.tpl_email_fuzzy), 'i');
  re$1.link_fuzzy       = RegExp(untpl(re$1.tpl_link_fuzzy), 'i');
  re$1.link_no_ip_fuzzy = RegExp(untpl(re$1.tpl_link_no_ip_fuzzy), 'i');
  re$1.host_fuzzy_test  = RegExp(untpl(re$1.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) { return; }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate =
      self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize =
      self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__)
                      .filter(function (name) {
                        // Filter disabled & fake schemas
                        return name.length > 0 && self.__compiled__[name];
                      })
                      .map(escapeRE)
                      .join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test   = RegExp('(^|(?!_)(?:[><\uff5c]|' + re$1.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uff5c]|' + re$1.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp(
    '(' + self.re.schema_test.source + ')|(' + self.re.host_fuzzy_test.source + ')|@',
    'i'
  );

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end   = self.__last_index__,
      text  = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema    = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index     = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw       = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text      = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url       = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}


/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt$1(schemas, options) {
  if (!(this instanceof LinkifyIt$1)) {
    return new LinkifyIt$1(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__           = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__          = -1;
  this.__last_index__     = -1; // Next scan position
  this.__schema__         = '';
  this.__text_cache__     = '';

  this.__schemas__        = assign({}, defaultSchemas, schemas);
  this.__compiled__       = {};

  this.__tlds__           = tlds_default;
  this.__tlds_replaced__  = false;

  this.re = {};

  compile(this);
}


/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt$1.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};


/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt$1.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};


/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt$1.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__      = -1;

  if (!text.length) { return false; }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__     = m[2];
        this.__index__      = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__     = '';
            this.__index__      = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next  = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ ||
            (shift === this.__index__ && next > this.__last_index__)) {
          this.__schema__     = 'mailto:';
          this.__index__      = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};


/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt$1.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};


/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt$1.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};


/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt$1.prototype.match = function match(text) {
  var shift = 0, result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};


/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt$1.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [ list ];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list)
                                  .sort()
                                  .filter(function (el, idx, arr) {
                                    return el !== arr[idx - 1];
                                  })
                                  .reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt$1.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) { match.url = 'http://' + match.url; }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};


/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt$1.prototype.onCompile = function onCompile() {
};


var linkifyIt = LinkifyIt$1;

var _default = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   100            // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

var zero = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'normalize',
        'block',
        'inline'
      ]
    },

    block: {
      rules: [
        'paragraph'
      ]
    },

    inline: {
      rules: [
        'text'
      ],
      rules2: [
        'balance_pairs',
        'text_collapse'
      ]
    }
  }
};

var commonmark = {
  options: {
    html:         true,         // Enable HTML tags in source
    xhtmlOut:     true,         // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'normalize',
        'block',
        'inline'
      ]
    },

    block: {
      rules: [
        'blockquote',
        'code',
        'fence',
        'heading',
        'hr',
        'html_block',
        'lheading',
        'list',
        'reference',
        'paragraph'
      ]
    },

    inline: {
      rules: [
        'autolink',
        'backticks',
        'emphasis',
        'entity',
        'escape',
        'html_inline',
        'image',
        'link',
        'newline',
        'text'
      ],
      rules2: [
        'balance_pairs',
        'emphasis',
        'text_collapse'
      ]
    }
  }
};

var utils        = utils$1;
var helpers      = helpers$1;
var Renderer     = renderer;
var ParserCore   = parser_core;
var ParserBlock  = parser_block;
var ParserInline = parser_inline;
var LinkifyIt    = linkifyIt;
var mdurl        = mdurl$1;
var punycode     = require$$8;


var config = {
  default: _default,
  zero: zero,
  commonmark: commonmark
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) { /**/ }
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) { /**/ }
    }
  }

  // add '%' to exclude list because of https://github.com/markdown-it/markdown-it/issues/720
  return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + '%');
}


/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(str, { language: lang, ignoreIllegals: true }).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(str, { language: lang, ignoreIllegals: true }).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;


  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);


  this.options = {};
  this.configure(presetName);

  if (options) { this.set(options); }
}


/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};


/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you will - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this, presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) { throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name'); }
  }

  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\'t be empty'); }

  if (presets.options) { self.set(presets.options); }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};


/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) { list = [ list ]; }

  [ 'core', 'block', 'inline' ].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};


/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) { list = [ list ]; }

  [ 'core', 'block', 'inline' ].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};


/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};


/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and return list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};


/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};


/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};


/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};


var lib = MarkdownIt;

var markdownIt = lib;

declare type Markdown = ReturnType<typeof markdownIt>;

declare function container(md: Markdown): void;

declare function noticeboard(md: Markdown): void;

declare function codeLineNumbers(md: Markdown): void;

interface CollectCodeBlock {
    /**
     * Show the code block language.
     * @type {boolean}
     * @default true
     */
    lang?: boolean;
    /**
     * Shows the copy code block content button.
     * @type {boolean}
     * @default false
     */
    copy?: boolean;
    /**
     * Always expand the code block.
     * @type {boolean}
     * @default true
     */
    open?: boolean;
    /**
     * Copy the content button text.
     * @type {string}
     * @default: 'Copy'
     */
    copyText?: string;
    /**
     * The delimiter for the code block name.
     * @type {string}
     * @default ':'
     */
    separator?: string;
    /**
     * Display code block names.
     * @type {boolean}
     * @default false
     */
    blockName?: boolean;
}
declare function collectBlockCode(md: Markdown, { lang, copy, open, copyText, separator, blockName, }?: CollectCodeBlock): void;

declare function extendImageTitle(md: Markdown): void;

export { CollectCodeBlock, codeLineNumbers, collectBlockCode, container, extendImageTitle, noticeboard };
